# 04. 依赖对 Dependent Pairs

> **中英双语核心定义 | Bilingual Core Definitions**

## 核心定义 Core Definition

### 依赖对 Dependent Pairs

- **中文**：依赖对是第二个分量类型依赖于第一个分量值的对类型。它们用于表达存在量词和依赖数据，是依赖类型理论中表达"存在"概念的核心构造。
- **English**: Dependent pairs are pair types where the type of the second component depends on the value of the first component. They are used to express existential quantification and dependent data, serving as a core construct for expressing "existence" in dependent type theory.

### Σ类型 Sigma Types

- **中文**：Σ类型（依赖对类型）是依赖对的类型表示。它表达了"存在x，使得B(x)"的逻辑含义，是依赖类型理论中表达存在量词的形式化方法。
- **English**: Sigma types (dependent pair types) are the type representation of dependent pairs. They express the logical meaning of "there exists x such that B(x)" and are a formal method for expressing existential quantification in dependent type theory.

### 存在类型 Existential Types

- **中文**：存在类型是依赖对类型的一种特殊形式，用于表达"存在某个值满足特定条件"的概念。它们在程序验证和形式化证明中具有重要作用。
- **English**: Existential types are a special form of dependent pair types used to express the concept of "there exists some value satisfying a specific condition." They play an important role in program verification and formal proofs.

## 理论基础 Theoretical Foundation

### Σ类型的形式化定义 Formal Definition of Sigma Types

Σ类型在Lean中通过结构体语法实现：

```lean
-- Σ类型的基本语法
-- { x : A // B x } 表示依赖对类型

-- 依赖对类型的基本形式
structure Sigma (α : Type) (β : α → Type) : Type where
  fst : α
  snd : β fst

-- 更简洁的语法
def Sigma' (α : Type) (β : α → Type) : Type :=
  { p : α × β p.1 // p.2 : β p.1 }
```

### 依赖对的分类 Classification of Dependent Pairs

#### 1. 简单依赖对 Simple Dependent Pairs

```lean
-- 简单依赖对：第二个分量类型依赖于第一个分量值
def VecWithLength (α : Type) : Type :=
  { n : Nat // Vec α n }

-- 构造依赖对
def mkVecWithLength : (n : Nat) → Vec α n → VecWithLength α
  | n, vec => ⟨n, vec⟩

-- 使用依赖对
def getLength : VecWithLength α → Nat
  | ⟨n, _⟩ => n

def getVec : (vwl : VecWithLength α) → Vec α vwl.fst
  | ⟨_, vec⟩ => vec
```

#### 2. 复杂依赖对 Complex Dependent Pairs

```lean
-- 复杂依赖对：多个依赖关系
def MatrixWithDimensions (α : Type) : Type :=
  { m : Nat // { n : Nat // Matrix α m n } }

-- 构造复杂依赖对
def mkMatrixWithDimensions : (m n : Nat) → Matrix α m n → MatrixWithDimensions α
  | m, n, matrix => ⟨m, ⟨n, matrix⟩⟩

-- 使用复杂依赖对
def getRows : MatrixWithDimensions α → Nat
  | ⟨m, _⟩ => m

def getCols : MatrixWithDimensions α → Nat
  | ⟨_, ⟨n, _⟩⟩ => n

def getMatrix : (mwd : MatrixWithDimensions α) → Matrix α mwd.fst mwd.snd.fst
  | ⟨_, ⟨_, matrix⟩⟩ => matrix
```

#### 3. 存在类型 Existential Types

```lean
-- 存在类型：表达存在量词
def Exists (α : Type) (P : α → Prop) : Prop :=
  { x : α // P x }

-- 存在类型的构造
def exists_intro : (x : α) → P x → Exists α P
  | x, px => ⟨x, px⟩

-- 存在类型的消除
def exists_elim : Exists α P → (∀ x, P x → β) → β
  | ⟨x, px⟩, f => f x px
```

## 代码示例 Code Examples

### 基础依赖对 Basic Dependent Pairs

#### 向量长度对 Vector Length Pairs

```lean
-- 向量长度依赖对
def VecWithLength (α : Type) : Type :=
  { n : Nat // Vec α n }

-- 向量长度对的操作
def mkVecWithLength : (n : Nat) → Vec α n → VecWithLength α
  | n, vec => ⟨n, vec⟩

def getLength : VecWithLength α → Nat
  | ⟨n, _⟩ => n

def getVec : (vwl : VecWithLength α) → Vec α vwl.fst
  | ⟨_, vec⟩ => vec

def appendVecWithLength : VecWithLength α → VecWithLength α → VecWithLength α
  | ⟨n, vec1⟩, ⟨m, vec2⟩ => ⟨n + m, append vec1 vec2⟩

-- 使用示例
def example : VecWithLength Nat :=
  mkVecWithLength 3 (Vec.cons 1 (Vec.cons 2 (Vec.cons 3 Vec.nil)))
```

#### 有限类型对 Finite Type Pairs

```lean
-- 有限类型依赖对
def FinWithValue (n : Nat) : Type :=
  { i : Fin n // Nat }

-- 有限类型对的操作
def mkFinWithValue : (n : Nat) → Fin n → Nat → FinWithValue n
  | n, i, val => ⟨i, val⟩

def getIndex : FinWithValue n → Fin n
  | ⟨i, _⟩ => i

def getValue : FinWithValue n → Nat
  | ⟨_, val⟩ => val

def updateValue : FinWithValue n → Nat → FinWithValue n
  | ⟨i, _⟩, newVal => ⟨i, newVal⟩
```

### 高级依赖对 Advanced Dependent Pairs

#### 矩阵维度对 Matrix Dimension Pairs

```lean
-- 矩阵维度依赖对
def MatrixWithDimensions (α : Type) : Type :=
  { m : Nat // { n : Nat // Matrix α m n } }

-- 矩阵维度对的操作
def mkMatrixWithDimensions : (m n : Nat) → Matrix α m n → MatrixWithDimensions α
  | m, n, matrix => ⟨m, ⟨n, matrix⟩⟩

def getRows : MatrixWithDimensions α → Nat
  | ⟨m, _⟩ => m

def getCols : MatrixWithDimensions α → Nat
  | ⟨_, ⟨n, _⟩⟩ => n

def getMatrix : (mwd : MatrixWithDimensions α) → Matrix α mwd.fst mwd.snd.fst
  | ⟨_, ⟨_, matrix⟩⟩ => matrix

-- 矩阵运算
def matrixAddWithDimensions : MatrixWithDimensions Nat → MatrixWithDimensions Nat → Option (MatrixWithDimensions Nat)
  | ⟨m1, ⟨n1, matrix1⟩⟩, ⟨m2, ⟨n2, matrix2⟩⟩ => 
    if m1 = m2 && n1 = n2 then
      some ⟨m1, ⟨n1, matrixAdd m1 n1 matrix1 matrix2⟩⟩
    else
      none
```

#### 状态数据对 State Data Pairs

```lean
-- 状态数据依赖对
inductive State : Type where
  | idle : State
  | running : State
  | finished : State

inductive StateData : State → Type where
  | idleData : StateData State.idle
  | runningData : Nat → StateData State.running
  | finishedData : String → StateData State.finished

def StateWithData : Type :=
  { s : State // StateData s }

-- 状态数据对的操作
def mkStateWithData : (s : State) → StateData s → StateWithData
  | s, data => ⟨s, data⟩

def getState : StateWithData → State
  | ⟨s, _⟩ => s

def getStateData : (swd : StateWithData) → StateData swd.fst
  | ⟨_, data⟩ => data

-- 状态转换
def transitionStateWithData : StateWithData → StateWithData
  | ⟨State.idle, StateData.idleData⟩ => ⟨State.running, StateData.runningData 0⟩
  | ⟨State.running, StateData.runningData n⟩ => ⟨State.finished, StateData.finishedData s!"completed: {n}"⟩
  | ⟨State.finished, StateData.finishedData msg⟩ => ⟨State.finished, StateData.finishedData msg⟩
```

## 应用场景 Applications

### 1. 数组边界检查 Array Bounds Checking

```lean
-- 使用依赖对确保数组访问安全
def SafeArray (α : Type) : Type :=
  { n : Nat // { arr : Vec α n // n > 0 } }

def safeGet : SafeArray α → Fin (getLength (getArray (getSafeArray α))) → α
  | ⟨n, ⟨arr, _⟩⟩, i => Vec.get arr i

-- 构造安全数组
def mkSafeArray : (n : Nat) → Vec α n → Option (SafeArray α)
  | 0, _ => none
  | n + 1, arr => some ⟨n + 1, ⟨arr, sorry⟩⟩
```

### 2. 矩阵运算 Matrix Operations

```lean
-- 类型安全的矩阵运算
def MatrixOperation (α : Type) : Type :=
  { m : Nat // { n : Nat // { matrix : Matrix α m n // m > 0 && n > 0 } } }

def safeMatrixGet : MatrixOperation α → Fin (getRows (getMatrixOp α)) → Fin (getCols (getMatrixOp α)) → α
  | ⟨m, ⟨n, ⟨matrix, _⟩⟩⟩, i, j => matrixGet m n matrix i j
```

### 3. 协议验证 Protocol Verification

```lean
-- 协议状态验证
inductive ProtocolState : Type where
  | initial : ProtocolState
  | authenticated : ProtocolState
  | connected : ProtocolState

inductive ProtocolData : ProtocolState → Type where
  | initialData : ProtocolData ProtocolState.initial
  | authenticatedData : String → ProtocolData ProtocolState.authenticated
  | connectedData : String → ProtocolData ProtocolState.connected

def ValidProtocolState : Type :=
  { s : ProtocolState // ProtocolData s }

-- 协议状态验证
def validateProtocolState : (s : ProtocolState) → ProtocolData s → ValidProtocolState
  | s, data => ⟨s, data⟩
```

### 4. 数据库操作 Database Operations

```lean
-- 数据库表验证
inductive Table : Type where
  | users : Table
  | orders : Table

inductive TableData : Table → Type where
  | usersData : TableData Table.users
  | ordersData : TableData Table.orders

def ValidTable : Type :=
  { t : Table // TableData t }

-- 表操作验证
def validateTable : (t : Table) → TableData t → ValidTable
  | t, data => ⟨t, data⟩
```

## 对比分析 Comparison

### 与Haskell对类型对比

| 特性 | Lean | Haskell |
|------|------|---------|
| 依赖对 | 原生支持 | 有限支持 |
| 存在类型 | 完整支持 | 有限支持 |
| 类型推断 | 强大 | 强大 |
| 证明能力 | 完整 | 有限 |

### 与Coq对类型对比

| 特性 | Lean | Coq |
|------|------|-----|
| 依赖对 | 完整支持 | 完整支持 |
| 存在类型 | 完整支持 | 完整支持 |
| 语法简洁性 | 现代 | 传统 |
| 编程能力 | 强 | 中等 |

## 争议与批判 Controversies & Critique

### 复杂性 Complexity

- **争议**：依赖对增加了类型系统的复杂性
- **回应**：虽然复杂，但提供了更强的类型安全保证和更精确的程序属性表达

### 性能影响 Performance Impact

- **争议**：依赖对可能影响编译时间和运行时性能
- **回应**：Lean的优化编译器能够消除大部分依赖对开销

### 学习曲线 Learning Curve

- **争议**：依赖对的学习曲线陡峭
- **回应**：通过渐进式学习和实践可以掌握

## 前沿趋势 Frontier Trends

### 同伦类型论 Homotopy Type Theory

- **路径类型**：类型之间的等价关系
- **单值性公理**：类型等价性的公理
- **高阶结构**：更丰富的类型结构

### 计算类型论 Computational Type Theory

- **计算内容**：类型中的计算信息
- **规范形式**：值的规范表示
- **评估策略**：类型检查中的计算

### 依赖类型推断 Dependent Type Inference

- **自动推断**：更智能的类型推断
- **约束求解**：依赖类型约束的求解
- **错误信息**：更好的类型错误提示

## 交叉引用 Cross References

### 相关理论 Related Theories

- [依赖类型基础 Dependent Types Fundamentals](./01-依赖类型基础.md)
- [类型族 Type Families](./02-类型族.md)
- [依赖函数 Dependent Functions](./03-依赖函数.md)
- [类型推断 Type Inference](./05-类型推断.md)

### 相关语言 Related Languages

- [Haskell对类型 Haskell Pair Types](../../01-Haskell/README.md)
- [Coq对类型 Coq Pair Types](../../04-Coq/README.md)

## 参考文献 References

### 官方文档 Official Documentation

- [Lean 4 Manual](https://leanprover.github.io/lean4/doc/)
- [Theorem Proving in Lean 4](https://leanprover.github.io/theorem_proving_in_lean4/)

### 学术论文 Academic Papers

- [Dependent Pairs](https://en.wikipedia.org/wiki/Dependent_type#Dependent_pair_types)
- [Sigma Types](https://ncatlab.org/nlab/show/dependent+pair+type)

### 社区资源 Community Resources

- [Lean Community](https://leanprover-community.github.io/)
- [Mathlib Documentation](https://leanprover-community.github.io/mathlib_docs/)

---

`#DependentPairs #SigmaTypes #ExistentialTypes #Lean #VectorLengthPairs #FiniteTypePairs #MatrixDimensionPairs #StateDataPairs #ArrayBoundsChecking #MatrixOperations #ProtocolVerification #DatabaseOperations`
