# 01. 自然演绎 Natural Deduction

> **中英双语核心定义 | Bilingual Core Definitions**

## 核心定义 Core Definition

### 自然演绎 Natural Deduction

- **中文**：自然演绎是Lean的基础证明系统，通过引入和消除规则构建证明。它提供了直观的证明构造方法，符合数学家的思维习惯，是Lean中证明构造的主要方式。
- **English**: Natural deduction is Lean's foundational proof system, constructing proofs through introduction and elimination rules. It provides intuitive proof construction methods that align with mathematicians' thinking habits and is the primary way of constructing proofs in Lean.

### 引入规则 Introduction Rules

- **中文**：引入规则是自然演绎中构造复合命题的规则，包括合取引入、析取引入、蕴含引入、全称引入等。这些规则允许从更简单的命题构造更复杂的命题。
- **English**: Introduction rules are rules in natural deduction for constructing compound propositions, including conjunction introduction, disjunction introduction, implication introduction, universal introduction, etc. These rules allow constructing more complex propositions from simpler ones.

### 消除规则 Elimination Rules

- **中文**：消除规则是自然演绎中使用复合命题的规则，包括合取消除、析取消除、蕴含消除、全称消除等。这些规则允许从复合命题中提取信息。
- **English**: Elimination rules are rules in natural deduction for using compound propositions, including conjunction elimination, disjunction elimination, implication elimination, universal elimination, etc. These rules allow extracting information from compound propositions.

## 理论基础 Theoretical Foundation

### 自然演绎的形式化定义 Formal Definition of Natural Deduction

自然演绎在Lean中通过以下基本构造实现：

```lean
-- 自然演绎的基本构造
-- 1. 命题逻辑
namespace PropositionalLogic
  -- 合取引入
  theorem and_intro : P → Q → P ∧ Q :=
    fun hp hq => ⟨hp, hq⟩

  -- 合取消除
  theorem and_elim_left : P ∧ Q → P :=
    fun h => h.1

  theorem and_elim_right : P ∧ Q → Q :=
    fun h => h.2

  -- 析取引入
  theorem or_intro_left : P → P ∨ Q :=
    fun hp => Or.inl hp

  theorem or_intro_right : Q → P ∨ Q :=
    fun hq => Or.inr hq

  -- 析取消除
  theorem or_elim : P ∨ Q → (P → R) → (Q → R) → R :=
    fun hpq hpr hqr =>
      match hpq with
      | Or.inl hp => hpr hp
      | Or.inr hq => hqr hq

  -- 蕴含引入
  theorem imp_intro : (P → Q) → P → Q :=
    fun hpq hp => hpq hp

  -- 蕴含消除 (Modus Ponens)
  theorem imp_elim : P → (P → Q) → Q :=
    fun hp hpq => hpq hp

  -- 否定引入
  theorem not_intro : (P → False) → ¬P :=
    fun h => h

  -- 否定消除
  theorem not_elim : ¬P → P → False :=
    fun hnp hp => hnp hp
end PropositionalLogic
```

### 自然演绎的分类 Classification of Natural Deduction

#### 1. 命题逻辑 Propositional Logic

```lean
-- 命题逻辑
namespace PropositionalLogic
  -- 基本命题
  variable (P Q R : Prop)

  -- 合取规则
  theorem and_intro : P → Q → P ∧ Q :=
    fun hp hq => ⟨hp, hq⟩

  theorem and_elim_left : P ∧ Q → P :=
    fun h => h.1

  theorem and_elim_right : P ∧ Q → Q :=
    fun h => h.2

  -- 析取规则
  theorem or_intro_left : P → P ∨ Q :=
    fun hp => Or.inl hp

  theorem or_intro_right : Q → P ∨ Q :=
    fun hq => Or.inr hq

  theorem or_elim : P ∨ Q → (P → R) → (Q → R) → R :=
    fun hpq hpr hqr =>
      match hpq with
      | Or.inl hp => hpr hp
      | Or.inr hq => hqr hq

  -- 蕴含规则
  theorem imp_intro : (P → Q) → P → Q :=
    fun hpq hp => hpq hp

  theorem imp_elim : P → (P → Q) → Q :=
    fun hp hpq => hpq hp

  -- 否定规则
  theorem not_intro : (P → False) → ¬P :=
    fun h => h

  theorem not_elim : ¬P → P → False :=
    fun hnp hp => hnp hp
end PropositionalLogic
```

#### 2. 谓词逻辑 Predicate Logic

```lean
-- 谓词逻辑
namespace PredicateLogic
  -- 全称量词
  theorem forall_intro : (x : α) → P x → ∀ x, P x :=
    fun x hpx => fun y => hpx

  theorem forall_elim : (∀ x, P x) → (a : α) → P a :=
    fun h a => h a

  -- 存在量词
  theorem exists_intro : (a : α) → P a → ∃ x, P x :=
    fun a ha => ⟨a, ha⟩

  theorem exists_elim : (∃ x, P x) → (∀ x, P x → Q) → Q :=
    fun ⟨x, hpx⟩ h => h x hpx

  -- 等词规则
  theorem eq_intro : (a : α) → a = a :=
    fun a => rfl

  theorem eq_elim : (a b : α) → a = b → P a → P b :=
    fun a b hab hpa => hab ▸ hpa
end PredicateLogic
```

#### 3. 归纳类型 Inductive Types

```lean
-- 归纳类型
namespace InductiveTypes
  -- 自然数归纳
  theorem nat_induction : (P : Nat → Prop) → 
    P 0 → (∀ n, P n → P (n + 1)) → ∀ n, P n :=
    fun P h0 hstep n =>
      match n with
      | 0 => h0
      | n + 1 => hstep n (nat_induction P h0 hstep n)

  -- 列表归纳
  theorem list_induction : (P : List α → Prop) → 
    P [] → (∀ x xs, P xs → P (x :: xs)) → ∀ xs, P xs :=
    fun P hnil hcons xs =>
      match xs with
      | [] => hnil
      | x :: xs => hcons x xs (list_induction P hnil hcons xs)

  -- 树归纳
  inductive Tree (α : Type) : Type where
    | leaf : Tree α
    | node : α → Tree α → Tree α → Tree α

  theorem tree_induction : (P : Tree α → Prop) → 
    P Tree.leaf → (∀ x l r, P l → P r → P (Tree.node x l r)) → ∀ t, P t :=
    fun P hleaf hnode t =>
      match t with
      | Tree.leaf => hleaf
      | Tree.node x l r => hnode x l r (tree_induction P hleaf hnode l) (tree_induction P hleaf hnode r)
end InductiveTypes
```

## 代码示例 Code Examples

### 基础证明示例 Basic Proof Examples

#### 命题逻辑证明 Propositional Logic Proofs

```lean
-- 命题逻辑证明
namespace PropositionalProofs
  variable (P Q R : Prop)

  -- 交换律
  theorem and_comm : P ∧ Q → Q ∧ P :=
    fun h => ⟨h.2, h.1⟩

  theorem or_comm : P ∨ Q → Q ∨ P :=
    fun h =>
      match h with
      | Or.inl hp => Or.inr hp
      | Or.inr hq => Or.inl hq

  -- 结合律
  theorem and_assoc : (P ∧ Q) ∧ R → P ∧ (Q ∧ R) :=
    fun h => ⟨h.1.1, ⟨h.1.2, h.2⟩⟩

  theorem or_assoc : (P ∨ Q) ∨ R → P ∨ (Q ∨ R) :=
    fun h =>
      match h with
      | Or.inl hpq =>
        match hpq with
        | Or.inl hp => Or.inl hp
        | Or.inr hq => Or.inr (Or.inl hq)
      | Or.inr hr => Or.inr (Or.inr hr)

  -- 分配律
  theorem and_or_distrib : P ∧ (Q ∨ R) → (P ∧ Q) ∨ (P ∧ R) :=
    fun h =>
      match h.2 with
      | Or.inl hq => Or.inl ⟨h.1, hq⟩
      | Or.inr hr => Or.inr ⟨h.1, hr⟩

  theorem or_and_distrib : P ∨ (Q ∧ R) → (P ∨ Q) ∧ (P ∨ R) :=
    fun h =>
      match h with
      | Or.inl hp => ⟨Or.inl hp, Or.inl hp⟩
      | Or.inr ⟨hq, hr⟩ => ⟨Or.inr hq, Or.inr hr⟩

  -- 德摩根定律
  theorem demorgan_and : ¬(P ∧ Q) → ¬P ∨ ¬Q :=
    fun h => sorry -- 需要经典逻辑

  theorem demorgan_or : ¬(P ∨ Q) → ¬P ∧ ¬Q :=
    fun h => ⟨fun hp => h (Or.inl hp), fun hq => h (Or.inr hq)⟩
end PropositionalProofs
```

#### 谓词逻辑证明 Predicate Logic Proofs

```lean
-- 谓词逻辑证明
namespace PredicateProofs
  variable (α : Type) (P Q : α → Prop)

  -- 全称量词性质
  theorem forall_and : (∀ x, P x ∧ Q x) → (∀ x, P x) ∧ (∀ x, Q x) :=
    fun h => ⟨fun x => (h x).1, fun x => (h x).2⟩

  theorem forall_imp : (∀ x, P x → Q x) → (∀ x, P x) → (∀ x, Q x) :=
    fun h h' x => h x (h' x)

  -- 存在量词性质
  theorem exists_or : (∃ x, P x ∨ Q x) → (∃ x, P x) ∨ (∃ x, Q x) :=
    fun ⟨x, h⟩ =>
      match h with
      | Or.inl hpx => Or.inl ⟨x, hpx⟩
      | Or.inr hqx => Or.inr ⟨x, hqx⟩

  theorem exists_imp : (∃ x, P x → Q x) → (∀ x, P x) → (∃ x, Q x) :=
    fun ⟨x, h⟩ h' => ⟨x, h (h' x)⟩

  -- 等词性质
  theorem eq_symm : (a b : α) → a = b → b = a :=
    fun a b hab => hab.symm

  theorem eq_trans : (a b c : α) → a = b → b = c → a = c :=
    fun a b c hab hbc => hab.trans hbc
end PredicateProofs
```

### 高级证明示例 Advanced Proof Examples

#### 归纳证明 Inductive Proofs

```lean
-- 归纳证明
namespace InductiveProofs
  -- 自然数性质
  theorem add_zero : (n : Nat) → n + 0 = n :=
    fun n =>
      match n with
      | 0 => rfl
      | n + 1 => congrArg (· + 1) (add_zero n)

  theorem add_succ : (m n : Nat) → m + (n + 1) = (m + n) + 1 :=
    fun m n =>
      match m with
      | 0 => rfl
      | m + 1 => congrArg (· + 1) (add_succ m n)

  theorem add_comm : (m n : Nat) → m + n = n + m :=
    fun m n =>
      match m with
      | 0 => add_zero n
      | m + 1 => congrArg (· + 1) (add_comm m n)

  theorem add_assoc : (m n p : Nat) → (m + n) + p = m + (n + p) :=
    fun m n p =>
      match m with
      | 0 => rfl
      | m + 1 => congrArg (· + 1) (add_assoc m n p)

  -- 列表性质
  theorem length_append : (xs ys : List α) → 
    length (xs ++ ys) = length xs + length ys :=
    fun xs ys =>
      match xs with
      | [] => rfl
      | x :: xs => congrArg (· + 1) (length_append xs ys)

  theorem append_assoc : (xs ys zs : List α) → 
    (xs ++ ys) ++ zs = xs ++ (ys ++ zs) :=
    fun xs ys zs =>
      match xs with
      | [] => rfl
      | x :: xs => congrArg (x :: ·) (append_assoc xs ys zs)
end InductiveProofs
```

#### 案例分析证明 Case Analysis Proofs

```lean
-- 案例分析证明
namespace CaseAnalysisProofs
  -- 布尔值性质
  theorem bool_dichotomy : (b : Bool) → b = true ∨ b = false :=
    fun b =>
      match b with
      | true => Or.inl rfl
      | false => Or.inr rfl

  theorem bool_not_involutive : (b : Bool) → not (not b) = b :=
    fun b =>
      match b with
      | true => rfl
      | false => rfl

  -- 选项类型性质
  theorem option_cases : (x : Option α) → x = none ∨ ∃ a, x = some a :=
    fun x =>
      match x with
      | none => Or.inl rfl
      | some a => Or.inr ⟨a, rfl⟩

  theorem option_map_id : (x : Option α) → Option.map id x = x :=
    fun x =>
      match x with
      | none => rfl
      | some a => rfl

  -- 和类型性质
  theorem sum_cases : (x : α ⊕ β) → (∃ a, x = Sum.inl a) ∨ (∃ b, x = Sum.inr b) :=
    fun x =>
      match x with
      | Sum.inl a => Or.inl ⟨a, rfl⟩
      | Sum.inr b => Or.inr ⟨b, rfl⟩
end CaseAnalysisProofs
```

## 应用场景 Applications

### 1. 数学证明 Mathematical Proofs

```lean
-- 数学证明
namespace MathematicalProofs
  -- 数论证明
  theorem even_plus_even : (m n : Nat) → Even m → Even n → Even (m + n) :=
    fun m n hm hn =>
      match hm, hn with
      | ⟨k, hk⟩, ⟨l, hl⟩ => ⟨k + l, by rw [hk, hl, add_mul]⟩

  theorem odd_plus_odd : (m n : Nat) → Odd m → Odd n → Even (m + n) :=
    fun m n hm hn =>
      match hm, hn with
      | ⟨k, hk⟩, ⟨l, hl⟩ => ⟨k + l + 1, by rw [hk, hl, add_mul, add_mul, add_assoc]⟩

  -- 几何证明
  theorem triangle_inequality : (a b c : Nat) → 
    a + b > c → a + c > b → b + c > a → True :=
    fun a b c h1 h2 h3 => True.intro
end MathematicalProofs
```

### 2. 程序验证 Program Verification

```lean
-- 程序验证
namespace ProgramVerification
  -- 排序算法验证
  def sorted : List Nat → Prop :=
    fun xs => ∀ i j, i < j → nth xs i ≤ nth xs j

  theorem sort_preserves_length : (xs : List Nat) → 
    length (sort xs) = length xs :=
    fun xs => sorry -- 证明细节

  theorem sort_sorted : (xs : List Nat) → 
    sorted (sort xs) :=
    fun xs => sorry -- 证明细节

  -- 搜索算法验证
  theorem search_correct : (xs : List Nat) → (x : Nat) → 
    search xs x = (x ∈ xs) :=
    fun xs x => sorry -- 证明细节
end ProgramVerification
```

### 3. 类型理论证明 Type Theory Proofs

```lean
-- 类型理论证明
namespace TypeTheoryProofs
  -- 类型等价性
  theorem type_equiv_refl : (A : Type) → A ≃ A :=
    fun A => ⟨id, ⟨id, fun x => rfl, fun x => rfl⟩⟩

  theorem type_equiv_symm : (A B : Type) → A ≃ B → B ≃ A :=
    fun A B ⟨f, ⟨g, hgf, hfg⟩⟩ => ⟨g, ⟨f, hfg, hgf⟩⟩

  theorem type_equiv_trans : (A B C : Type) → A ≃ B → B ≃ C → A ≃ C :=
    fun A B C ⟨f1, ⟨g1, h1, h2⟩⟩ ⟨f2, ⟨g2, h3, h4⟩⟩ => 
      ⟨f2 ∘ f1, ⟨g1 ∘ g2, sorry, sorry⟩⟩
end TypeTheoryProofs
```

## 对比分析 Comparison

### 与其他证明系统对比

| 特性 | 自然演绎 | 序列演算 | 公理化系统 | 表列演算 |
|------|----------|----------|------------|----------|
| 直观性 | 高 | 中等 | 低 | 中等 |
| 自动化 | 中等 | 高 | 高 | 高 |
| 构造性 | 强 | 强 | 弱 | 中等 |
| 学习曲线 | 平缓 | 中等 | 陡峭 | 中等 |

### 与其他证明助手对比

| 特性 | Lean | Coq | Isabelle/HOL | Agda |
|------|------|-----|--------------|------|
| 自然演绎 | 优秀 | 优秀 | 优秀 | 优秀 |
| 自动化 | 高 | 高 | 高 | 中等 |
| 交互性 | 优秀 | 优秀 | 优秀 | 优秀 |
| 学习曲线 | 中等 | 中等 | 中等 | 中等 |

## 争议与批判 Controversies & Critique

### 优势 Advantages

- **直观性**：符合数学家的思维习惯
- **构造性**：所有证明都是构造性的
- **模块化**：证明可以分解为小的步骤
- **可读性**：证明结构清晰易懂

### 劣势 Disadvantages

- **冗长性**：某些证明可能很长
- **重复性**：存在重复的证明步骤
- **自动化限制**：某些情况下自动化程度有限
- **经典逻辑限制**：某些经典逻辑构造难以表达

## 前沿趋势 Frontier Trends

### 自动化证明 Automated Proving

- **智能策略**：使用机器学习改进证明策略
- **自动搜索**：自动搜索证明路径
- **模式识别**：识别证明模式
- **启发式方法**：改进启发式搜索

### 交互式证明 Interactive Proving

- **实时反馈**：提供实时证明反馈
- **智能提示**：智能提示下一步证明
- **错误诊断**：更好的错误诊断
- **可视化**：证明过程可视化

## 交叉引用 Cross References

### 相关理论 Related Theories

- [序列演算 Sequent Calculus](./02-序列演算.md)
- [归纳类型 Inductive Types](./03-归纳类型.md)
- [公理化 Axiomatization](./04-公理化.md)
- [证明理论 Proof Theory](./05-证明理论.md)

### 相关语言 Related Languages

- [Lean证明助手 Lean Proof Assistant](../02-Proof-Assistant/README.md)
- [Coq证明助手 Coq Proof Assistant](../../04-Coq/README.md)
- [Agda证明助手 Agda Proof Assistant](../../05-Agda/README.md)

## 参考文献 References

### 官方文档 Official Documentation

- [Lean 4 Manual](https://leanprover.github.io/lean4/doc/)
- [Theorem Proving in Lean 4](https://leanprover.github.io/theorem_proving_in_lean4/)

### 学术论文 Academic Papers

- Gentzen, G. (1935). Untersuchungen über das logische Schließen. Mathematische Zeitschrift, 39(1), 176-210.
- Prawitz, D. (1965). Natural deduction: A proof-theoretical study. Almqvist & Wiksell.
- Troelstra, A. S., & Schwichtenberg, H. (2000). Basic proof theory. Cambridge University Press.

### 社区资源 Community Resources

- [Lean Community](https://leanprover-community.github.io/)
- [Mathlib Documentation](https://leanprover-community.github.io/mathlib_docs/)

---

`#NaturalDeduction #Lean #ProofTheory #IntroductionRules #EliminationRules #PropositionalLogic #PredicateLogic #InductiveTypes #MathematicalProofs #ProgramVerification #TypeTheoryProofs`
