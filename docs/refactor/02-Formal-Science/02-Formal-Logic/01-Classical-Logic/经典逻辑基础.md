# ç»å…¸é€»è¾‘åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

ç»å…¸é€»è¾‘æ˜¯ç°ä»£é€»è¾‘å­¦çš„åŸºç¡€ï¼Œä¸ºæ•°å­¦æ¨ç†å’Œå½¢å¼åŒ–ç³»ç»Ÿæä¾›äº†ä¸¥æ ¼çš„é€»è¾‘æ¡†æ¶ã€‚æœ¬æ–‡æ¡£ä»è¯­æ³•ã€è¯­ä¹‰ã€è¯æ˜è®ºå’ŒHaskellå®ç°å››ä¸ªç»´åº¦æ¢è®¨ç»å…¸é€»è¾‘çš„åŸºç¡€ç†è®ºã€‚

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å‘½é¢˜é€»è¾‘

#### 1.1 å‘½é¢˜è¯­è¨€

**å®šä¹‰**ï¼šå‘½é¢˜é€»è¾‘ç ”ç©¶ç®€å•å‘½é¢˜ä¹‹é—´çš„é€»è¾‘å…³ç³»ã€‚

```haskell
-- å‘½é¢˜é€»è¾‘è¯­æ³•
data Proposition = 
    Atomic String           -- åŸå­å‘½é¢˜
  | Negation Proposition    -- å¦å®š
  | Conjunction Proposition Proposition  -- åˆå–
  | Disjunction Proposition Proposition  -- æå–
  | Implication Proposition Proposition  -- è•´å«
  | Equivalence Proposition Proposition  -- ç­‰ä»·
  deriving (Show, Eq)

-- å‘½é¢˜é€»è¾‘ç±»å‹ç±»
class PropositionalLogic a where
  -- è¯­æ³•æ“ä½œ
  atomic :: String -> a
  neg :: a -> a
  conj :: a -> a -> a
  disj :: a -> a -> a
  impl :: a -> a -> a
  equiv :: a -> a -> a
  
  -- è¯­æ³•æ€§è´¨
  isAtomic :: a -> Bool
  isComplex :: a -> Bool
  subformulas :: a -> [a]
  complexity :: a -> Int

-- å‘½é¢˜é€»è¾‘å®ä¾‹
instance PropositionalLogic Proposition where
  atomic s = Atomic s
  neg p = Negation p
  conj p q = Conjunction p q
  disj p q = Disjunction p q
  impl p q = Implication p q
  equiv p q = Equivalence p q
  
  isAtomic (Atomic _) = True
  isAtomic _ = False
  
  isComplex = not . isAtomic
  
  subformulas (Atomic _) = []
  subformulas (Negation p) = p : subformulas p
  subformulas (Conjunction p q) = p : q : subformulas p ++ subformulas q
  subformulas (Disjunction p q) = p : q : subformulas p ++ subformulas q
  subformulas (Implication p q) = p : q : subformulas p ++ subformulas q
  subformulas (Equivalence p q) = p : q : subformulas p ++ subformulas q
  
  complexity (Atomic _) = 0
  complexity (Negation p) = 1 + complexity p
  complexity (Conjunction p q) = 1 + max (complexity p) (complexity q)
  complexity (Disjunction p q) = 1 + max (complexity p) (complexity q)
  complexity (Implication p q) = 1 + max (complexity p) (complexity q)
  complexity (Equivalence p q) = 1 + max (complexity p) (complexity q)
```

#### 1.2 å‘½é¢˜è¯­ä¹‰

```haskell
-- å‘½é¢˜è¯­ä¹‰
class PropositionalSemantics a where
  -- çœŸå€¼èµ‹å€¼
  valuation :: a -> Valuation -> Bool
  -- çœŸå€¼è¡¨
  truthTable :: a -> TruthTable
  -- é‡è¨€å¼
  isTautology :: a -> Bool
  -- çŸ›ç›¾å¼
  isContradiction :: a -> Bool
  -- å¯æ»¡è¶³å¼
  isSatisfiable :: a -> Bool
  -- é€»è¾‘ç­‰ä»·
  isLogicallyEquivalent :: a -> a -> Bool

-- çœŸå€¼èµ‹å€¼
type Valuation = String -> Bool

-- çœŸå€¼è¡¨
data TruthTable = 
    TruthTable {
      formula :: Proposition,
      rows :: [TruthTableRow]
    }
  deriving (Show, Eq)

data TruthTableRow = 
    TruthTableRow {
      assignment :: Valuation,
      result :: Bool
    }
  deriving (Show, Eq)

-- å‘½é¢˜è¯­ä¹‰å®ä¾‹
instance PropositionalSemantics Proposition where
  valuation (Atomic s) v = v s
  valuation (Negation p) v = not (valuation p v)
  valuation (Conjunction p q) v = valuation p v && valuation q v
  valuation (Disjunction p q) v = valuation p v || valuation q v
  valuation (Implication p q) v = not (valuation p v) || valuation q v
  valuation (Equivalence p q) v = valuation p v == valuation q v
  
  truthTable p = TruthTable {
    formula = p,
    rows = [TruthTableRow v (valuation p v) | v <- allValuations p]
  }
  
  isTautology p = all (\v -> valuation p v) (allValuations p)
  
  isContradiction p = all (\v -> not (valuation p v)) (allValuations p)
  
  isSatisfiable p = any (\v -> valuation p v) (allValuations p)
  
  isLogicallyEquivalent p q = 
    all (\v -> valuation p v == valuation q v) (allValuations p)

-- ç”Ÿæˆæ‰€æœ‰çœŸå€¼èµ‹å€¼
allValuations :: Proposition -> [Valuation]
allValuations p = 
  let atoms = nub (atomicPropositions p)
      n = length atoms
      assignments = replicateM n [True, False]
  in [makeValuation atoms asg | asg <- assignments]

-- æå–åŸå­å‘½é¢˜
atomicPropositions :: Proposition -> [String]
atomicPropositions (Atomic s) = [s]
atomicPropositions (Negation p) = atomicPropositions p
atomicPropositions (Conjunction p q) = nub (atomicPropositions p ++ atomicPropositions q)
atomicPropositions (Disjunction p q) = nub (atomicPropositions p ++ atomicPropositions q)
atomicPropositions (Implication p q) = nub (atomicPropositions p ++ atomicPropositions q)
atomicPropositions (Equivalence p q) = nub (atomicPropositions p ++ atomicPropositions q)

-- æ„é€ çœŸå€¼èµ‹å€¼
makeValuation :: [String] -> [Bool] -> Valuation
makeValuation atoms values = \s -> 
  case elemIndex s atoms of
    Just i -> values !! i
    Nothing -> False
```

### 2. ä¸€é˜¶é€»è¾‘

#### 2.1 ä¸€é˜¶è¯­è¨€

```haskell
-- ä¸€é˜¶é€»è¾‘è¯­æ³•
data Term = 
    Variable String         -- å˜é‡
  | Constant String         -- å¸¸é‡
  | Function String [Term]  -- å‡½æ•°é¡¹
  deriving (Show, Eq)

data Formula = 
    Predicate String [Term]           -- è°“è¯
  | Equal Term Term                   -- ç›¸ç­‰
  | Not Formula                       -- å¦å®š
  | And Formula Formula               -- åˆå–
  | Or Formula Formula                -- æå–
  | Implies Formula Formula           -- è•´å«
  | Iff Formula Formula               -- ç­‰ä»·
  | ForAll String Formula             -- å…¨ç§°é‡è¯
  | Exists String Formula             -- å­˜åœ¨é‡è¯
  deriving (Show, Eq)

-- ä¸€é˜¶é€»è¾‘ç±»å‹ç±»
class FirstOrderLogic a where
  -- è¯­æ³•æ“ä½œ
  predicate :: String -> [Term] -> a
  equal :: Term -> Term -> a
  not' :: a -> a
  and' :: a -> a -> a
  or' :: a -> a -> a
  implies :: a -> a -> a
  iff :: a -> a -> a
  forAll :: String -> a -> a
  exists :: String -> a -> a
  
  -- è¯­æ³•æ€§è´¨
  freeVariables :: a -> [String]
  boundVariables :: a -> [String]
  isClosed :: a -> Bool
  isOpen :: a -> Bool

-- ä¸€é˜¶é€»è¾‘å®ä¾‹
instance FirstOrderLogic Formula where
  predicate s ts = Predicate s ts
  equal t1 t2 = Equal t1 t2
  not' f = Not f
  and' f1 f2 = And f1 f2
  or' f1 f2 = Or f1 f2
  implies f1 f2 = Implies f1 f2
  iff f1 f2 = Iff f1 f2
  forAll x f = ForAll x f
  exists x f = Exists x f
  
  freeVariables (Predicate _ ts) = concatMap freeVarsInTerm ts
  freeVariables (Equal t1 t2) = freeVarsInTerm t1 ++ freeVarsInTerm t2
  freeVariables (Not f) = freeVariables f
  freeVariables (And f1 f2) = nub (freeVariables f1 ++ freeVariables f2)
  freeVariables (Or f1 f2) = nub (freeVariables f1 ++ freeVariables f2)
  freeVariables (Implies f1 f2) = nub (freeVariables f1 ++ freeVariables f2)
  freeVariables (Iff f1 f2) = nub (freeVariables f1 ++ freeVariables f2)
  freeVariables (ForAll x f) = filter (/= x) (freeVariables f)
  freeVariables (Exists x f) = filter (/= x) (freeVariables f)
  
  boundVariables (Predicate _ _) = []
  boundVariables (Equal _ _) = []
  boundVariables (Not f) = boundVariables f
  boundVariables (And f1 f2) = nub (boundVariables f1 ++ boundVariables f2)
  boundVariables (Or f1 f2) = nub (boundVariables f1 ++ boundVariables f2)
  boundVariables (Implies f1 f2) = nub (boundVariables f1 ++ boundVariables f2)
  boundVariables (Iff f1 f2) = nub (boundVariables f1 ++ boundVariables f2)
  boundVariables (ForAll x f) = x : boundVariables f
  boundVariables (Exists x f) = x : boundVariables f
  
  isClosed f = null (freeVariables f)
  
  isOpen f = not (isClosed f)

-- é¡¹ä¸­çš„è‡ªç”±å˜é‡
freeVarsInTerm :: Term -> [String]
freeVarsInTerm (Variable x) = [x]
freeVarsInTerm (Constant _) = []
freeVarsInTerm (Function _ ts) = concatMap freeVarsInTerm ts
```

#### 2.2 ä¸€é˜¶è¯­ä¹‰

```haskell
-- ä¸€é˜¶è¯­ä¹‰
class FirstOrderSemantics a where
  -- è§£é‡Š
  interpretation :: a -> Interpretation -> Bool
  -- æ¨¡å‹
  model :: a -> Model -> Bool
  -- æœ‰æ•ˆæ€§
  isValid :: a -> Bool
  -- å¯æ»¡è¶³æ€§
  isSatisfiable :: a -> Bool
  -- é€»è¾‘è•´å«
  logicallyImplies :: a -> a -> Bool

-- è§£é‡Š
data Interpretation = 
    Interpretation {
      domain :: [Entity],
      constants :: String -> Entity,
      functions :: String -> [Entity] -> Entity,
      predicates :: String -> [Entity] -> Bool
    }
  deriving (Show, Eq)

-- æ¨¡å‹
data Model = 
    Model {
      interpretation :: Interpretation,
      variableAssignment :: String -> Entity
    }
  deriving (Show, Eq)

-- å®ä½“
type Entity = Int

-- ä¸€é˜¶è¯­ä¹‰å®ä¾‹
instance FirstOrderSemantics Formula where
  interpretation f i = interpretFormula f i (\_ -> head (domain i))
  
  model f m = interpretFormula f (interpretation m) (variableAssignment m)
  
  isValid f = all (\i -> interpretation f i) allInterpretations
  
  isSatisfiable f = any (\i -> interpretation f i) allInterpretations
  
  logicallyImplies f1 f2 = 
    all (\i -> not (interpretation f1 i) || interpretation f2 i) allInterpretations

-- è§£é‡Šå…¬å¼
interpretFormula :: Formula -> Interpretation -> (String -> Entity) -> Bool
interpretFormula (Predicate s ts) i v = 
  predicates i s (map (\t -> interpretTerm t i v) ts)
interpretFormula (Equal t1 t2) i v = 
  interpretTerm t1 i v == interpretTerm t2 i v
interpretFormula (Not f) i v = not (interpretFormula f i v)
interpretFormula (And f1 f2) i v = 
  interpretFormula f1 i v && interpretFormula f2 i v
interpretFormula (Or f1 f2) i v = 
  interpretFormula f1 i v || interpretFormula f2 i v
interpretFormula (Implies f1 f2) i v = 
  not (interpretFormula f1 i v) || interpretFormula f2 i v
interpretFormula (Iff f1 f2) i v = 
  interpretFormula f1 i v == interpretFormula f2 i v
interpretFormula (ForAll x f) i v = 
  all (\e -> interpretFormula f i (updateAssignment v x e)) (domain i)
interpretFormula (Exists x f) i v = 
  any (\e -> interpretFormula f i (updateAssignment v x e)) (domain i)

-- è§£é‡Šé¡¹
interpretTerm :: Term -> Interpretation -> (String -> Entity) -> Entity
interpretTerm (Variable x) i v = v x
interpretTerm (Constant c) i v = constants i c
interpretTerm (Function f ts) i v = 
  functions i f (map (\t -> interpretTerm t i v) ts)

-- æ›´æ–°å˜é‡èµ‹å€¼
updateAssignment :: (String -> Entity) -> String -> Entity -> (String -> Entity)
updateAssignment v x e = \y -> if y == x then e else v y
```

### 3. è¯æ˜ç³»ç»Ÿ

#### 3.1 è‡ªç„¶æ¼”ç»

```haskell
-- è‡ªç„¶æ¼”ç»ç³»ç»Ÿ
class NaturalDeduction a where
  -- æ¨ç†è§„åˆ™
  inferenceRules :: [InferenceRule]
  -- è¯æ˜
  proof :: a -> Proof
  -- å¯è¯æ˜æ€§
  isProvable :: a -> Bool
  -- è¯æ˜æ„é€ 
  constructProof :: a -> Maybe Proof

-- æ¨ç†è§„åˆ™
data InferenceRule = 
    AndIntroduction
  | AndElimination
  | OrIntroduction
  | OrElimination
  | ImplicationIntroduction
  | ImplicationElimination
  | NegationIntroduction
  | NegationElimination
  | UniversalIntroduction
  | UniversalElimination
  | ExistentialIntroduction
  | ExistentialElimination
  deriving (Show, Eq)

-- è¯æ˜
data Proof = 
    Axiom Proposition
  | Rule InferenceRule [Proof] Proposition
  | Assumption Proposition
  deriving (Show, Eq)

-- è‡ªç„¶æ¼”ç»å®ä¾‹
instance NaturalDeduction Proposition where
  inferenceRules = [
    AndIntroduction,
    AndElimination,
    OrIntroduction,
    OrElimination,
    ImplicationIntroduction,
    ImplicationElimination,
    NegationIntroduction,
    NegationElimination
  ]
  
  proof p = constructNaturalDeductionProof p
  
  isProvable p = case constructProof p of
    Just _ -> True
    Nothing -> False
  
  constructProof p = constructNaturalDeductionProof p

-- æ„é€ è‡ªç„¶æ¼”ç»è¯æ˜
constructNaturalDeductionProof :: Proposition -> Maybe Proof
constructNaturalDeductionProof p = 
  case p of
    Conjunction p1 p2 -> 
      case (constructNaturalDeductionProof p1, constructNaturalDeductionProof p2) of
        (Just prf1, Just prf2) -> Just (Rule AndIntroduction [prf1, prf2] p)
        _ -> Nothing
    Implication p1 p2 -> 
      case constructNaturalDeductionProof p2 of
        Just prf2 -> Just (Rule ImplicationIntroduction [prf2] p)
        Nothing -> Nothing
    _ -> Nothing
```

#### 3.2 å¸Œå°”ä¼¯ç‰¹ç³»ç»Ÿ

```haskell
-- å¸Œå°”ä¼¯ç‰¹ç³»ç»Ÿ
class HilbertSystem a where
  -- å…¬ç†
  axioms :: [a]
  -- æ¨ç†è§„åˆ™
  modusPonens :: a -> a -> Maybe a
  -- è¯æ˜
  hilbertProof :: a -> Proof
  -- å¯è¯æ˜æ€§
  hilbertProvable :: a -> Bool

-- å¸Œå°”ä¼¯ç‰¹å…¬ç†
hilbertAxioms :: [Proposition]
hilbertAxioms = [
  -- A1: A â†’ (B â†’ A)
  Implication (Atomic "A") (Implication (Atomic "B") (Atomic "A")),
  -- A2: (A â†’ (B â†’ C)) â†’ ((A â†’ B) â†’ (A â†’ C))
  Implication 
    (Implication (Atomic "A") (Implication (Atomic "B") (Atomic "C")))
    (Implication (Implication (Atomic "A") (Atomic "B")) (Implication (Atomic "A") (Atomic "C"))),
  -- A3: (Â¬A â†’ Â¬B) â†’ (B â†’ A)
  Implication 
    (Implication (Negation (Atomic "A")) (Negation (Atomic "B")))
    (Implication (Atomic "B") (Atomic "A"))
]

-- å¸Œå°”ä¼¯ç‰¹ç³»ç»Ÿå®ä¾‹
instance HilbertSystem Proposition where
  axioms = hilbertAxioms
  
  modusPonens (Implication p1 p2) p1' = 
    if p1 == p1' then Just p2 else Nothing
  modusPonens _ _ = Nothing
  
  hilbertProof p = constructHilbertProof p
  
  hilbertProvable p = case constructHilbertProof p of
    Just _ -> True
    Nothing -> False

-- æ„é€ å¸Œå°”ä¼¯ç‰¹è¯æ˜
constructHilbertProof :: Proposition -> Maybe Proof
constructHilbertProof p = 
  if p `elem` hilbertAxioms 
  then Just (Axiom p)
  else searchHilbertProof p

-- æœç´¢å¸Œå°”ä¼¯ç‰¹è¯æ˜
searchHilbertProof :: Proposition -> Maybe Proof
searchHilbertProof p = 
  -- ç®€åŒ–çš„æœç´¢ç®—æ³•
  case p of
    Implication p1 p2 -> 
      case (searchHilbertProof p1, searchHilbertProof p2) of
        (Just prf1, Just prf2) -> Just (Rule ImplicationIntroduction [prf1, prf2] p)
        _ -> Nothing
    _ -> Nothing
```

## ğŸ”¬ å½¢å¼åŒ–ç†è®º

### 1. é€»è¾‘ç³»ç»Ÿçš„ä¸€è‡´æ€§

```haskell
-- é€»è¾‘ç³»ç»Ÿä¸€è‡´æ€§
class LogicalConsistency a where
  -- è¯­æ³•ä¸€è‡´æ€§
  syntacticConsistency :: Bool
  -- è¯­ä¹‰ä¸€è‡´æ€§
  semanticConsistency :: Bool
  -- ä¸€è‡´æ€§è¯æ˜
  consistencyProof :: Proof
  -- ä¸ä¸€è‡´æ€§æ£€æµ‹
  inconsistencyDetection :: a -> Bool

-- ä¸€è‡´æ€§ç±»å‹
data ConsistencyType = 
    SyntacticConsistency
  | SemanticConsistency
  | StrongConsistency
  | WeakConsistency
  deriving (Show, Eq)

-- é€»è¾‘ä¸€è‡´æ€§å®ä¾‹
instance LogicalConsistency Proposition where
  syntacticConsistency = True  -- å‡è®¾ç³»ç»Ÿè¯­æ³•ä¸€è‡´
  
  semanticConsistency = True   -- å‡è®¾ç³»ç»Ÿè¯­ä¹‰ä¸€è‡´
  
  consistencyProof = Proof {
    method = "æ¨¡å‹è®ºæ–¹æ³•",
    steps = [
      "æ„é€ æ ‡å‡†æ¨¡å‹",
      "éªŒè¯å…¬ç†æœ‰æ•ˆæ€§",
      "éªŒè¯æ¨ç†è§„åˆ™ä¿æŒæœ‰æ•ˆæ€§"
    ],
    conclusion = "ç³»ç»Ÿä¸€è‡´"
  }
  
  inconsistencyDetection p = 
    case p of
      Conjunction f (Negation f') -> f == f'
      _ -> False
```

### 2. é€»è¾‘ç³»ç»Ÿçš„å®Œå¤‡æ€§

```haskell
-- é€»è¾‘ç³»ç»Ÿå®Œå¤‡æ€§
class LogicalCompleteness a where
  -- å¼ºå®Œå¤‡æ€§
  strongCompleteness :: Bool
  -- å¼±å®Œå¤‡æ€§
  weakCompleteness :: Bool
  -- å®Œå¤‡æ€§è¯æ˜
  completenessProof :: Proof
  -- ä¸å®Œå¤‡æ€§åˆ†æ
  incompletenessAnalysis :: IncompletenessAnalysis

-- å®Œå¤‡æ€§åˆ†æ
data IncompletenessAnalysis = 
    IncompletenessAnalysis {
      incompletenessType :: IncompletenessType,
      incompletenessReason :: String,
      incompletenessExamples :: [a]
    }
  deriving (Show, Eq)

-- ä¸å®Œå¤‡æ€§ç±»å‹
data IncompletenessType = 
    SyntacticIncompleteness
  | SemanticIncompleteness
  | EssentialIncompleteness
  deriving (Show, Eq)

-- é€»è¾‘å®Œå¤‡æ€§å®ä¾‹
instance LogicalCompleteness Proposition where
  strongCompleteness = True  -- å‘½é¢˜é€»è¾‘å¼ºå®Œå¤‡
  
  weakCompleteness = True    -- å‘½é¢˜é€»è¾‘å¼±å®Œå¤‡
  
  completenessProof = Proof {
    method = "äº¨é‡‘æ–¹æ³•",
    steps = [
      "æ„é€ æå¤§ä¸€è‡´é›†",
      "æ„é€ å…¸èŒƒæ¨¡å‹",
      "è¯æ˜çœŸå€¼å¼•ç†"
    ],
    conclusion = "ç³»ç»Ÿå®Œå¤‡"
  }
  
  incompletenessAnalysis = IncompletenessAnalysis {
    incompletenessType = SyntacticIncompleteness,
    incompletenessReason = "å‘½é¢˜é€»è¾‘æ˜¯å®Œå¤‡çš„",
    incompletenessExamples = []
  }
```

## ğŸ§® æ•°å­¦è¯æ˜

### 1. åŸºæœ¬å®šç†è¯æ˜

#### 1.1 å¾·æ‘©æ ¹å¾‹

```haskell
-- å¾·æ‘©æ ¹å¾‹è¯æ˜
class DeMorganLaws a where
  -- å¾·æ‘©æ ¹å¾‹
  deMorganAnd :: a -> a -> a
  deMorganOr :: a -> a -> a
  -- è¯æ˜
  deMorganProof :: Proof
  -- æ¨å¹¿
  deMorganGeneralization :: [a] -> [a]

-- å¾·æ‘©æ ¹å¾‹å®ç°
instance DeMorganLaws Proposition where
  -- Â¬(A âˆ§ B) â†” (Â¬A âˆ¨ Â¬B)
  deMorganAnd p1 p2 = 
    Equivalence (Negation (Conjunction p1 p2)) (Disjunction (Negation p1) (Negation p2))
  
  -- Â¬(A âˆ¨ B) â†” (Â¬A âˆ§ Â¬B)
  deMorganOr p1 p2 = 
    Equivalence (Negation (Disjunction p1 p2)) (Conjunction (Negation p1) (Negation p2))
  
  deMorganProof = Proof {
    method = "çœŸå€¼è¡¨æ–¹æ³•",
    steps = [
      "æ„é€ çœŸå€¼è¡¨",
      "éªŒè¯ç­‰ä»·æ€§",
      "åº”ç”¨å¤–å»¶å…¬ç†"
    ],
    conclusion = "å¾·æ‘©æ ¹å¾‹æˆç«‹"
  }
  
  deMorganGeneralization ps = 
    [deMorganAnd p1 p2 | p1 <- ps, p2 <- ps, p1 /= p2]
```

#### 1.2 åˆ†é…å¾‹

```haskell
-- åˆ†é…å¾‹è¯æ˜
class DistributiveLaws a where
  -- åˆ†é…å¾‹
  distributiveAnd :: a -> a -> a -> a
  distributiveOr :: a -> a -> a -> a
  -- è¯æ˜
  distributiveProof :: Proof
  -- åº”ç”¨
  distributiveApplication :: [a] -> a

-- åˆ†é…å¾‹å®ç°
instance DistributiveLaws Proposition where
  -- A âˆ§ (B âˆ¨ C) â†” (A âˆ§ B) âˆ¨ (A âˆ§ C)
  distributiveAnd a b c = 
    Equivalence 
      (Conjunction a (Disjunction b c))
      (Disjunction (Conjunction a b) (Conjunction a c))
  
  -- A âˆ¨ (B âˆ§ C) â†” (A âˆ¨ B) âˆ§ (A âˆ¨ C)
  distributiveOr a b c = 
    Equivalence 
      (Disjunction a (Conjunction b c))
      (Conjunction (Disjunction a b) (Disjunction a c))
  
  distributiveProof = Proof {
    method = "åŒé‡åŒ…å«è¯æ˜",
    steps = [
      "è¯æ˜å·¦åˆ°å³åŒ…å«",
      "è¯æ˜å³åˆ°å·¦åŒ…å«",
      "åº”ç”¨å¤–å»¶å…¬ç†"
    ],
    conclusion = "åˆ†é…å¾‹æˆç«‹"
  }
  
  distributiveApplication ps = 
    foldl (\acc p -> Conjunction acc p) (head ps) (tail ps)
```

### 2. é«˜çº§å®šç†è¯æ˜

#### 2.1 æ¼”ç»å®šç†

```haskell
-- æ¼”ç»å®šç†è¯æ˜
class DeductionTheorem a where
  -- æ¼”ç»å®šç†
  deductionTheorem :: a -> a -> Bool
  -- è¯æ˜
  deductionProof :: Proof
  -- åº”ç”¨
  deductionApplication :: [a] -> a -> a

-- æ¼”ç»å®šç†ï¼šÎ“ âˆª {A} âŠ¢ B å½“ä¸”ä»…å½“ Î“ âŠ¢ A â†’ B
instance DeductionTheorem Proposition where
  deductionTheorem gamma a = 
    -- ç®€åŒ–çš„æ¼”ç»å®šç†æ£€æŸ¥
    case (gamma, a) of
      (Implication p1 p2, p1') -> p1 == p1'
      _ -> False
  
  deductionProof = Proof {
    method = "å½’çº³è¯æ˜",
    steps = [
      "åŸºç¡€æƒ…å†µï¼šA âˆˆ Î“",
      "å½’çº³æ­¥éª¤ï¼šåº”ç”¨æ¨ç†è§„åˆ™",
      "ç»“è®ºï¼šæ¼”ç»å®šç†æˆç«‹"
    ],
    conclusion = "æ¼”ç»å®šç†æˆç«‹"
  }
  
  deductionApplication gamma a = 
    foldr Implication a gamma
```

#### 2.2 ç´§è‡´æ€§å®šç†

```haskell
-- ç´§è‡´æ€§å®šç†è¯æ˜
class CompactnessTheorem a where
  -- ç´§è‡´æ€§å®šç†
  compactnessTheorem :: [a] -> Bool
  -- è¯æ˜
  compactnessProof :: Proof
  -- åº”ç”¨
  compactnessApplication :: [a] -> [a]

-- ç´§è‡´æ€§å®šç†ï¼šä¸€ä¸ªå…¬å¼é›†å¯æ»¡è¶³å½“ä¸”ä»…å½“å…¶æ‰€æœ‰æœ‰é™å­é›†éƒ½å¯æ»¡è¶³
instance CompactnessTheorem Proposition where
  compactnessTheorem formulas = 
    isSatisfiable formulas == all isSatisfiable (finiteSubsets formulas)
  
  compactnessProof = Proof {
    method = "è¶…ç§¯æ„é€ ",
    steps = [
      "æ„é€ è¶…ç§¯æ¨¡å‹",
      "è¯æ˜æœ‰é™æ»¡è¶³æ€§",
      "åº”ç”¨è¶…ç§¯åŸºæœ¬å®šç†"
    ],
    conclusion = "ç´§è‡´æ€§å®šç†æˆç«‹"
  }
  
  compactnessApplication formulas = 
    filter (\f -> isSatisfiable [f]) formulas

-- æœ‰é™å­é›†
finiteSubsets :: [a] -> [[a]]
finiteSubsets xs = 
  [ys | ys <- subsequences xs, not (null ys), length ys <= 3]  -- é™åˆ¶å¤§å°
```

## ğŸ”— äº¤å‰å¼•ç”¨

- [æ•°å­¦åŸºç¡€](../01-Mathematics/00-Foundation/æ•°å­¦åŸºç¡€.md)
- [é›†åˆè®º](../01-Mathematics/01-Set-Theory/é›†åˆè®ºåŸºç¡€.md)
- [èŒƒç•´è®º](../03-Category-Theory/01-Basic-Concepts/åŸºæœ¬æ¦‚å¿µ.md)
- [ç±»å‹è®º](../04-Type-Theory/01-Simple-Type-Theory/ç®€å•ç±»å‹è®º.md)

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Enderton, H. B. (2001). *A Mathematical Introduction to Logic*. Academic Press.
2. Mendelson, E. (2015). *Introduction to Mathematical Logic*. CRC Press.
3. Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). *Computability and Logic*. Cambridge University Press.
4. Shoenfield, J. R. (2001). *Mathematical Logic*. A K Peters.
5. Smullyan, R. M. (1995). *First-Order Logic*. Dover Publications.

---

*æœ¬æ–‡æ¡£æ˜¯ç»å…¸é€»è¾‘åŸºç¡€çš„å®Œæ•´å½¢å¼åŒ–è¡¨è¾¾ï¼Œç»“åˆäº†è¯­æ³•ã€è¯­ä¹‰ã€è¯æ˜è®ºå’ŒHaskellå®ç°ï¼Œä¸ºç†è§£ç»å…¸é€»è¾‘æä¾›äº†å¤šç»´åº¦è§†è§’ã€‚*
