# 经典逻辑基础

## 📋 概述

经典逻辑是现代逻辑学的基础，为数学推理和形式化系统提供了严格的逻辑框架。本文档从语法、语义、证明论和Haskell实现四个维度探讨经典逻辑的基础理论。

## 🎯 核心概念

### 1. 命题逻辑

#### 1.1 命题语言

**定义**：命题逻辑研究简单命题之间的逻辑关系。

```haskell
-- 命题逻辑语法
data Proposition = 
    Atomic String           -- 原子命题
  | Negation Proposition    -- 否定
  | Conjunction Proposition Proposition  -- 合取
  | Disjunction Proposition Proposition  -- 析取
  | Implication Proposition Proposition  -- 蕴含
  | Equivalence Proposition Proposition  -- 等价
  deriving (Show, Eq)

-- 命题逻辑类型类
class PropositionalLogic a where
  -- 语法操作
  atomic :: String -> a
  neg :: a -> a
  conj :: a -> a -> a
  disj :: a -> a -> a
  impl :: a -> a -> a
  equiv :: a -> a -> a
  
  -- 语法性质
  isAtomic :: a -> Bool
  isComplex :: a -> Bool
  subformulas :: a -> [a]
  complexity :: a -> Int

-- 命题逻辑实例
instance PropositionalLogic Proposition where
  atomic s = Atomic s
  neg p = Negation p
  conj p q = Conjunction p q
  disj p q = Disjunction p q
  impl p q = Implication p q
  equiv p q = Equivalence p q
  
  isAtomic (Atomic _) = True
  isAtomic _ = False
  
  isComplex = not . isAtomic
  
  subformulas (Atomic _) = []
  subformulas (Negation p) = p : subformulas p
  subformulas (Conjunction p q) = p : q : subformulas p ++ subformulas q
  subformulas (Disjunction p q) = p : q : subformulas p ++ subformulas q
  subformulas (Implication p q) = p : q : subformulas p ++ subformulas q
  subformulas (Equivalence p q) = p : q : subformulas p ++ subformulas q
  
  complexity (Atomic _) = 0
  complexity (Negation p) = 1 + complexity p
  complexity (Conjunction p q) = 1 + max (complexity p) (complexity q)
  complexity (Disjunction p q) = 1 + max (complexity p) (complexity q)
  complexity (Implication p q) = 1 + max (complexity p) (complexity q)
  complexity (Equivalence p q) = 1 + max (complexity p) (complexity q)
```

#### 1.2 命题语义

```haskell
-- 命题语义
class PropositionalSemantics a where
  -- 真值赋值
  valuation :: a -> Valuation -> Bool
  -- 真值表
  truthTable :: a -> TruthTable
  -- 重言式
  isTautology :: a -> Bool
  -- 矛盾式
  isContradiction :: a -> Bool
  -- 可满足式
  isSatisfiable :: a -> Bool
  -- 逻辑等价
  isLogicallyEquivalent :: a -> a -> Bool

-- 真值赋值
type Valuation = String -> Bool

-- 真值表
data TruthTable = 
    TruthTable {
      formula :: Proposition,
      rows :: [TruthTableRow]
    }
  deriving (Show, Eq)

data TruthTableRow = 
    TruthTableRow {
      assignment :: Valuation,
      result :: Bool
    }
  deriving (Show, Eq)

-- 命题语义实例
instance PropositionalSemantics Proposition where
  valuation (Atomic s) v = v s
  valuation (Negation p) v = not (valuation p v)
  valuation (Conjunction p q) v = valuation p v && valuation q v
  valuation (Disjunction p q) v = valuation p v || valuation q v
  valuation (Implication p q) v = not (valuation p v) || valuation q v
  valuation (Equivalence p q) v = valuation p v == valuation q v
  
  truthTable p = TruthTable {
    formula = p,
    rows = [TruthTableRow v (valuation p v) | v <- allValuations p]
  }
  
  isTautology p = all (\v -> valuation p v) (allValuations p)
  
  isContradiction p = all (\v -> not (valuation p v)) (allValuations p)
  
  isSatisfiable p = any (\v -> valuation p v) (allValuations p)
  
  isLogicallyEquivalent p q = 
    all (\v -> valuation p v == valuation q v) (allValuations p)

-- 生成所有真值赋值
allValuations :: Proposition -> [Valuation]
allValuations p = 
  let atoms = nub (atomicPropositions p)
      n = length atoms
      assignments = replicateM n [True, False]
  in [makeValuation atoms asg | asg <- assignments]

-- 提取原子命题
atomicPropositions :: Proposition -> [String]
atomicPropositions (Atomic s) = [s]
atomicPropositions (Negation p) = atomicPropositions p
atomicPropositions (Conjunction p q) = nub (atomicPropositions p ++ atomicPropositions q)
atomicPropositions (Disjunction p q) = nub (atomicPropositions p ++ atomicPropositions q)
atomicPropositions (Implication p q) = nub (atomicPropositions p ++ atomicPropositions q)
atomicPropositions (Equivalence p q) = nub (atomicPropositions p ++ atomicPropositions q)

-- 构造真值赋值
makeValuation :: [String] -> [Bool] -> Valuation
makeValuation atoms values = \s -> 
  case elemIndex s atoms of
    Just i -> values !! i
    Nothing -> False
```

### 2. 一阶逻辑

#### 2.1 一阶语言

```haskell
-- 一阶逻辑语法
data Term = 
    Variable String         -- 变量
  | Constant String         -- 常量
  | Function String [Term]  -- 函数项
  deriving (Show, Eq)

data Formula = 
    Predicate String [Term]           -- 谓词
  | Equal Term Term                   -- 相等
  | Not Formula                       -- 否定
  | And Formula Formula               -- 合取
  | Or Formula Formula                -- 析取
  | Implies Formula Formula           -- 蕴含
  | Iff Formula Formula               -- 等价
  | ForAll String Formula             -- 全称量词
  | Exists String Formula             -- 存在量词
  deriving (Show, Eq)

-- 一阶逻辑类型类
class FirstOrderLogic a where
  -- 语法操作
  predicate :: String -> [Term] -> a
  equal :: Term -> Term -> a
  not' :: a -> a
  and' :: a -> a -> a
  or' :: a -> a -> a
  implies :: a -> a -> a
  iff :: a -> a -> a
  forAll :: String -> a -> a
  exists :: String -> a -> a
  
  -- 语法性质
  freeVariables :: a -> [String]
  boundVariables :: a -> [String]
  isClosed :: a -> Bool
  isOpen :: a -> Bool

-- 一阶逻辑实例
instance FirstOrderLogic Formula where
  predicate s ts = Predicate s ts
  equal t1 t2 = Equal t1 t2
  not' f = Not f
  and' f1 f2 = And f1 f2
  or' f1 f2 = Or f1 f2
  implies f1 f2 = Implies f1 f2
  iff f1 f2 = Iff f1 f2
  forAll x f = ForAll x f
  exists x f = Exists x f
  
  freeVariables (Predicate _ ts) = concatMap freeVarsInTerm ts
  freeVariables (Equal t1 t2) = freeVarsInTerm t1 ++ freeVarsInTerm t2
  freeVariables (Not f) = freeVariables f
  freeVariables (And f1 f2) = nub (freeVariables f1 ++ freeVariables f2)
  freeVariables (Or f1 f2) = nub (freeVariables f1 ++ freeVariables f2)
  freeVariables (Implies f1 f2) = nub (freeVariables f1 ++ freeVariables f2)
  freeVariables (Iff f1 f2) = nub (freeVariables f1 ++ freeVariables f2)
  freeVariables (ForAll x f) = filter (/= x) (freeVariables f)
  freeVariables (Exists x f) = filter (/= x) (freeVariables f)
  
  boundVariables (Predicate _ _) = []
  boundVariables (Equal _ _) = []
  boundVariables (Not f) = boundVariables f
  boundVariables (And f1 f2) = nub (boundVariables f1 ++ boundVariables f2)
  boundVariables (Or f1 f2) = nub (boundVariables f1 ++ boundVariables f2)
  boundVariables (Implies f1 f2) = nub (boundVariables f1 ++ boundVariables f2)
  boundVariables (Iff f1 f2) = nub (boundVariables f1 ++ boundVariables f2)
  boundVariables (ForAll x f) = x : boundVariables f
  boundVariables (Exists x f) = x : boundVariables f
  
  isClosed f = null (freeVariables f)
  
  isOpen f = not (isClosed f)

-- 项中的自由变量
freeVarsInTerm :: Term -> [String]
freeVarsInTerm (Variable x) = [x]
freeVarsInTerm (Constant _) = []
freeVarsInTerm (Function _ ts) = concatMap freeVarsInTerm ts
```

#### 2.2 一阶语义

```haskell
-- 一阶语义
class FirstOrderSemantics a where
  -- 解释
  interpretation :: a -> Interpretation -> Bool
  -- 模型
  model :: a -> Model -> Bool
  -- 有效性
  isValid :: a -> Bool
  -- 可满足性
  isSatisfiable :: a -> Bool
  -- 逻辑蕴含
  logicallyImplies :: a -> a -> Bool

-- 解释
data Interpretation = 
    Interpretation {
      domain :: [Entity],
      constants :: String -> Entity,
      functions :: String -> [Entity] -> Entity,
      predicates :: String -> [Entity] -> Bool
    }
  deriving (Show, Eq)

-- 模型
data Model = 
    Model {
      interpretation :: Interpretation,
      variableAssignment :: String -> Entity
    }
  deriving (Show, Eq)

-- 实体
type Entity = Int

-- 一阶语义实例
instance FirstOrderSemantics Formula where
  interpretation f i = interpretFormula f i (\_ -> head (domain i))
  
  model f m = interpretFormula f (interpretation m) (variableAssignment m)
  
  isValid f = all (\i -> interpretation f i) allInterpretations
  
  isSatisfiable f = any (\i -> interpretation f i) allInterpretations
  
  logicallyImplies f1 f2 = 
    all (\i -> not (interpretation f1 i) || interpretation f2 i) allInterpretations

-- 解释公式
interpretFormula :: Formula -> Interpretation -> (String -> Entity) -> Bool
interpretFormula (Predicate s ts) i v = 
  predicates i s (map (\t -> interpretTerm t i v) ts)
interpretFormula (Equal t1 t2) i v = 
  interpretTerm t1 i v == interpretTerm t2 i v
interpretFormula (Not f) i v = not (interpretFormula f i v)
interpretFormula (And f1 f2) i v = 
  interpretFormula f1 i v && interpretFormula f2 i v
interpretFormula (Or f1 f2) i v = 
  interpretFormula f1 i v || interpretFormula f2 i v
interpretFormula (Implies f1 f2) i v = 
  not (interpretFormula f1 i v) || interpretFormula f2 i v
interpretFormula (Iff f1 f2) i v = 
  interpretFormula f1 i v == interpretFormula f2 i v
interpretFormula (ForAll x f) i v = 
  all (\e -> interpretFormula f i (updateAssignment v x e)) (domain i)
interpretFormula (Exists x f) i v = 
  any (\e -> interpretFormula f i (updateAssignment v x e)) (domain i)

-- 解释项
interpretTerm :: Term -> Interpretation -> (String -> Entity) -> Entity
interpretTerm (Variable x) i v = v x
interpretTerm (Constant c) i v = constants i c
interpretTerm (Function f ts) i v = 
  functions i f (map (\t -> interpretTerm t i v) ts)

-- 更新变量赋值
updateAssignment :: (String -> Entity) -> String -> Entity -> (String -> Entity)
updateAssignment v x e = \y -> if y == x then e else v y
```

### 3. 证明系统

#### 3.1 自然演绎

```haskell
-- 自然演绎系统
class NaturalDeduction a where
  -- 推理规则
  inferenceRules :: [InferenceRule]
  -- 证明
  proof :: a -> Proof
  -- 可证明性
  isProvable :: a -> Bool
  -- 证明构造
  constructProof :: a -> Maybe Proof

-- 推理规则
data InferenceRule = 
    AndIntroduction
  | AndElimination
  | OrIntroduction
  | OrElimination
  | ImplicationIntroduction
  | ImplicationElimination
  | NegationIntroduction
  | NegationElimination
  | UniversalIntroduction
  | UniversalElimination
  | ExistentialIntroduction
  | ExistentialElimination
  deriving (Show, Eq)

-- 证明
data Proof = 
    Axiom Proposition
  | Rule InferenceRule [Proof] Proposition
  | Assumption Proposition
  deriving (Show, Eq)

-- 自然演绎实例
instance NaturalDeduction Proposition where
  inferenceRules = [
    AndIntroduction,
    AndElimination,
    OrIntroduction,
    OrElimination,
    ImplicationIntroduction,
    ImplicationElimination,
    NegationIntroduction,
    NegationElimination
  ]
  
  proof p = constructNaturalDeductionProof p
  
  isProvable p = case constructProof p of
    Just _ -> True
    Nothing -> False
  
  constructProof p = constructNaturalDeductionProof p

-- 构造自然演绎证明
constructNaturalDeductionProof :: Proposition -> Maybe Proof
constructNaturalDeductionProof p = 
  case p of
    Conjunction p1 p2 -> 
      case (constructNaturalDeductionProof p1, constructNaturalDeductionProof p2) of
        (Just prf1, Just prf2) -> Just (Rule AndIntroduction [prf1, prf2] p)
        _ -> Nothing
    Implication p1 p2 -> 
      case constructNaturalDeductionProof p2 of
        Just prf2 -> Just (Rule ImplicationIntroduction [prf2] p)
        Nothing -> Nothing
    _ -> Nothing
```

#### 3.2 希尔伯特系统

```haskell
-- 希尔伯特系统
class HilbertSystem a where
  -- 公理
  axioms :: [a]
  -- 推理规则
  modusPonens :: a -> a -> Maybe a
  -- 证明
  hilbertProof :: a -> Proof
  -- 可证明性
  hilbertProvable :: a -> Bool

-- 希尔伯特公理
hilbertAxioms :: [Proposition]
hilbertAxioms = [
  -- A1: A → (B → A)
  Implication (Atomic "A") (Implication (Atomic "B") (Atomic "A")),
  -- A2: (A → (B → C)) → ((A → B) → (A → C))
  Implication 
    (Implication (Atomic "A") (Implication (Atomic "B") (Atomic "C")))
    (Implication (Implication (Atomic "A") (Atomic "B")) (Implication (Atomic "A") (Atomic "C"))),
  -- A3: (¬A → ¬B) → (B → A)
  Implication 
    (Implication (Negation (Atomic "A")) (Negation (Atomic "B")))
    (Implication (Atomic "B") (Atomic "A"))
]

-- 希尔伯特系统实例
instance HilbertSystem Proposition where
  axioms = hilbertAxioms
  
  modusPonens (Implication p1 p2) p1' = 
    if p1 == p1' then Just p2 else Nothing
  modusPonens _ _ = Nothing
  
  hilbertProof p = constructHilbertProof p
  
  hilbertProvable p = case constructHilbertProof p of
    Just _ -> True
    Nothing -> False

-- 构造希尔伯特证明
constructHilbertProof :: Proposition -> Maybe Proof
constructHilbertProof p = 
  if p `elem` hilbertAxioms 
  then Just (Axiom p)
  else searchHilbertProof p

-- 搜索希尔伯特证明
searchHilbertProof :: Proposition -> Maybe Proof
searchHilbertProof p = 
  -- 简化的搜索算法
  case p of
    Implication p1 p2 -> 
      case (searchHilbertProof p1, searchHilbertProof p2) of
        (Just prf1, Just prf2) -> Just (Rule ImplicationIntroduction [prf1, prf2] p)
        _ -> Nothing
    _ -> Nothing
```

## 🔬 形式化理论

### 1. 逻辑系统的一致性

```haskell
-- 逻辑系统一致性
class LogicalConsistency a where
  -- 语法一致性
  syntacticConsistency :: Bool
  -- 语义一致性
  semanticConsistency :: Bool
  -- 一致性证明
  consistencyProof :: Proof
  -- 不一致性检测
  inconsistencyDetection :: a -> Bool

-- 一致性类型
data ConsistencyType = 
    SyntacticConsistency
  | SemanticConsistency
  | StrongConsistency
  | WeakConsistency
  deriving (Show, Eq)

-- 逻辑一致性实例
instance LogicalConsistency Proposition where
  syntacticConsistency = True  -- 假设系统语法一致
  
  semanticConsistency = True   -- 假设系统语义一致
  
  consistencyProof = Proof {
    method = "模型论方法",
    steps = [
      "构造标准模型",
      "验证公理有效性",
      "验证推理规则保持有效性"
    ],
    conclusion = "系统一致"
  }
  
  inconsistencyDetection p = 
    case p of
      Conjunction f (Negation f') -> f == f'
      _ -> False
```

### 2. 逻辑系统的完备性

```haskell
-- 逻辑系统完备性
class LogicalCompleteness a where
  -- 强完备性
  strongCompleteness :: Bool
  -- 弱完备性
  weakCompleteness :: Bool
  -- 完备性证明
  completenessProof :: Proof
  -- 不完备性分析
  incompletenessAnalysis :: IncompletenessAnalysis

-- 完备性分析
data IncompletenessAnalysis = 
    IncompletenessAnalysis {
      incompletenessType :: IncompletenessType,
      incompletenessReason :: String,
      incompletenessExamples :: [a]
    }
  deriving (Show, Eq)

-- 不完备性类型
data IncompletenessType = 
    SyntacticIncompleteness
  | SemanticIncompleteness
  | EssentialIncompleteness
  deriving (Show, Eq)

-- 逻辑完备性实例
instance LogicalCompleteness Proposition where
  strongCompleteness = True  -- 命题逻辑强完备
  
  weakCompleteness = True    -- 命题逻辑弱完备
  
  completenessProof = Proof {
    method = "亨金方法",
    steps = [
      "构造极大一致集",
      "构造典范模型",
      "证明真值引理"
    ],
    conclusion = "系统完备"
  }
  
  incompletenessAnalysis = IncompletenessAnalysis {
    incompletenessType = SyntacticIncompleteness,
    incompletenessReason = "命题逻辑是完备的",
    incompletenessExamples = []
  }
```

## 🧮 数学证明

### 1. 基本定理证明

#### 1.1 德摩根律

```haskell
-- 德摩根律证明
class DeMorganLaws a where
  -- 德摩根律
  deMorganAnd :: a -> a -> a
  deMorganOr :: a -> a -> a
  -- 证明
  deMorganProof :: Proof
  -- 推广
  deMorganGeneralization :: [a] -> [a]

-- 德摩根律实现
instance DeMorganLaws Proposition where
  -- ¬(A ∧ B) ↔ (¬A ∨ ¬B)
  deMorganAnd p1 p2 = 
    Equivalence (Negation (Conjunction p1 p2)) (Disjunction (Negation p1) (Negation p2))
  
  -- ¬(A ∨ B) ↔ (¬A ∧ ¬B)
  deMorganOr p1 p2 = 
    Equivalence (Negation (Disjunction p1 p2)) (Conjunction (Negation p1) (Negation p2))
  
  deMorganProof = Proof {
    method = "真值表方法",
    steps = [
      "构造真值表",
      "验证等价性",
      "应用外延公理"
    ],
    conclusion = "德摩根律成立"
  }
  
  deMorganGeneralization ps = 
    [deMorganAnd p1 p2 | p1 <- ps, p2 <- ps, p1 /= p2]
```

#### 1.2 分配律

```haskell
-- 分配律证明
class DistributiveLaws a where
  -- 分配律
  distributiveAnd :: a -> a -> a -> a
  distributiveOr :: a -> a -> a -> a
  -- 证明
  distributiveProof :: Proof
  -- 应用
  distributiveApplication :: [a] -> a

-- 分配律实现
instance DistributiveLaws Proposition where
  -- A ∧ (B ∨ C) ↔ (A ∧ B) ∨ (A ∧ C)
  distributiveAnd a b c = 
    Equivalence 
      (Conjunction a (Disjunction b c))
      (Disjunction (Conjunction a b) (Conjunction a c))
  
  -- A ∨ (B ∧ C) ↔ (A ∨ B) ∧ (A ∨ C)
  distributiveOr a b c = 
    Equivalence 
      (Disjunction a (Conjunction b c))
      (Conjunction (Disjunction a b) (Disjunction a c))
  
  distributiveProof = Proof {
    method = "双重包含证明",
    steps = [
      "证明左到右包含",
      "证明右到左包含",
      "应用外延公理"
    ],
    conclusion = "分配律成立"
  }
  
  distributiveApplication ps = 
    foldl (\acc p -> Conjunction acc p) (head ps) (tail ps)
```

### 2. 高级定理证明

#### 2.1 演绎定理

```haskell
-- 演绎定理证明
class DeductionTheorem a where
  -- 演绎定理
  deductionTheorem :: a -> a -> Bool
  -- 证明
  deductionProof :: Proof
  -- 应用
  deductionApplication :: [a] -> a -> a

-- 演绎定理：Γ ∪ {A} ⊢ B 当且仅当 Γ ⊢ A → B
instance DeductionTheorem Proposition where
  deductionTheorem gamma a = 
    -- 简化的演绎定理检查
    case (gamma, a) of
      (Implication p1 p2, p1') -> p1 == p1'
      _ -> False
  
  deductionProof = Proof {
    method = "归纳证明",
    steps = [
      "基础情况：A ∈ Γ",
      "归纳步骤：应用推理规则",
      "结论：演绎定理成立"
    ],
    conclusion = "演绎定理成立"
  }
  
  deductionApplication gamma a = 
    foldr Implication a gamma
```

#### 2.2 紧致性定理

```haskell
-- 紧致性定理证明
class CompactnessTheorem a where
  -- 紧致性定理
  compactnessTheorem :: [a] -> Bool
  -- 证明
  compactnessProof :: Proof
  -- 应用
  compactnessApplication :: [a] -> [a]

-- 紧致性定理：一个公式集可满足当且仅当其所有有限子集都可满足
instance CompactnessTheorem Proposition where
  compactnessTheorem formulas = 
    isSatisfiable formulas == all isSatisfiable (finiteSubsets formulas)
  
  compactnessProof = Proof {
    method = "超积构造",
    steps = [
      "构造超积模型",
      "证明有限满足性",
      "应用超积基本定理"
    ],
    conclusion = "紧致性定理成立"
  }
  
  compactnessApplication formulas = 
    filter (\f -> isSatisfiable [f]) formulas

-- 有限子集
finiteSubsets :: [a] -> [[a]]
finiteSubsets xs = 
  [ys | ys <- subsequences xs, not (null ys), length ys <= 3]  -- 限制大小
```

## 🔗 交叉引用

- [数学基础](../01-Mathematics/00-Foundation/数学基础.md)
- [集合论](../01-Mathematics/01-Set-Theory/集合论基础.md)
- [范畴论](../03-Category-Theory/01-Basic-Concepts/基本概念.md)
- [类型论](../04-Type-Theory/01-Simple-Type-Theory/简单类型论.md)

## 📚 参考文献

1. Enderton, H. B. (2001). *A Mathematical Introduction to Logic*. Academic Press.
2. Mendelson, E. (2015). *Introduction to Mathematical Logic*. CRC Press.
3. Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). *Computability and Logic*. Cambridge University Press.
4. Shoenfield, J. R. (2001). *Mathematical Logic*. A K Peters.
5. Smullyan, R. M. (1995). *First-Order Logic*. Dover Publications.

---

*本文档是经典逻辑基础的完整形式化表达，结合了语法、语义、证明论和Haskell实现，为理解经典逻辑提供了多维度视角。*
