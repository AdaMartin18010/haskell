# Haskell类型系统基础

## 概述

Haskell的类型系统是其最强大的特性之一，提供了编译时类型安全、类型推断和抽象能力。本章介绍Haskell类型系统的基础概念和形式化定义。

## 数学基础

### 类型论基础

在类型论中，类型是值的集合，类型系统是描述这些集合之间关系的规则系统。

#### 基本类型

基本类型 $T$ 是原子类型，如：

- $\text{Bool} = \{\text{True}, \text{False}\}$
- $\text{Int} = \{\ldots, -1, 0, 1, \ldots\}$
- $\text{Char} = \{\text{'a'}, \text{'b'}, \ldots\}$

#### 函数类型

函数类型 $A \rightarrow B$ 表示从类型 $A$ 到类型 $B$ 的所有函数集合：
$$A \rightarrow B = \{f \mid f: A \rightarrow B\}$$

#### 积类型

积类型 $A \times B$ 表示类型 $A$ 和 $B$ 的笛卡尔积：
$$A \times B = \{(a, b) \mid a \in A, b \in B\}$$

#### 和类型

和类型 $A + B$ 表示类型 $A$ 和 $B$ 的不相交并集：
$$A + B = \{\text{Left}(a) \mid a \in A\} \cup \{\text{Right}(b) \mid b \in B\}$$

### 类型推断

Hindley-Milner类型系统提供了类型推断算法，能够自动推导表达式的类型。

#### 类型推断规则

1. **变量规则**：如果 $x: \tau \in \Gamma$，则 $\Gamma \vdash x: \tau$
2. **应用规则**：如果 $\Gamma \vdash e_1: \tau_1 \rightarrow \tau_2$ 且 $\Gamma \vdash e_2: \tau_1$，则 $\Gamma \vdash e_1 e_2: \tau_2$
3. **抽象规则**：如果 $\Gamma, x: \tau_1 \vdash e: \tau_2$，则 $\Gamma \vdash \lambda x.e: \tau_1 \rightarrow \tau_2$

## Haskell实现

### 1. 基本类型

#### 1.1 数值类型

```haskell
-- 整数类型
intValue :: Int
intValue = 42

integerValue :: Integer
integerValue = 1234567890123456789

-- 浮点类型
doubleValue :: Double
doubleValue = 3.14159

floatValue :: Float
floatValue = 2.718

-- 有理数类型
import Data.Ratio
rationalValue :: Rational
rationalValue = 22 % 7

-- 复数类型
import Data.Complex
complexValue :: Complex Double
complexValue = 3.0 :+ 4.0
```

#### 1.2 字符和字符串

```haskell
-- 字符类型
charValue :: Char
charValue = 'H'

-- 字符串类型（字符列表）
stringValue :: String
stringValue = "Hello, Haskell!"

-- 字符串操作
stringLength :: String -> Int
stringLength = length

stringConcat :: String -> String -> String
stringConcat = (++)

-- 字符列表操作
charList :: [Char]
charList = ['H', 'e', 'l', 'l', 'o']
```

#### 1.3 布尔类型

```haskell
-- 布尔值
trueValue :: Bool
trueValue = True

falseValue :: Bool
falseValue = False

-- 布尔运算
logicalAnd :: Bool -> Bool -> Bool
logicalAnd = (&&)

logicalOr :: Bool -> Bool -> Bool
logicalOr = (||)

logicalNot :: Bool -> Bool
logicalNot = not

-- 条件表达式
conditionalValue :: Int -> String
conditionalValue n = if n > 0 then "positive" else "non-positive"
```

### 2. 复合类型

#### 2.1 元组类型

```haskell
-- 二元组
pair :: (Int, String)
pair = (1, "hello")

-- 三元组
triple :: (Int, Double, Bool)
triple = (1, 2.5, True)

-- 嵌套元组
nestedTuple :: ((Int, String), (Double, Bool))
nestedTuple = ((1, "hello"), (2.5, True))

-- 元组操作
first :: (a, b) -> a
first (x, _) = x

second :: (a, b) -> b
second (_, y) = y

swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)
```

#### 2.2 列表类型

```haskell
-- 基本列表
intList :: [Int]
intList = [1, 2, 3, 4, 5]

stringList :: [String]
stringList = ["hello", "world"]

-- 列表构造
emptyList :: [a]
emptyList = []

singletonList :: a -> [a]
singletonList x = [x]

-- 列表操作
head' :: [a] -> Maybe a
head' [] = Nothing
head' (x:_) = Just x

tail' :: [a] -> Maybe [a]
tail' [] = Nothing
tail' (_:xs) = Just xs

length' :: [a] -> Int
length' [] = 0
length' (_:xs) = 1 + length' xs
```

#### 2.3 Maybe类型

```haskell
-- Maybe类型定义
data Maybe a = Nothing | Just a

-- Maybe操作
fromMaybe :: a -> Maybe a -> a
fromMaybe defaultVal Nothing = defaultVal
fromMaybe _ (Just val) = val

maybe :: b -> (a -> b) -> Maybe a -> b
maybe defaultVal f Nothing = defaultVal
maybe _ f (Just val) = f val

-- 安全除法
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

-- 列表查找
findElement :: Eq a => a -> [a] -> Maybe Int
findElement _ [] = Nothing
findElement x (y:ys)
  | x == y = Just 0
  | otherwise = fmap (+1) (findElement x ys)
```

### 3. 函数类型

#### 3.1 基本函数类型

```haskell
-- 一元函数
increment :: Int -> Int
increment x = x + 1

-- 二元函数
add :: Int -> Int -> Int
add x y = x + y

-- 高阶函数
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)

-- 函数组合
compose :: (b -> c) -> (a -> b) -> a -> c
compose f g x = f (g x)

-- 部分应用
addFive :: Int -> Int
addFive = add 5

multiplyByTwo :: Int -> Int
multiplyByTwo = (*2)
```

#### 3.2 多态函数

```haskell
-- 多态恒等函数
id' :: a -> a
id' x = x

-- 多态常量函数
const' :: a -> b -> a
const' x _ = x

-- 多态列表操作
map' :: (a -> b) -> [a] -> [b]
map' _ [] = []
map' f (x:xs) = f x : map' f xs

filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' p (x:xs)
  | p x = x : filter' p xs
  | otherwise = filter' p xs
```

### 4. 代数数据类型 (ADT)

```haskell
-- 积类型（记录类型）
data Person = Person 
    { name :: String
    , age :: Int
    , email :: String
    } deriving (Show, Eq)

-- 和类型（枚举类型）
data Color = Red | Green | Blue deriving (Show, Eq)

-- 递归类型
data List a = Nil | Cons a (List a) deriving (Show, Eq)

-- 参数化类型
data Maybe a = Nothing | Just a deriving (Show, Eq)

data Either a b = Left a | Right b deriving (Show, Eq)

-- 使用示例
createPerson :: String -> Int -> String -> Person
createPerson n a e = Person { name = n, age = a, email = e }

safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

parseInt :: String -> Either String Int
parseInt s = case reads s of
    [(n, "")] -> Right n
    _ -> Left $ "Cannot parse: " ++ s
```

### 5. 类型类

#### 5.1 基本类型类

```haskell
-- Eq类型类
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    
    -- 默认实现
    x /= y = not (x == y)

-- Ord类型类
class (Eq a) => Ord a where
    compare :: a -> a -> Ordering
    (<) :: a -> a -> Bool
    (<=) :: a -> a -> Bool
    (>) :: a -> a -> Bool
    (>=) :: a -> a -> Bool
    max :: a -> a -> a
    min :: a -> a -> a

-- Show类型类
class Show a where
    show :: a -> String

-- Read类型类
class Read a where
    readsPrec :: Int -> ReadS a
    readList :: ReadS [a]
    readList = readParen False (\r -> [pr | ("[",s) <- lex r,
                                           (xs,t) <- readList' s,
                                           ("]",u) <- lex t,
                                           pr <- [(xs,u)]])
        where readList' s = readParen False (\r -> [pr | (x,t) <- reads r,
                                                       (xs,u) <- readList' t,
                                                       pr <- [(x:xs,u)]])
                    ++ [([],s)]

-- 类型类实例
instance Eq Bool where
    True == True = True
    False == False = True
    _ == _ = False

instance Eq Person where
    p1 == p2 = name p1 == name p2 && age p1 == age p2
```

#### 5.2 数值类型类

```haskell
-- Num类型类
class (Eq a, Show a) => Num a where
    (+) :: a -> a -> a
    (-) :: a -> a -> a
    (*) :: a -> a -> a
    negate :: a -> a
    abs :: a -> a
    signum :: a -> a
    fromInteger :: Integer -> a

-- Integral类型类
class (Real a, Enum a) => Integral a where
    quot :: a -> a -> a
    rem :: a -> a -> a
    div :: a -> a -> a
    mod :: a -> a -> a
    quotRem :: a -> a -> (a, a)
    divMod :: a -> a -> (a, a)
    toInteger :: a -> Integer

-- Fractional类型类
class (Num a) => Fractional a where
    (/) :: a -> a -> a
    recip :: a -> a
    fromRational :: Rational -> a
```

### 6. 高阶类型

```haskell
-- 类型构造器
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)

-- 类型构造器的类型
-- Tree :: * -> *
-- Tree Int :: *
-- Tree (Tree Int) :: *

-- 高阶类型类
class Functor f where
    fmap :: (a -> b) -> f a -> f b

instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)

instance Functor Tree where
    fmap _ Empty = Empty
    fmap f (Node x left right) = Node (f x) (fmap f left) (fmap f right)

-- 使用示例
doubleMaybe :: Maybe Int -> Maybe Int
doubleMaybe = fmap (*2)

doubleTree :: Tree Int -> Tree Int
doubleTree = fmap (*2)
```

### 7. 类型推断

#### 7.1 基本类型推断

```haskell
-- 自动类型推断
autoInferred = 42  -- 推断为 Num a => a

-- 函数类型推断
inferredFunction x = x + 1  -- 推断为 Num a => a -> a

-- 列表类型推断
inferredList = [1, 2, 3]  -- 推断为 Num a => [a]

-- 多态类型推断
inferredMap f xs = map f xs  -- 推断为 (a -> b) -> [a] -> [b]
```

#### 7.2 类型注解

```haskell
-- 显式类型注解
explicitInt :: Int
explicitInt = 42

explicitFunction :: Int -> Int -> Int
explicitFunction x y = x + y

-- 多态类型注解
polymorphicFunction :: a -> a
polymorphicFunction x = x

-- 约束类型注解
constrainedFunction :: Num a => a -> a -> a
constrainedFunction x y = x + y

-- 类型推断示例
id :: a -> a
id x = x

const :: a -> b -> a
const x _ = x

-- 类型推断过程
-- id 3 :: Int
-- const 5 "hello" :: Int
-- map id [1,2,3] :: [Int]

-- 多态函数
length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs

-- 类型约束
sum :: Num a => [a] -> a
sum [] = 0
sum (x:xs) = x + sum xs

-- 使用类型约束
average :: (Fractional a, Show a) => [a] -> String
average xs = show (sum xs / fromIntegral (length xs))
```

### 8. 类型安全

#### 8.1 类型检查

```haskell
-- 类型安全的函数
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

-- 类型安全的除法
safeDivision :: (Fractional a, Eq a) => a -> a -> Maybe a
safeDivision _ 0 = Nothing
safeDivision x y = Just (x / y)

-- 类型安全的列表操作
safeIndex :: [a] -> Int -> Maybe a
safeIndex [] _ = Nothing
safeIndex (x:_) 0 = Just x
safeIndex (_:xs) n
  | n < 0 = Nothing
  | otherwise = safeIndex xs (n - 1)
```

#### 8.2 类型错误预防

```haskell
-- 使用Maybe避免错误
processMaybe :: Maybe Int -> String
processMaybe Nothing = "No value"
processMaybe (Just x) = "Value: " ++ show x

-- 使用Either处理错误
processEither :: Either String Int -> String
processEither (Left err) = "Error: " ++ err
processEither (Right val) = "Value: " ++ show val

-- 类型安全的模式匹配
safePatternMatch :: [a] -> String
safePatternMatch [] = "Empty list"
safePatternMatch [x] = "Single element"
safePatternMatch (x:y:xs) = "Multiple elements"
```

### 9. 高级类型特性

#### 9.1 类型别名

```haskell
-- 类型别名
type Name = String
type Age = Int
type Person = (Name, Age)

-- 函数类型别名
type BinaryOp a = a -> a -> a
type Predicate a = a -> Bool

-- 使用类型别名
addNumbers :: BinaryOp Int
addNumbers = (+)

isPositive :: Predicate Int
isPositive = (>0)
```

#### 9.2 新类型

```haskell
-- 新类型定义
newtype Celsius = Celsius Double
newtype Fahrenheit = Fahrenheit Double

-- 新类型操作
toFahrenheit :: Celsius -> Fahrenheit
toFahrenheit (Celsius c) = Fahrenheit (c * 9/5 + 32)

toCelsius :: Fahrenheit -> Celsius
toCelsius (Fahrenheit f) = Celsius ((f - 32) * 5/9)

-- 新类型实例
instance Show Celsius where
  show (Celsius c) = show c ++ "°C"

instance Show Fahrenheit where
  show (Fahrenheit f) = show f ++ "°F"
```

## 形式化证明

### Hindley-Milner类型系统

Haskell的类型系统基于Hindley-Milner类型系统，支持：

- **类型推断**：$\Gamma \vdash e : \tau$
- **类型检查**：$\Gamma \vdash e : \tau \Rightarrow \tau'$
- **类型统一**：$\tau_1 \sim \tau_2$

### 类型规则

**变量规则**：
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

**应用规则**：
$$\frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}$$

**抽象规则**：
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}$$

### 类型统一

类型统一的语义：

$$\text{unify}(\tau_1, \tau_2) = \begin{cases}
\text{Just } \sigma & \text{if } \tau_1 \text{ and } \tau_2 \text{ are unifiable} \\
\text{Nothing} & \text{otherwise}
\end{cases}$$

## 实践示例

### 类型安全计算器

```haskell
-- 计算器类型
data Operation = Add | Subtract | Multiply | Divide

-- 类型安全的计算
calculate :: Operation -> Double -> Double -> Maybe Double
calculate Add x y = Just (x + y)
calculate Subtract x y = Just (x - y)
calculate Multiply x y = Just (x * y)
calculate Divide x 0 = Nothing
calculate Divide x y = Just (x / y)

-- 类型安全的计算器
calculator :: IO ()
calculator = do
  putStrLn "Enter operation (+, -, *, /):"
  opStr <- getLine
  putStrLn "Enter first number:"
  xStr <- getLine
  putStrLn "Enter second number:"
  yStr <- getLine
  
  let op = case opStr of
        "+" -> Add
        "-" -> Subtract
        "*" -> Multiply
        "/" -> Divide
        _ -> error "Invalid operation"
      x = read xStr :: Double
      y = read yStr :: Double
      result = calculate op x y
  
  case result of
    Just r -> putStrLn $ "Result: " ++ show r
    Nothing -> putStrLn "Error: Invalid operation"
```

### 类型安全数据结构

```haskell
-- 类型安全的栈
newtype Stack a = Stack [a]

-- 栈操作
empty :: Stack a
empty = Stack []

push :: a -> Stack a -> Stack a
push x (Stack xs) = Stack (x:xs)

pop :: Stack a -> Maybe (a, Stack a)
pop (Stack []) = Nothing
pop (Stack (x:xs)) = Just (x, Stack xs)

peek :: Stack a -> Maybe a
peek (Stack []) = Nothing
peek (Stack (x:_)) = Just x

-- 栈实例
instance Show a => Show (Stack a) where
  show (Stack xs) = "Stack " ++ show xs

-- 使用示例
stackExample :: IO ()
stackExample = do
  let s1 = empty
      s2 = push 1 s1
      s3 = push 2 s2
      s4 = push 3 s3
  
  putStrLn $ "Stack: " ++ show s4
  
  case pop s4 of
    Just (val, newStack) -> do
      putStrLn $ "Popped: " ++ show val
      putStrLn $ "New stack: " ++ show newStack
    Nothing -> putStrLn "Stack is empty"
```

## 总结

Haskell的类型系统提供了：

1. **类型安全**：编译时错误检测
2. **类型推断**：自动推导类型
3. **多态性**：泛型编程支持
4. **类型类**：特设多态
5. **代数数据类型**：强大的数据结构定义
6. **高阶类型**：类型构造器抽象

这些特性使得Haskell能够提供强大的类型安全保障，同时保持代码的简洁性和表达力。

---

**相关链接**：

- [类型类](类型类.md)
- [高级类型](高级类型.md)
- [类型安全](类型安全.md)
- [函数式编程基础](../01-Basic-Concepts/函数式编程基础.md)
