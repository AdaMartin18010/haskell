# 编译器开发 - Haskell实现

## 概述

编译器是将高级编程语言转换为机器代码或字节码的程序。本文档使用Haskell实现一个完整的编译器，包括词法分析、语法分析、语义分析、代码生成等各个阶段。

## 词法分析器

### 基本框架

```haskell
-- 词法单元类型
data Token = 
    -- 关键字
    TokenIf | TokenElse | TokenWhile | TokenFor | TokenReturn | TokenInt | TokenBool
    -- 标识符和字面量
    | TokenIdentifier String
    | TokenInteger Int
    | TokenBoolean Bool
    -- 操作符
    | TokenPlus | TokenMinus | TokenMultiply | TokenDivide
    | TokenAssign | TokenEqual | TokenLessThan | TokenGreaterThan
    | TokenAnd | TokenOr | TokenNot
    -- 分隔符
    | TokenLeftParen | TokenRightParen | TokenLeftBrace | TokenRightBrace
    | TokenSemicolon | TokenComma
    -- 特殊
    | TokenEOF
    deriving (Show, Eq)

-- 词法分析器状态
data LexerState = LexerState
    { input :: String
    , position :: Int
    , line :: Int
    , column :: Int
    } deriving Show

-- 词法分析器
newtype Lexer a = Lexer { runLexer :: LexerState -> Either String (a, LexerState) }

instance Functor Lexer where
    fmap f (Lexer l) = Lexer $ \s -> case l s of
        Left err -> Left err
        Right (a, s') -> Right (f a, s')

instance Applicative Lexer where
    pure a = Lexer $ \s -> Right (a, s)
    (Lexer f) <*> (Lexer a) = Lexer $ \s -> case f s of
        Left err -> Left err
        Right (g, s') -> case a s' of
            Left err -> Left err
            Right (b, s'') -> Right (g b, s'')

instance Monad Lexer where
    return = pure
    (Lexer m) >>= f = Lexer $ \s -> case m s of
        Left err -> Left err
        Right (a, s') -> runLexer (f a) s'

-- 基本词法分析操作
peek :: Lexer (Maybe Char)
peek = Lexer $ \s -> 
    if position s >= length (input s)
    then Right (Nothing, s)
    else Right (Just (input s !! position s), s)

advance :: Lexer Char
advance = Lexer $ \s -> 
    if position s >= length (input s)
    then Left "Unexpected end of input"
    else let c = input s !! position s
             newPos = position s + 1
             newLine = if c == '\n' then line s + 1 else line s
             newCol = if c == '\n' then 1 else column s + 1
         in Right (c, s { position = newPos, line = newLine, column = newCol })

skipWhitespace :: Lexer ()
skipWhitespace = do
    c <- peek
    case c of
        Just ' ' -> advance >> skipWhitespace
        Just '\t' -> advance >> skipWhitespace
        Just '\n' -> advance >> skipWhitespace
        Just '\r' -> advance >> skipWhitespace
        _ -> return ()

-- 识别标识符
lexIdentifier :: Lexer Token
lexIdentifier = do
    c <- advance
    if isAlpha c
        then do
            rest <- lexIdentifierRest
            let identifier = c:rest
            return $ case identifier of
                "if" -> TokenIf
                "else" -> TokenElse
                "while" -> TokenWhile
                "for" -> TokenFor
                "return" -> TokenReturn
                "int" -> TokenInt
                "bool" -> TokenBool
                "true" -> TokenBoolean True
                "false" -> TokenBoolean False
                _ -> TokenIdentifier identifier
        else Left "Expected identifier"

lexIdentifierRest :: Lexer String
lexIdentifierRest = do
    c <- peek
    case c of
        Just c' | isAlphaNum c' -> do
            advance
            rest <- lexIdentifierRest
            return (c':rest)
        _ -> return ""

-- 识别数字
lexNumber :: Lexer Token
lexNumber = do
    c <- advance
    if isDigit c
        then do
            rest <- lexNumberRest
            return $ TokenInteger (read (c:rest))
        else Left "Expected digit"

lexNumberRest :: Lexer String
lexNumberRest = do
    c <- peek
    case c of
        Just c' | isDigit c' -> do
            advance
            rest <- lexNumberRest
            return (c':rest)
        _ -> return ""

-- 识别操作符
lexOperator :: Lexer Token
lexOperator = do
    c <- advance
    case c of
        '+' -> return TokenPlus
        '-' -> return TokenMinus
        '*' -> return TokenMultiply
        '/' -> return TokenDivide
        '=' -> do
            c2 <- peek
            case c2 of
                Just '=' -> advance >> return TokenEqual
                _ -> return TokenAssign
        '<' -> return TokenLessThan
        '>' -> return TokenGreaterThan
        '&' -> do
            c2 <- advance
            if c2 == '&' then return TokenAnd else Left "Expected &&"
        '|' -> do
            c2 <- advance
            if c2 == '|' then return TokenOr else Left "Expected ||"
        '!' -> return TokenNot
        '(' -> return TokenLeftParen
        ')' -> return TokenRightParen
        '{' -> return TokenLeftBrace
        '}' -> return TokenRightBrace
        ';' -> return TokenSemicolon
        ',' -> return TokenComma
        _ -> Left $ "Unknown operator: " ++ [c]

-- 主词法分析函数
lexToken :: Lexer Token
lexToken = do
    skipWhitespace
    c <- peek
    case c of
        Nothing -> return TokenEOF
        Just c' | isAlpha c' -> lexIdentifier
        Just c' | isDigit c' -> lexNumber
        Just c' | isSpace c' -> advance >> lexToken
        _ -> lexOperator

-- 词法分析器运行函数
tokenize :: String -> Either String [Token]
tokenize input = 
    let initialState = LexerState input 0 1 1
        tokenizeLoop = do
            token <- lexToken
            case token of
                TokenEOF -> return [token]
                _ -> do
                    rest <- tokenizeLoop
                    return (token:rest)
    in case runLexer tokenizeLoop initialState of
        Left err -> Left err
        Right (tokens, _) -> Right tokens
```

## 语法分析器

### 抽象语法树

```haskell
-- 抽象语法树节点
data AST = 
    -- 表达式
    ExprInteger Int
    | ExprBoolean Bool
    | ExprIdentifier String
    | ExprBinaryOp BinaryOp AST AST
    | ExprUnaryOp UnaryOp AST
    | ExprCall String [AST]
    -- 语句
    | StmtExpression AST
    | StmtDeclaration String Type AST
    | StmtAssignment String AST
    | StmtIf AST AST AST  -- condition, then, else
    | StmtWhile AST AST   -- condition, body
    | StmtBlock [AST]
    | StmtReturn AST
    -- 函数定义
    | FuncDef String [Parameter] Type AST
    -- 程序
    | Program [AST]
    deriving Show

-- 二元操作符
data BinaryOp = 
    OpAdd | OpSub | OpMul | OpDiv
    | OpEq | OpLt | OpGt
    | OpAnd | OpOr
    deriving Show

-- 一元操作符
data UnaryOp = 
    OpNeg | OpNot
    deriving Show

-- 类型
data Type = 
    TypeInt | TypeBool | TypeVoid
    deriving Show

-- 参数
data Parameter = Parameter String Type
    deriving Show

-- 语法分析器
newtype Parser a = Parser { runParser :: [Token] -> Either String (a, [Token]) }

instance Functor Parser where
    fmap f (Parser p) = Parser $ \tokens -> case p tokens of
        Left err -> Left err
        Right (a, tokens') -> Right (f a, tokens')

instance Applicative Parser where
    pure a = Parser $ \tokens -> Right (a, tokens)
    (Parser f) <*> (Parser a) = Parser $ \tokens -> case f tokens of
        Left err -> Left err
        Right (g, tokens') -> case a tokens' of
            Left err -> Left err
            Right (b, tokens'') -> Right (g b, tokens'')

instance Monad Parser where
    return = pure
    (Parser m) >>= f = Parser $ \tokens -> case m tokens of
        Left err -> Left err
        Right (a, tokens') -> runParser (f a) tokens'

-- 基本解析操作
peekToken :: Parser (Maybe Token)
peekToken = Parser $ \tokens -> 
    case tokens of
        [] -> Right (Nothing, tokens)
        (t:_) -> Right (Just t, tokens)

consumeToken :: Parser Token
consumeToken = Parser $ \tokens -> 
    case tokens of
        [] -> Left "Unexpected end of input"
        (t:ts) -> Right (t, ts)

expectToken :: Token -> Parser ()
expectToken expected = do
    token <- consumeToken
    if token == expected
        then return ()
        else Parser $ \_ -> Left $ "Expected " ++ show expected ++ ", got " ++ show token

-- 表达式解析
parseExpression :: Parser AST
parseExpression = parseOrExpression

parseOrExpression :: Parser AST
parseOrExpression = do
    left <- parseAndExpression
    orExpression left
    where
        orExpression left = do
            token <- peekToken
            case token of
                Just TokenOr -> do
                    consumeToken
                    right <- parseAndExpression
                    orExpression (ExprBinaryOp OpOr left right)
                _ -> return left

parseAndExpression :: Parser AST
parseAndExpression = do
    left <- parseEqualityExpression
    andExpression left
    where
        andExpression left = do
            token <- peekToken
            case token of
                Just TokenAnd -> do
                    consumeToken
                    right <- parseEqualityExpression
                    andExpression (ExprBinaryOp OpAnd left right)
                _ -> return left

parseEqualityExpression :: Parser AST
parseEqualityExpression = do
    left <- parseRelationalExpression
    equalityExpression left
    where
        equalityExpression left = do
            token <- peekToken
            case token of
                Just TokenEqual -> do
                    consumeToken
                    right <- parseRelationalExpression
                    equalityExpression (ExprBinaryOp OpEq left right)
                _ -> return left

parseRelationalExpression :: Parser AST
parseRelationalExpression = do
    left <- parseAdditiveExpression
    relationalExpression left
    where
        relationalExpression left = do
            token <- peekToken
            case token of
                Just TokenLessThan -> do
                    consumeToken
                    right <- parseAdditiveExpression
                    relationalExpression (ExprBinaryOp OpLt left right)
                Just TokenGreaterThan -> do
                    consumeToken
                    right <- parseAdditiveExpression
                    relationalExpression (ExprBinaryOp OpGt left right)
                _ -> return left

parseAdditiveExpression :: Parser AST
parseAdditiveExpression = do
    left <- parseMultiplicativeExpression
    additiveExpression left
    where
        additiveExpression left = do
            token <- peekToken
            case token of
                Just TokenPlus -> do
                    consumeToken
                    right <- parseMultiplicativeExpression
                    additiveExpression (ExprBinaryOp OpAdd left right)
                Just TokenMinus -> do
                    consumeToken
                    right <- parseMultiplicativeExpression
                    additiveExpression (ExprBinaryOp OpSub left right)
                _ -> return left

parseMultiplicativeExpression :: Parser AST
parseMultiplicativeExpression = do
    left <- parseUnaryExpression
    multiplicativeExpression left
    where
        multiplicativeExpression left = do
            token <- peekToken
            case token of
                Just TokenMultiply -> do
                    consumeToken
                    right <- parseUnaryExpression
                    multiplicativeExpression (ExprBinaryOp OpMul left right)
                Just TokenDivide -> do
                    consumeToken
                    right <- parseUnaryExpression
                    multiplicativeExpression (ExprBinaryOp OpDiv left right)
                _ -> return left

parseUnaryExpression :: Parser AST
parseUnaryExpression = do
    token <- peekToken
    case token of
        Just TokenMinus -> do
            consumeToken
            expr <- parseUnaryExpression
            return (ExprUnaryOp OpNeg expr)
        Just TokenNot -> do
            consumeToken
            expr <- parseUnaryExpression
            return (ExprUnaryOp OpNot expr)
        _ -> parsePrimaryExpression

parsePrimaryExpression :: Parser AST
parsePrimaryExpression = do
    token <- consumeToken
    case token of
        TokenInteger n -> return (ExprInteger n)
        TokenBoolean b -> return (ExprBoolean b)
        TokenIdentifier name -> parseIdentifierSuffix name
        TokenLeftParen -> do
            expr <- parseExpression
            expectToken TokenRightParen
            return expr
        _ -> Parser $ \_ -> Left $ "Unexpected token: " ++ show token

parseIdentifierSuffix :: String -> Parser AST
parseIdentifierSuffix name = do
    token <- peekToken
    case token of
        Just TokenLeftParen -> do
            consumeToken
            args <- parseArgumentList
            expectToken TokenRightParen
            return (ExprCall name args)
        _ -> return (ExprIdentifier name)

parseArgumentList :: Parser [AST]
parseArgumentList = do
    token <- peekToken
    case token of
        Just TokenRightParen -> return []
        _ -> do
            first <- parseExpression
            rest <- parseArgumentListRest
            return (first:rest)

parseArgumentListRest :: Parser [AST]
parseArgumentListRest = do
    token <- peekToken
    case token of
        Just TokenComma -> do
            consumeToken
            arg <- parseExpression
            rest <- parseArgumentListRest
            return (arg:rest)
        _ -> return []

-- 语句解析
parseStatement :: Parser AST
parseStatement = do
    token <- peekToken
    case token of
        Just TokenInt -> parseDeclaration
        Just TokenBool -> parseDeclaration
        Just TokenIf -> parseIfStatement
        Just TokenWhile -> parseWhileStatement
        Just TokenReturn -> parseReturnStatement
        Just TokenLeftBrace -> parseBlockStatement
        _ -> parseExpressionStatement

parseDeclaration :: Parser AST
parseDeclaration = do
    typ <- parseType
    name <- parseIdentifier
    expectToken TokenAssign
    value <- parseExpression
    expectToken TokenSemicolon
    return (StmtDeclaration name typ value)

parseType :: Parser Type
parseType = do
    token <- consumeToken
    case token of
        TokenInt -> return TypeInt
        TokenBool -> return TypeBool
        _ -> Parser $ \_ -> Left $ "Expected type, got " ++ show token

parseIdentifier :: Parser String
parseIdentifier = do
    token <- consumeToken
    case token of
        TokenIdentifier name -> return name
        _ -> Parser $ \_ -> Left $ "Expected identifier, got " ++ show token

parseIfStatement :: Parser AST
parseIfStatement = do
    expectToken TokenIf
    expectToken TokenLeftParen
    condition <- parseExpression
    expectToken TokenRightParen
    thenStmt <- parseStatement
    token <- peekToken
    case token of
        Just TokenElse -> do
            consumeToken
            elseStmt <- parseStatement
            return (StmtIf condition thenStmt elseStmt)
        _ -> return (StmtIf condition thenStmt (StmtBlock []))

parseWhileStatement :: Parser AST
parseWhileStatement = do
    expectToken TokenWhile
    expectToken TokenLeftParen
    condition <- parseExpression
    expectToken TokenRightParen
    body <- parseStatement
    return (StmtWhile condition body)

parseReturnStatement :: Parser AST
parseReturnStatement = do
    expectToken TokenReturn
    value <- parseExpression
    expectToken TokenSemicolon
    return (StmtReturn value)

parseBlockStatement :: Parser AST
parseBlockStatement = do
    expectToken TokenLeftBrace
    statements <- parseStatementList
    expectToken TokenRightBrace
    return (StmtBlock statements)

parseStatementList :: Parser [AST]
parseStatementList = do
    token <- peekToken
    case token of
        Just TokenRightBrace -> return []
        _ -> do
            first <- parseStatement
            rest <- parseStatementList
            return (first:rest)

parseExpressionStatement :: Parser AST
parseExpressionStatement = do
    expr <- parseExpression
    expectToken TokenSemicolon
    return (StmtExpression expr)

-- 程序解析
parseProgram :: Parser AST
parseProgram = do
    statements <- parseStatementList
    return (Program statements)

-- 解析器运行函数
parse :: [Token] -> Either String AST
parse tokens = 
    case runParser parseProgram tokens of
        Left err -> Left err
        Right (ast, []) -> Right ast
        Right (ast, remaining) -> Left $ "Unexpected tokens: " ++ show remaining
```

## 语义分析器

### 符号表

```haskell
-- 符号类型
data Symbol = 
    VariableSymbol String Type
    | FunctionSymbol String [Type] Type
    deriving Show

-- 符号表
type SymbolTable = Map String Symbol

-- 作用域
data Scope = Scope
    { symbols :: SymbolTable
    , parent :: Maybe Scope
    } deriving Show

-- 语义分析器状态
data SemanticState = SemanticState
    { currentScope :: Scope
    , errors :: [String]
    } deriving Show

-- 语义分析器
newtype SemanticAnalyzer a = SemanticAnalyzer 
    { runSemanticAnalyzer :: SemanticState -> (Either String a, SemanticState) }

instance Functor SemanticAnalyzer where
    fmap f (SemanticAnalyzer sa) = SemanticAnalyzer $ \s -> 
        case sa s of
            (Left err, s') -> (Left err, s')
            (Right a, s') -> (Right (f a), s')

instance Applicative SemanticAnalyzer where
    pure a = SemanticAnalyzer $ \s -> (Right a, s)
    (SemanticAnalyzer f) <*> (SemanticAnalyzer a) = SemanticAnalyzer $ \s -> 
        case f s of
            (Left err, s') -> (Left err, s')
            (Right g, s') -> case a s' of
                (Left err, s'') -> (Left err, s'')
                (Right b, s'') -> (Right (g b), s'')

instance Monad SemanticAnalyzer where
    return = pure
    (SemanticAnalyzer m) >>= f = SemanticAnalyzer $ \s -> 
        case m s of
            (Left err, s') -> (Left err, s')
            (Right a, s') -> runSemanticAnalyzer (f a) s'

-- 符号表操作
lookupSymbol :: String -> SemanticAnalyzer (Maybe Symbol)
lookupSymbol name = SemanticAnalyzer $ \s -> 
    let scope = currentScope s
        symbol = Map.lookup name (symbols scope)
    in case symbol of
        Just sym -> (Right (Just sym), s)
        Nothing -> case parent scope of
            Just parentScope -> 
                let parentSymbol = Map.lookup name (symbols parentScope)
                in (Right parentSymbol, s)
            Nothing -> (Right Nothing, s)

insertSymbol :: String -> Symbol -> SemanticAnalyzer ()
insertSymbol name symbol = SemanticAnalyzer $ \s -> 
    let scope = currentScope s
        newSymbols = Map.insert name symbol (symbols scope)
        newScope = scope { symbols = newSymbols }
        newState = s { currentScope = newScope }
    in (Right (), newState)

enterScope :: SemanticAnalyzer ()
enterScope = SemanticAnalyzer $ \s -> 
    let newScope = Scope Map.empty (Just (currentScope s))
        newState = s { currentScope = newScope }
    in (Right (), newState)

exitScope :: SemanticAnalyzer ()
exitScope = SemanticAnalyzer $ \s -> 
    let scope = currentScope s
        newState = case parent scope of
            Just parentScope -> s { currentScope = parentScope }
            Nothing -> s
    in (Right (), newState)

-- 类型检查
typeCheck :: AST -> SemanticAnalyzer Type
typeCheck ast = 
    case ast of
        ExprInteger _ -> return TypeInt
        ExprBoolean _ -> return TypeBool
        ExprIdentifier name -> do
            symbol <- lookupSymbol name
            case symbol of
                Just (VariableSymbol _ typ) -> return typ
                _ -> addError $ "Undefined variable: " ++ name >> return TypeInt
        ExprBinaryOp op left right -> do
            leftType <- typeCheck left
            rightType <- typeCheck right
            checkBinaryOp op leftType rightType
        ExprUnaryOp op expr -> do
            exprType <- typeCheck expr
            checkUnaryOp op exprType
        ExprCall name args -> do
            symbol <- lookupSymbol name
            case symbol of
                Just (FunctionSymbol _ paramTypes returnType) -> do
                    argTypes <- mapM typeCheck args
                    if argTypes == paramTypes
                        then return returnType
                        else addError $ "Type mismatch in function call: " ++ name >> return returnType
                _ -> addError $ "Undefined function: " ++ name >> return TypeInt
        StmtExpression expr -> typeCheck expr >> return TypeVoid
        StmtDeclaration name typ value -> do
            valueType <- typeCheck value
            if valueType == typ
                then do
                    insertSymbol name (VariableSymbol name typ)
                    return TypeVoid
                else addError $ "Type mismatch in declaration: " ++ name >> return TypeVoid
        StmtAssignment name value -> do
            symbol <- lookupSymbol name
            valueType <- typeCheck value
            case symbol of
                Just (VariableSymbol _ varType) -> 
                    if valueType == varType
                        then return TypeVoid
                        else addError $ "Type mismatch in assignment: " ++ name >> return TypeVoid
                _ -> addError $ "Undefined variable: " ++ name >> return TypeVoid
        StmtIf condition thenStmt elseStmt -> do
            condType <- typeCheck condition
            if condType == TypeBool
                then do
                    typeCheck thenStmt
                    typeCheck elseStmt
                    return TypeVoid
                else addError "Condition must be boolean" >> return TypeVoid
        StmtWhile condition body -> do
            condType <- typeCheck condition
            if condType == TypeBool
                then do
                    typeCheck body
                    return TypeVoid
                else addError "While condition must be boolean" >> return TypeVoid
        StmtBlock statements -> do
            enterScope
            mapM_ typeCheck statements
            exitScope
            return TypeVoid
        StmtReturn value -> do
            valueType <- typeCheck value
            return TypeVoid
        Program statements -> do
            mapM_ typeCheck statements
            return TypeVoid

-- 操作符类型检查
checkBinaryOp :: BinaryOp -> Type -> Type -> SemanticAnalyzer Type
checkBinaryOp op leftType rightType = 
    case op of
        OpAdd | leftType == TypeInt && rightType == TypeInt -> return TypeInt
        OpSub | leftType == TypeInt && rightType == TypeInt -> return TypeInt
        OpMul | leftType == TypeInt && rightType == TypeInt -> return TypeInt
        OpDiv | leftType == TypeInt && rightType == TypeInt -> return TypeInt
        OpEq | leftType == rightType -> return TypeBool
        OpLt | leftType == TypeInt && rightType == TypeInt -> return TypeBool
        OpGt | leftType == TypeInt && rightType == TypeInt -> return TypeBool
        OpAnd | leftType == TypeBool && rightType == TypeBool -> return TypeBool
        OpOr | leftType == TypeBool && rightType == TypeBool -> return TypeBool
        _ -> addError $ "Invalid binary operation: " ++ show op >> return TypeInt

checkUnaryOp :: UnaryOp -> Type -> SemanticAnalyzer Type
checkUnaryOp op exprType = 
    case op of
        OpNeg | exprType == TypeInt -> return TypeInt
        OpNot | exprType == TypeBool -> return TypeBool
        _ -> addError $ "Invalid unary operation: " ++ show op >> return exprType

-- 错误处理
addError :: String -> SemanticAnalyzer ()
addError error = SemanticAnalyzer $ \s -> 
    let newErrors = error : errors s
        newState = s { errors = newErrors }
    in (Right (), newState)

-- 语义分析运行函数
analyzeSemantics :: AST -> Either [String] AST
analyzeSemantics ast = 
    let initialState = SemanticState (Scope Map.empty Nothing) []
        (result, finalState) = runSemanticAnalyzer (typeCheck ast) initialState
    in case result of
        Left err -> Left [err]
        Right _ -> if null (errors finalState)
                   then Right ast
                   else Left (reverse (errors finalState))
```

## 代码生成器

### 中间表示

```haskell
-- 三地址码指令
data IRInstruction = 
    -- 算术运算
    IRAdd String String String
    | IRSub String String String
    | IRMul String String String
    | IRDiv String String String
    -- 比较运算
    | IREq String String String
    | IRLt String String String
    | IRGt String String String
    -- 逻辑运算
    | IRAnd String String String
    | IROr String String String
    | IRNot String String
    -- 控制流
    | IRLabel String
    | IRJump String
    | IRJumpIf String String String
    | IRJumpIfNot String String String
    -- 内存操作
    | IRLoad String String
    | IRStore String String
    -- 函数调用
    | IRCall String [String] String
    | IRReturn String
    deriving Show

-- 中间表示程序
data IRProgram = IRProgram
    { functions :: [IRFunction]
    } deriving Show

-- 中间表示函数
data IRFunction = IRFunction
    { name :: String
    , parameters :: [String]
    , instructions :: [IRInstruction]
    } deriving Show

-- 代码生成器状态
data CodeGenState = CodeGenState
    { tempCounter :: Int
    , labelCounter :: Int
    , currentFunction :: String
    } deriving Show

-- 代码生成器
newtype CodeGenerator a = CodeGenerator 
    { runCodeGenerator :: CodeGenState -> (a, CodeGenState) }

instance Functor CodeGenerator where
    fmap f (CodeGenerator cg) = CodeGenerator $ \s -> 
        let (a, s') = cg s
        in (f a, s')

instance Applicative CodeGenerator where
    pure a = CodeGenerator $ \s -> (a, s)
    (CodeGenerator f) <*> (CodeGenerator a) = CodeGenerator $ \s -> 
        let (g, s') = f s
            (b, s'') = a s'
        in (g b, s'')

instance Monad CodeGenerator where
    return = pure
    (CodeGenerator m) >>= f = CodeGenerator $ \s -> 
        let (a, s') = m s
            (CodeGenerator g) = f a
        in g s'

-- 临时变量生成
newTemp :: CodeGenerator String
newTemp = CodeGenerator $ \s -> 
    let temp = "t" ++ show (tempCounter s)
        newState = s { tempCounter = tempCounter s + 1 }
    in (temp, newState)

-- 标签生成
newLabel :: CodeGenerator String
newLabel = CodeGenerator $ \s -> 
    let label = "L" ++ show (labelCounter s)
        newState = s { labelCounter = labelCounter s + 1 }
    in (label, newState)

-- 表达式代码生成
generateExpression :: AST -> CodeGenerator (String, [IRInstruction])
generateExpression ast = 
    case ast of
        ExprInteger n -> 
            return (show n, [])
        ExprBoolean b -> 
            return (show b, [])
        ExprIdentifier name -> 
            return (name, [])
        ExprBinaryOp op left right -> do
            (leftTemp, leftCode) <- generateExpression left
            (rightTemp, rightCode) <- generateExpression right
            resultTemp <- newTemp
            let opCode = case op of
                    OpAdd -> IRAdd resultTemp leftTemp rightTemp
                    OpSub -> IRSub resultTemp leftTemp rightTemp
                    OpMul -> IRMul resultTemp leftTemp rightTemp
                    OpDiv -> IRDiv resultTemp leftTemp rightTemp
                    OpEq -> IREq resultTemp leftTemp rightTemp
                    OpLt -> IRLt resultTemp leftTemp rightTemp
                    OpGt -> IRGt resultTemp leftTemp rightTemp
                    OpAnd -> IRAnd resultTemp leftTemp rightTemp
                    OpOr -> IROr resultTemp leftTemp rightTemp
            return (resultTemp, leftCode ++ rightCode ++ [opCode])
        ExprUnaryOp op expr -> do
            (exprTemp, exprCode) <- generateExpression expr
            resultTemp <- newTemp
            let opCode = case op of
                    OpNeg -> IRSub resultTemp "0" exprTemp
                    OpNot -> IRNot resultTemp exprTemp
            return (resultTemp, exprCode ++ [opCode])
        ExprCall name args -> do
            argTemps <- mapM generateExpression args
            let (argNames, argCodes) = unzip argTemps
                allCode = concat argCodes
            resultTemp <- newTemp
            return (resultTemp, allCode ++ [IRCall name argNames resultTemp])
        _ -> return ("", [])

-- 语句代码生成
generateStatement :: AST -> CodeGenerator [IRInstruction]
generateStatement ast = 
    case ast of
        StmtExpression expr -> do
            (_, code) <- generateExpression expr
            return code
        StmtDeclaration name _ value -> do
            (valueTemp, valueCode) <- generateExpression value
            return $ valueCode ++ [IRStore name valueTemp]
        StmtAssignment name value -> do
            (valueTemp, valueCode) <- generateExpression value
            return $ valueCode ++ [IRStore name valueTemp]
        StmtIf condition thenStmt elseStmt -> do
            (condTemp, condCode) <- generateExpression condition
            thenLabel <- newLabel
            elseLabel <- newLabel
            endLabel <- newLabel
            thenCode <- generateStatement thenStmt
            elseCode <- generateStatement elseStmt
            return $ condCode ++ 
                    [IRJumpIfNot condTemp elseLabel] ++
                    [IRLabel thenLabel] ++
                    thenCode ++
                    [IRJump endLabel] ++
                    [IRLabel elseLabel] ++
                    elseCode ++
                    [IRLabel endLabel]
        StmtWhile condition body -> do
            loopLabel <- newLabel
            bodyLabel <- newLabel
            endLabel <- newLabel
            (condTemp, condCode) <- generateExpression condition
            bodyCode <- generateStatement body
            return $ [IRLabel loopLabel] ++
                    condCode ++
                    [IRJumpIfNot condTemp endLabel] ++
                    [IRLabel bodyLabel] ++
                    bodyCode ++
                    [IRJump loopLabel] ++
                    [IRLabel endLabel]
        StmtBlock statements -> do
            codes <- mapM generateStatement statements
            return $ concat codes
        StmtReturn value -> do
            (valueTemp, valueCode) <- generateExpression value
            return $ valueCode ++ [IRReturn valueTemp]
        _ -> return []

-- 函数代码生成
generateFunction :: AST -> CodeGenerator IRFunction
generateFunction (FuncDef name params returnType body) = do
    let paramNames = map (\(Parameter n _) -> n) params
    bodyCode <- generateStatement body
    return $ IRFunction name paramNames bodyCode

-- 程序代码生成
generateProgram :: AST -> CodeGenerator IRProgram
generateProgram (Program statements) = do
    functions <- mapM generateFunction statements
    return $ IRProgram functions

-- 代码生成运行函数
generateCode :: AST -> IRProgram
generateCode ast = 
    let initialState = CodeGenState 0 0 "main"
        (program, _) = runCodeGenerator (generateProgram ast) initialState
    in program
```

## 实际应用示例

### 简单编译器

```haskell
-- 完整编译器
compile :: String -> Either String IRProgram
compile source = do
    tokens <- tokenize source
    ast <- parse tokens
    case analyzeSemantics ast of
        Left errors -> Left $ "Semantic errors: " ++ show errors
        Right _ -> Right $ generateCode ast

-- 测试程序
testProgram :: String
testProgram = unlines
    [ "int x = 5;"
    , "int y = 3;"
    , "int z = x + y;"
    , "if (z > 5) {"
    , "    return z;"
    , "} else {"
    , "    return 0;"
    , "}"
    ]

-- 运行编译器
runCompiler :: IO ()
runCompiler = do
    putStrLn "Compiling test program..."
    case compile testProgram of
        Left err -> putStrLn $ "Compilation error: " ++ err
        Right program -> do
            putStrLn "Compilation successful!"
            putStrLn $ "Generated IR: " ++ show program
```

## 总结

本文档展示了Haskell中编译器开发的完整实现，包括：

1. **词法分析器**：Token定义、词法分析器框架、基本操作
2. **语法分析器**：AST定义、递归下降解析、表达式和语句解析
3. **语义分析器**：符号表、作用域管理、类型检查
4. **代码生成器**：中间表示、三地址码、代码生成
5. **实际应用**：完整编译器、测试程序

这些技术展示了Haskell在编译器开发中的优势：

- **类型安全**：编译时保证编译器正确性
- **函数式风格**：清晰的编译器结构
- **模式匹配**：优雅的AST处理
- **高阶函数**：抽象编译器模式
- **不可变性**：避免副作用，便于优化

通过这些实现，我们可以看到Haskell不仅适合理论研究，也适合实际的编译器开发。
