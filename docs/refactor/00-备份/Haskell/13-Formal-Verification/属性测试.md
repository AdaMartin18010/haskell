# 属性测试 - Haskell实现

## 概述

属性测试是一种基于属性的测试方法，通过定义程序应该满足的属性，然后自动生成测试用例来验证这些属性。本文档使用Haskell实现属性测试技术，重点介绍QuickCheck框架的使用和扩展。

## QuickCheck基础

### 基本框架

```haskell
import Test.QuickCheck
import Test.QuickCheck.Gen
import Test.QuickCheck.Arbitrary

-- 属性定义
prop_commutative :: Int -> Int -> Bool
prop_commutative x y = x + y == y + x

-- 运行属性测试
runPropertyTest :: IO ()
runPropertyTest = quickCheck prop_commutative

-- 带标签的属性测试
prop_commutative_with_label :: Int -> Int -> Property
prop_commutative_with_label x y = 
    x + y == y + x ==> label "commutative property" True

-- 分类属性测试
prop_commutative_classified :: Int -> Int -> Property
prop_commutative_classified x y = 
    classify (x < 0) "negative first" $
    classify (y < 0) "negative second" $
    classify (x == 0) "zero first" $
    classify (y == 0) "zero second" $
    x + y == y + x
```

### 自定义数据类型

```haskell
-- 自定义数据类型
data BinaryTree a = 
    Leaf
    | Node a (BinaryTree a) (BinaryTree a)
    deriving (Show, Eq)

-- 为自定义类型定义Arbitrary实例
instance Arbitrary a => Arbitrary (BinaryTree a) where
    arbitrary = sized genTree
        where
            genTree 0 = return Leaf
            genTree n = frequency
                [ (1, return Leaf)
                , (3, do
                    x <- arbitrary
                    left <- genTree (n `div` 2)
                    right <- genTree (n `div` 2)
                    return $ Node x left right)
                ]
    
    shrink Leaf = []
    shrink (Node x left right) = 
        [Leaf] ++  -- 收缩为叶子节点
        [Node x' left right | x' <- shrink x] ++  -- 收缩值
        [Node x left' right | left' <- shrink left] ++  -- 收缩左子树
        [Node x left right' | right' <- shrink right]   -- 收缩右子树

-- 二叉树属性
prop_tree_size :: BinaryTree Int -> Bool
prop_tree_size tree = 
    let size = treeSize tree
        height = treeHeight tree
    in size <= 2^height - 1

-- 计算树大小
treeSize :: BinaryTree a -> Int
treeSize Leaf = 0
treeSize (Node _ left right) = 1 + treeSize left + treeSize right

-- 计算树高度
treeHeight :: BinaryTree a -> Int
treeHeight Leaf = 0
treeHeight (Node _ left right) = 1 + max (treeHeight left) (treeHeight right)
```

## 高级属性定义

### 函数属性

```haskell
-- 函数属性：反转两次等于原函数
prop_double_reverse :: [Int] -> Bool
prop_double_reverse xs = reverse (reverse xs) == xs

-- 函数属性：映射保持长度
prop_map_length :: (Int -> Int) -> [Int] -> Bool
prop_map_length f xs = length (map f xs) == length xs

-- 函数属性：过滤保持顺序
prop_filter_order :: (Int -> Bool) -> [Int] -> Bool
prop_filter_order p xs = 
    let filtered = filter p xs
        original = [x | x <- xs, p x]
    in filtered == original

-- 函数属性：折叠的关联性
prop_fold_associativity :: [Int] -> Bool
prop_fold_associativity xs = 
    foldl (+) 0 xs == foldr (+) 0 xs

-- 函数属性：单子的左单位律
prop_monad_left_unit :: Int -> Bool
prop_monad_left_unit x = 
    return x >>= (\y -> return (y + 1)) == return (x + 1)

-- 函数属性：单子的右单位律
prop_monad_right_unit :: Maybe Int -> Bool
prop_monad_right_unit mx = 
    mx >>= return == mx

-- 函数属性：单子的结合律
prop_monad_associativity :: Maybe Int -> Bool
prop_monad_associativity mx = 
    let f x = Just (x + 1)
        g x = Just (x * 2)
    in (mx >>= f) >>= g == mx >>= (\x -> f x >>= g)
```

### 数据结构属性

```haskell
-- 列表属性
prop_list_append_associativity :: [Int] -> [Int] -> [Int] -> Bool
prop_list_append_associativity xs ys zs = 
    (xs ++ ys) ++ zs == xs ++ (ys ++ zs)

prop_list_append_length :: [Int] -> [Int] -> Bool
prop_list_append_length xs ys = 
    length (xs ++ ys) == length xs + length ys

-- 集合属性
prop_set_union_commutativity :: [Int] -> [Int] -> Bool
prop_set_union_commutativity xs ys = 
    let set1 = Set.fromList xs
        set2 = Set.fromList ys
    in Set.union set1 set2 == Set.union set2 set1

prop_set_intersection_idempotent :: [Int] -> Bool
prop_set_intersection_idempotent xs = 
    let set = Set.fromList xs
    in Set.intersection set set == set

-- 映射属性
prop_map_insert_overwrite :: Int -> Int -> Int -> Map Int Int -> Bool
prop_map_insert_overwrite k v1 v2 m = 
    let m1 = Map.insert k v1 m
        m2 = Map.insert k v2 m1
    in Map.lookup k m2 == Just v2

prop_map_delete_insert :: Int -> Int -> Map Int Int -> Bool
prop_map_delete_insert k v m = 
    let m1 = Map.insert k v m
        m2 = Map.delete k m1
    in Map.lookup k m2 == Nothing
```

## 测试数据生成

### 自定义生成器

```haskell
-- 自定义生成器
genSortedList :: Gen [Int]
genSortedList = do
    xs <- listOf arbitrary
    return $ sort xs

genPositiveInt :: Gen Int
genPositiveInt = abs <$> arbitrary

genSmallList :: Gen [Int]
genSmallList = resize 10 $ listOf arbitrary

genBalancedTree :: Gen (BinaryTree Int)
genBalancedTree = sized genBalanced
    where
        genBalanced 0 = return Leaf
        genBalanced n = do
            x <- arbitrary
            let half = n `div` 2
            left <- genBalanced half
            right <- genBalanced (n - half - 1)
            return $ Node x left right

-- 使用自定义生成器的属性
prop_sorted_list_properties :: Property
prop_sorted_list_properties = 
    forAll genSortedList $ \xs ->
        isSorted xs && (null xs || length xs > 0)

-- 检查列表是否有序
isSorted :: Ord a => [a] -> Bool
isSorted [] = True
isSorted [_] = True
isSorted (x:y:xs) = x <= y && isSorted (y:xs)
```

### 条件生成

```haskell
-- 条件生成器
genEvenInt :: Gen Int
genEvenInt = do
    x <- arbitrary
    return $ 2 * x

genOddInt :: Gen Int
genOddInt = do
    x <- arbitrary
    return $ 2 * x + 1

genNonEmptyList :: Gen [Int]
genNonEmptyList = do
    x <- arbitrary
    xs <- listOf arbitrary
    return $ x:xs

genDistinctList :: Gen [Int]
genDistinctList = do
    xs <- listOf arbitrary
    return $ nub xs

-- 使用条件生成器的属性
prop_even_plus_even :: Property
prop_even_plus_even = 
    forAll genEvenInt $ \x ->
    forAll genEvenInt $ \y ->
        even (x + y)

prop_odd_plus_odd :: Property
prop_odd_plus_odd = 
    forAll genOddInt $ \x ->
    forAll genOddInt $ \y ->
        even (x + y)

prop_nonempty_length :: Property
prop_nonempty_length = 
    forAll genNonEmptyList $ \xs ->
        length xs > 0
```

## 模型测试

### 参考实现测试

```haskell
-- 快速排序实现
quickSort :: Ord a => [a] -> [a]
quickSort [] = []
quickSort (x:xs) = 
    let smaller = quickSort [a | a <- xs, a <= x]
        larger = quickSort [a | a <- xs, a > x]
    in smaller ++ [x] ++ larger

-- 参考实现（使用标准库）
referenceSort :: Ord a => [a] -> [a]
referenceSort = sort

-- 模型测试属性
prop_quicksort_model :: [Int] -> Bool
prop_quicksort_model xs = 
    quickSort xs == referenceSort xs

prop_quicksort_sorted :: [Int] -> Bool
prop_quicksort_sorted xs = 
    isSorted $ quickSort xs

prop_quicksort_permutation :: [Int] -> Bool
prop_quicksort_permutation xs = 
    sort (quickSort xs) == sort xs

-- 检查排列
isPermutation :: Eq a => [a] -> [a] -> Bool
isPermutation xs ys = 
    sort xs == sort ys
```

### 不变量测试

```haskell
-- 数据结构不变量
prop_tree_invariant :: BinaryTree Int -> Bool
prop_tree_invariant tree = 
    case tree of
        Leaf -> True
        Node x left right -> 
            all (< x) (treeToList left) &&
            all (> x) (treeToList right) &&
            prop_tree_invariant left &&
            prop_tree_invariant right

-- 将树转换为列表
treeToList :: BinaryTree a -> [a]
treeToList Leaf = []
treeToList (Node x left right) = 
    treeToList left ++ [x] ++ treeToList right

-- 堆不变量
data Heap a = 
    Empty
    | Heap a (Heap a) (Heap a)
    deriving (Show, Eq)

instance Arbitrary a => Arbitrary (Heap a) where
    arbitrary = sized genHeap
        where
            genHeap 0 = return Empty
            genHeap n = frequency
                [ (1, return Empty)
                , (3, do
                    x <- arbitrary
                    left <- genHeap (n `div` 2)
                    right <- genHeap (n `div` 2)
                    return $ Heap x left right)
                ]

-- 堆属性
prop_heap_invariant :: Heap Int -> Bool
prop_heap_invariant heap = 
    case heap of
        Empty -> True
        Heap x left right -> 
            all (>= x) (heapToList left) &&
            all (>= x) (heapToList right) &&
            prop_heap_invariant left &&
            prop_heap_invariant right

-- 将堆转换为列表
heapToList :: Heap a -> [a]
heapToList Empty = []
heapToList (Heap x left right) = 
    x : heapToList left ++ heapToList right
```

## 性能测试

### 性能属性

```haskell
-- 性能测试属性
prop_quicksort_performance :: [Int] -> Property
prop_quicksort_performance xs = 
    let result = quickSort xs
        steps = countComparisons xs
    in classify (length xs <= 10) "small" $
       classify (length xs <= 100) "medium" $
       classify (length xs > 100) "large" $
       steps <= length xs * length xs  -- O(n²)上界

-- 计算比较次数（简化）
countComparisons :: [Int] -> Int
countComparisons xs = length xs * length xs `div` 2

-- 内存使用测试
prop_memory_usage :: [Int] -> Property
prop_memory_usage xs = 
    let result = quickSort xs
    in collect (length xs) $ 
       length result == length xs

-- 时间复杂性测试
prop_time_complexity :: Property
prop_time_complexity = 
    forAll (choose (1, 1000)) $ \n ->
    forAll (vectorOf n arbitrary) $ \xs ->
        let result = quickSort xs
            steps = countComparisons xs
        in steps <= n * n
```

## 错误注入测试

### 错误模型

```haskell
-- 错误注入
data FaultySort = FaultySort
    { originalSort :: [Int] -> [Int]
    , faultySort :: [Int] -> [Int]
    }

-- 创建有错误的排序
createFaultySort :: FaultySort
createFaultySort = FaultySort
    { originalSort = sort
    , faultySort = \xs -> 
        if length xs > 10 
        then reverse $ sort xs  -- 大列表时反转
        else sort xs           -- 小列表时正常
    }

-- 错误检测属性
prop_fault_detection :: Property
prop_fault_detection = 
    let faulty = createFaultySort
    in forAll (listOf arbitrary) $ \xs ->
        if length xs > 10
        then faultySort faulty xs /= originalSort faulty xs
        else faultySort faulty xs == originalSort faulty xs
```

## 回归测试

### 回归测试属性

```haskell
-- 已知的回归测试用例
regressionTestCases :: [(String, [Int])]
regressionTestCases = 
    [ ("empty list", [])
    , ("single element", [1])
    , ("two elements", [2, 1])
    , ("already sorted", [1, 2, 3, 4, 5])
    , ("reverse sorted", [5, 4, 3, 2, 1])
    , ("duplicates", [3, 1, 4, 1, 5, 9, 2, 6])
    , ("negative numbers", [-3, -1, -4, -1, -5])
    ]

-- 回归测试属性
prop_regression_tests :: Property
prop_regression_tests = 
    conjoin $ map testCase regressionTestCases
    where
        testCase (name, xs) = 
            label name $ quickSort xs == sort xs

-- 历史bug测试
prop_historical_bugs :: Property
prop_historical_bugs = 
    conjoin
        [ label "bug1" $ quickSort [3, 1, 4, 1, 5] == [1, 1, 3, 4, 5]
        , label "bug2" $ quickSort [] == []
        , label "bug3" $ quickSort [1] == [1]
        , label "bug4" $ quickSort [2, 1] == [1, 2]
        ]
```

## 测试报告

### 测试统计

```haskell
-- 测试统计
data TestStats = TestStats
    { totalTests :: Int
    , passedTests :: Int
    , failedTests :: Int
    , averageSize :: Double
    , maxSize :: Int
    , minSize :: Int
    } deriving Show

-- 收集测试统计
collectTestStats :: [TestResult] -> TestStats
collectTestStats results = 
    let total = length results
        passed = length $ filter isSuccess results
        failed = total - passed
        sizes = map testSize results
        avgSize = fromIntegral (sum sizes) / fromIntegral total
        maxSize = maximum sizes
        minSize = minimum sizes
    in TestStats total passed failed avgSize maxSize minSize

-- 测试结果类型
data TestResult = TestResult
    { isSuccess :: Bool
    , testSize :: Int
    , testInput :: String
    } deriving Show

-- 运行测试并收集统计
runTestWithStats :: Testable prop => prop -> IO TestStats
runTestWithStats prop = do
    results <- quickCheckWithResult stdArgs { maxSuccess = 1000 } prop
    return $ collectTestStats [TestResult True 0 ""]  -- 简化
```

## 总结

本文档展示了Haskell中属性测试的完整实现，包括：

1. **QuickCheck基础**：基本框架、自定义数据类型
2. **高级属性定义**：函数属性、数据结构属性
3. **测试数据生成**：自定义生成器、条件生成
4. **模型测试**：参考实现测试、不变量测试
5. **性能测试**：性能属性、内存使用测试
6. **错误注入测试**：错误模型、错误检测
7. **回归测试**：回归测试属性、历史bug测试
8. **测试报告**：测试统计、结果收集

这些技术展示了Haskell在属性测试中的优势：

- **类型安全**：编译时保证测试正确性
- **函数式风格**：清晰的属性定义
- **高阶函数**：抽象测试模式
- **惰性求值**：优化测试性能
- **模式匹配**：优雅的测试用例处理

通过这些实现，我们可以看到Haskell不仅适合理论研究，也适合实际的软件测试和质量保证。
