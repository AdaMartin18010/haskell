# 单元测试 - Haskell实现

## 概述

单元测试是软件质量保证的重要组成部分，通过测试单个函数或模块来确保代码的正确性。本文档使用Haskell实现单元测试，重点介绍HUnit测试框架的使用和最佳实践。

## HUnit测试框架

### 基本框架

```haskell
import Test.HUnit
import Test.HUnit.Base

-- 基本测试用例
testAddition :: Test
testAddition = TestCase $ assertEqual "Addition test" 4 (2 + 2)

-- 测试列表
testSuite :: Test
testSuite = TestList
    [ TestLabel "Addition" testAddition
    , TestLabel "Subtraction" testSubtraction
    , TestLabel "Multiplication" testMultiplication
    ]

-- 更多测试用例
testSubtraction :: Test
testSubtraction = TestCase $ assertEqual "Subtraction test" 2 (4 - 2)

testMultiplication :: Test
testMultiplication = TestCase $ assertEqual "Multiplication test" 8 (4 * 2)

-- 运行测试
runTests :: IO Counts
runTests = runTestTT testSuite

-- 主函数
main :: IO ()
main = do
    counts <- runTests
    putStrLn $ "Tests run: " ++ show (cases counts)
    putStrLn $ "Failures: " ++ show (failures counts)
    putStrLn $ "Errors: " ++ show (errors counts)
```

### 断言函数

```haskell
-- 基本断言
testAssertions :: Test
testAssertions = TestList
    [ TestLabel "assertEqual" $ TestCase $
        assertEqual "Should be equal" 5 (2 + 3)
    
    , TestLabel "assertBool" $ TestCase $
        assertBool "Should be true" (5 > 3)
    
    , TestLabel "assertString" $ TestCase $
        assertString "This test should pass"
    
    , TestLabel "assertFailure" $ TestCase $
        when False $ assertFailure "This should not be called"
    
    , TestLabel "assertEqual with tolerance" $ TestCase $
        assertEqual "Floating point comparison" 3.14159 3.14159
    ]

-- 自定义断言
assertNear :: (Show a, Fractional a, Ord a) => String -> a -> a -> a -> Assertion
assertNear message expected actual tolerance = 
    let diff = abs (expected - actual)
    in assertBool (message ++ ": expected " ++ show expected ++ 
                  ", got " ++ show actual ++ ", difference " ++ show diff)
       (diff <= tolerance)

-- 使用自定义断言
testCustomAssertion :: Test
testCustomAssertion = TestCase $ do
    assertNear "Pi approximation" 3.14159 3.14159265359 0.0001
    assertNear "Square root" 1.414 1.41421356237 0.001
```

## 数据结构测试

### 列表操作测试

```haskell
-- 列表函数测试
testListOperations :: Test
testListOperations = TestList
    [ TestLabel "head" $ TestCase $
        assertEqual "head of [1,2,3]" 1 (head [1,2,3])
    
    , TestLabel "tail" $ TestCase $
        assertEqual "tail of [1,2,3]" [2,3] (tail [1,2,3])
    
    , TestLabel "length" $ TestCase $
        assertEqual "length of [1,2,3]" 3 (length [1,2,3])
    
    , TestLabel "reverse" $ TestCase $
        assertEqual "reverse [1,2,3]" [3,2,1] (reverse [1,2,3])
    
    , TestLabel "map" $ TestCase $
        assertEqual "map (+1) [1,2,3]" [2,3,4] (map (+1) [1,2,3])
    
    , TestLabel "filter" $ TestCase $
        assertEqual "filter (>2) [1,2,3,4]" [3,4] (filter (>2) [1,2,3,4])
    
    , TestLabel "foldl" $ TestCase $
        assertEqual "foldl (+) 0 [1,2,3]" 6 (foldl (+) 0 [1,2,3])
    
    , TestLabel "foldr" $ TestCase $
        assertEqual "foldr (+) 0 [1,2,3]" 6 (foldr (+) 0 [1,2,3])
    ]

-- 自定义列表函数测试
testCustomListFunctions :: Test
testCustomListFunctions = TestList
    [ TestLabel "myMap" $ TestCase $
        assertEqual "myMap (+1) [1,2,3]" [2,3,4] (myMap (+1) [1,2,3])
    
    , TestLabel "myFilter" $ TestCase $
        assertEqual "myFilter (>2) [1,2,3,4]" [3,4] (myFilter (>2) [1,2,3,4])
    
    , TestLabel "myFoldl" $ TestCase $
        assertEqual "myFoldl (+) 0 [1,2,3]" 6 (myFoldl (+) 0 [1,2,3])
    ]

-- 自定义列表函数实现
myMap :: (a -> b) -> [a] -> [b]
myMap _ [] = []
myMap f (x:xs) = f x : myMap f xs

myFilter :: (a -> Bool) -> [a] -> [a]
myFilter _ [] = []
myFilter p (x:xs) = if p x then x : myFilter p xs else myFilter p xs

myFoldl :: (b -> a -> b) -> b -> [a] -> b
myFoldl _ acc [] = acc
myFoldl f acc (x:xs) = myFoldl f (f acc x) xs
```

### 树结构测试

```haskell
-- 二叉树定义
data BinaryTree a = 
    Leaf
    | Node a (BinaryTree a) (BinaryTree a)
    deriving (Show, Eq)

-- 二叉树测试
testBinaryTree :: Test
testBinaryTree = TestList
    [ TestLabel "treeSize" $ TestList
        [ TestCase $ assertEqual "size of Leaf" 0 (treeSize Leaf)
        , TestCase $ assertEqual "size of single node" 1 (treeSize (Node 1 Leaf Leaf))
        , TestCase $ assertEqual "size of complex tree" 3 (treeSize (Node 1 (Node 2 Leaf Leaf) Leaf))
        ]
    
    , TestLabel "treeHeight" $ TestList
        [ TestCase $ assertEqual "height of Leaf" 0 (treeHeight Leaf)
        , TestCase $ assertEqual "height of single node" 1 (treeHeight (Node 1 Leaf Leaf))
        , TestCase $ assertEqual "height of complex tree" 2 (treeHeight (Node 1 (Node 2 Leaf Leaf) Leaf))
        ]
    
    , TestLabel "treeToList" $ TestList
        [ TestCase $ assertEqual "Leaf to list" [] (treeToList Leaf)
        , TestCase $ assertEqual "single node to list" [1] (treeToList (Node 1 Leaf Leaf))
        , TestCase $ assertEqual "complex tree to list" [2,1,3] (treeToList (Node 1 (Node 2 Leaf Leaf) (Node 3 Leaf Leaf)))
        ]
    
    , TestLabel "insert" $ TestList
        [ TestCase $ assertEqual "insert into Leaf" (Node 1 Leaf Leaf) (insert 1 Leaf)
        , TestCase $ assertEqual "insert smaller" (Node 2 (Node 1 Leaf Leaf) Leaf) (insert 1 (Node 2 Leaf Leaf))
        , TestCase $ assertEqual "insert larger" (Node 2 Leaf (Node 3 Leaf Leaf)) (insert 3 (Node 2 Leaf Leaf))
        ]
    ]

-- 二叉树函数实现
treeSize :: BinaryTree a -> Int
treeSize Leaf = 0
treeSize (Node _ left right) = 1 + treeSize left + treeSize right

treeHeight :: BinaryTree a -> Int
treeHeight Leaf = 0
treeHeight (Node _ left right) = 1 + max (treeHeight left) (treeHeight right)

treeToList :: BinaryTree a -> [a]
treeToList Leaf = []
treeToList (Node x left right) = treeToList left ++ [x] ++ treeToList right

insert :: Ord a => a -> BinaryTree a -> BinaryTree a
insert x Leaf = Node x Leaf Leaf
insert x (Node y left right) = 
    if x <= y 
    then Node y (insert x left) right
    else Node y left (insert x right)
```

## 算法测试

### 排序算法测试

```haskell
-- 排序算法测试
testSortingAlgorithms :: Test
testSortingAlgorithms = TestList
    [ TestLabel "bubbleSort" $ TestList
        [ TestCase $ assertEqual "empty list" [] (bubbleSort [])
        , TestCase $ assertEqual "single element" [1] (bubbleSort [1])
        , TestCase $ assertEqual "sorted list" [1,2,3] (bubbleSort [1,2,3])
        , TestCase $ assertEqual "reverse sorted" [1,2,3] (bubbleSort [3,2,1])
        , TestCase $ assertEqual "random list" [1,2,3,4,5] (bubbleSort [3,1,4,2,5])
        ]
    
    , TestLabel "quickSort" $ TestList
        [ TestCase $ assertEqual "empty list" [] (quickSort [])
        , TestCase $ assertEqual "single element" [1] (quickSort [1])
        , TestCase $ assertEqual "sorted list" [1,2,3] (quickSort [1,2,3])
        , TestCase $ assertEqual "reverse sorted" [1,2,3] (quickSort [3,2,1])
        , TestCase $ assertEqual "random list" [1,2,3,4,5] (quickSort [3,1,4,2,5])
        ]
    
    , TestLabel "mergeSort" $ TestList
        [ TestCase $ assertEqual "empty list" [] (mergeSort [])
        , TestCase $ assertEqual "single element" [1] (mergeSort [1])
        , TestCase $ assertEqual "sorted list" [1,2,3] (mergeSort [1,2,3])
        , TestCase $ assertEqual "reverse sorted" [1,2,3] (mergeSort [3,2,1])
        , TestCase $ assertEqual "random list" [1,2,3,4,5] (mergeSort [3,1,4,2,5])
        ]
    ]

-- 排序算法实现
bubbleSort :: Ord a => [a] -> [a]
bubbleSort [] = []
bubbleSort xs = 
    let (swapped, ys) = bubblePass xs
    in if swapped then bubbleSort ys else ys

bubblePass :: Ord a => [a] -> (Bool, [a])
bubblePass [] = (False, [])
bubblePass [x] = (False, [x])
bubblePass (x:y:xs) = 
    if x > y 
    then let (swapped, ys) = bubblePass (x:xs) in (True, y:ys)
    else let (swapped, ys) = bubblePass (y:xs) in (swapped, x:ys)

quickSort :: Ord a => [a] -> [a]
quickSort [] = []
quickSort (x:xs) = 
    let smaller = quickSort [a | a <- xs, a <= x]
        larger = quickSort [a | a <- xs, a > x]
    in smaller ++ [x] ++ larger

mergeSort :: Ord a => [a] -> [a]
mergeSort [] = []
mergeSort [x] = [x]
mergeSort xs = 
    let (left, right) = splitAt (length xs `div` 2) xs
    in merge (mergeSort left) (mergeSort right)

merge :: Ord a => [a] -> [a] -> [a]
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys) = 
    if x <= y 
    then x : merge xs (y:ys)
    else y : merge (x:xs) ys
```

### 搜索算法测试

```haskell
-- 搜索算法测试
testSearchAlgorithms :: Test
testSearchAlgorithms = TestList
    [ TestLabel "linearSearch" $ TestList
        [ TestCase $ assertEqual "find existing element" (Just 2) (linearSearch 3 [1,2,3,4,5])
        , TestCase $ assertEqual "find first element" (Just 0) (linearSearch 1 [1,2,3,4,5])
        , TestCase $ assertEqual "find last element" (Just 4) (linearSearch 5 [1,2,3,4,5])
        , TestCase $ assertEqual "element not found" Nothing (linearSearch 6 [1,2,3,4,5])
        , TestCase $ assertEqual "empty list" Nothing (linearSearch 1 [])
        ]
    
    , TestLabel "binarySearch" $ TestList
        [ TestCase $ assertEqual "find existing element" (Just 2) (binarySearch 3 [1,2,3,4,5])
        , TestCase $ assertEqual "find first element" (Just 0) (binarySearch 1 [1,2,3,4,5])
        , TestCase $ assertEqual "find last element" (Just 4) (binarySearch 5 [1,2,3,4,5])
        , TestCase $ assertEqual "element not found" Nothing (binarySearch 6 [1,2,3,4,5])
        , TestCase $ assertEqual "empty list" Nothing (binarySearch 1 [])
        ]
    ]

-- 搜索算法实现
linearSearch :: Eq a => a -> [a] -> Maybe Int
linearSearch _ [] = Nothing
linearSearch x (y:ys) = 
    if x == y 
    then Just 0
    else case linearSearch x ys of
        Just i -> Just (i + 1)
        Nothing -> Nothing

binarySearch :: Ord a => a -> [a] -> Maybe Int
binarySearch _ [] = Nothing
binarySearch x xs = binarySearchHelper x xs 0 (length xs - 1)

binarySearchHelper :: Ord a => a -> [a] -> Int -> Int -> Maybe Int
binarySearchHelper _ _ low high | low > high = Nothing
binarySearchHelper x xs low high = 
    let mid = (low + high) `div` 2
        midVal = xs !! mid
    in if x == midVal
       then Just mid
       else if x < midVal
            then binarySearchHelper x xs low (mid - 1)
            else binarySearchHelper x xs (mid + 1) high
```

## 函数式编程测试

### 高阶函数测试

```haskell
-- 高阶函数测试
testHigherOrderFunctions :: Test
testHigherOrderFunctions = TestList
    [ TestLabel "compose" $ TestList
        [ TestCase $ assertEqual "compose (+1) (*2)" 5 ((+1) . (*2) $ 2)
        , TestCase $ assertEqual "compose reverse map" "321" ((reverse . map show) [1,2,3])
        ]
    
    , TestLabel "curry" $ TestList
        [ TestCase $ assertEqual "curry add" 5 (curry (+) 2 3)
        , TestCase $ assertEqual "curry max" 3 (curry max 2 3)
        ]
    
    , TestLabel "uncurry" $ TestList
        [ TestCase $ assertEqual "uncurry add" 5 (uncurry (+) (2, 3))
        , TestCase $ assertEqual "uncurry max" 3 (uncurry max (2, 3))
        ]
    
    , TestLabel "flip" $ TestList
        [ TestCase $ assertEqual "flip (-)" 1 (flip (-) 3 2)
        , TestCase $ assertEqual "flip (++)" "worldhello" (flip (++) "hello" "world")
        ]
    ]

-- 自定义高阶函数测试
testCustomHigherOrderFunctions :: Test
testCustomHigherOrderFunctions = TestList
    [ TestLabel "myCompose" $ TestList
        [ TestCase $ assertEqual "myCompose (+1) (*2)" 5 (myCompose (+1) (*2) 2)
        , TestCase $ assertEqual "myCompose reverse map" "321" (myCompose reverse (map show) [1,2,3])
        ]
    
    , TestLabel "myCurry" $ TestList
        [ TestCase $ assertEqual "myCurry add" 5 (myCurry (+) 2 3)
        , TestCase $ assertEqual "myCurry max" 3 (myCurry max 2 3)
        ]
    
    , TestLabel "myUncurry" $ TestList
        [ TestCase $ assertEqual "myUncurry add" 5 (myUncurry (+) (2, 3))
        , TestCase $ assertEqual "myUncurry max" 3 (myUncurry max (2, 3))
        ]
    ]

-- 自定义高阶函数实现
myCompose :: (b -> c) -> (a -> b) -> a -> c
myCompose f g x = f (g x)

myCurry :: ((a, b) -> c) -> a -> b -> c
myCurry f x y = f (x, y)

myUncurry :: (a -> b -> c) -> (a, b) -> c
myUncurry f (x, y) = f x y
```

### 单子测试

```haskell
-- 单子测试
testMonads :: Test
testMonads = TestList
    [ TestLabel "Maybe monad" $ TestList
        [ TestCase $ assertEqual "return" (Just 5) (return 5 :: Maybe Int)
        , TestCase $ assertEqual "bind" (Just 6) (Just 5 >>= \x -> Just (x + 1))
        , TestCase $ assertEqual "bind with Nothing" Nothing (Nothing >>= \x -> Just (x + 1))
        ]
    
    , TestLabel "List monad" $ TestList
        [ TestCase $ assertEqual "return" [5] (return 5 :: [Int])
        , TestCase $ assertEqual "bind" [2,3,3,4] ([1,2] >>= \x -> [x+1, x+2])
        ]
    
    , TestLabel "IO monad" $ TestCase $ do
        result <- return "Hello, World!"
        assertEqual "IO return" "Hello, World!" result
    ]

-- 自定义单子测试
testCustomMonads :: Test
testCustomMonads = TestList
    [ TestLabel "State monad" $ TestList
        [ TestCase $ assertEqual "get" (5, 5) (runState get 5)
        , TestCase $ assertEqual "put" ((), 10) (runState (put 10) 5)
        , TestCase $ assertEqual "modify" ((), 6) (runState (modify (+1)) 5)
        ]
    
    , TestLabel "Reader monad" $ TestList
        [ TestCase $ assertEqual "ask" (5, 5) (runReader ask 5)
        , TestCase $ assertEqual "local" (10, 5) (runReader (local (+5) ask) 5)
        ]
    ]

-- 状态单子实现
newtype State s a = State { runState :: s -> (a, s) }

instance Functor (State s) where
    fmap f (State g) = State $ \s -> let (a, s') = g s in (f a, s')

instance Applicative (State s) where
    pure a = State $ \s -> (a, s)
    (State f) <*> (State g) = State $ \s -> 
        let (h, s') = f s
            (a, s'') = g s'
        in (h a, s'')

instance Monad (State s) where
    return = pure
    (State f) >>= g = State $ \s -> 
        let (a, s') = f s
            State h = g a
        in h s'

get :: State s s
get = State $ \s -> (s, s)

put :: s -> State s ()
put s = State $ \_ -> ((), s)

modify :: (s -> s) -> State s ()
modify f = State $ \s -> ((), f s)

-- 读取器单子实现
newtype Reader r a = Reader { runReader :: r -> a }

instance Functor (Reader r) where
    fmap f (Reader g) = Reader $ f . g

instance Applicative (Reader r) where
    pure a = Reader $ \_ -> a
    (Reader f) <*> (Reader g) = Reader $ \r -> f r (g r)

instance Monad (Reader r) where
    return = pure
    (Reader f) >>= g = Reader $ \r -> 
        let a = f r
            Reader h = g a
        in h r

ask :: Reader r r
ask = Reader id

local :: (r -> r) -> Reader r a -> Reader r a
local f (Reader g) = Reader $ g . f
```

## 性能测试

### 基准测试

```haskell
import Criterion.Main
import Criterion.Types

-- 基准测试
benchmarkTests :: IO ()
benchmarkTests = defaultMain
    [ bgroup "Sorting Algorithms"
        [ bench "bubbleSort" $ nf bubbleSort [3,1,4,2,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,9,7,1,6,9,3,9,9,3,7,5,1,0,5,8,2,0,9,7,4,9,4,4,5,9,2,3,0,7,8,1,6,4,0,6,6,1,3,0,0,1,8,9,4,8,0,9,1,2,8,5,0,2,5,3,3]
        , bench "quickSort" $ nf quickSort [3,1,4,2,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,9,7,1,6,9,3,9,9,3,7,5,1,0,5,8,2,0,9,7,4,9,4,4,5,9,2,3,0,7,8,1,6,4,0,6,6,1,3,0,0,1,8,9,4,8,0,9,1,2,8,5,0,2,5,3,3]
        , bench "mergeSort" $ nf mergeSort [3,1,4,2,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,9,7,1,6,9,3,9,9,3,7,5,1,0,5,8,2,0,9,7,4,9,4,4,5,9,2,3,0,7,8,1,6,4,0,6,6,1,3,0,0,1,8,9,4,8,0,9,1,2,8,5,0,2,5,3,3]
        ]
    , bgroup "Search Algorithms"
        [ bench "linearSearch" $ nf (linearSearch 50) [1..100]
        , bench "binarySearch" $ nf (binarySearch 50) [1..100]
        ]
    , bgroup "List Operations"
        [ bench "map" $ nf (map (+1)) [1..1000]
        , bench "filter" $ nf (filter (>500)) [1..1000]
        , bench "foldl" $ nf (foldl (+) 0) [1..1000]
        , bench "foldr" $ nf (foldr (+) 0) [1..1000]
        ]
    ]

-- 内存使用测试
memoryUsageTest :: IO ()
memoryUsageTest = do
    let largeList = [1..1000000]
    putStrLn "Testing memory usage..."
    
    -- 测试惰性求值
    let lazySum = sum largeList
    putStrLn $ "Lazy sum: " ++ show lazySum
    
    -- 测试严格求值
    let strictSum = foldl' (+) 0 largeList
    putStrLn $ "Strict sum: " ++ show strictSum
```

### 压力测试

```haskell
-- 压力测试
stressTest :: Test
stressTest = TestList
    [ TestLabel "Large List Operations" $ TestList
        [ TestCase $ do
            let largeList = [1..10000]
            assertEqual "large map" (length largeList) (length (map (+1) largeList))
        
        , TestCase $ do
            let largeList = [1..10000]
            assertEqual "large filter" 5000 (length (filter (<=5000) largeList))
        
        , TestCase $ do
            let largeList = [1..10000]
            assertEqual "large foldl" 50005000 (foldl (+) 0 largeList)
        ]
    
    , TestLabel "Deep Recursion" $ TestList
        [ TestCase $ do
            let deepTree = createDeepTree 1000
            assertEqual "deep tree size" 1000 (treeSize deepTree)
        
        , TestCase $ do
            let deepTree = createDeepTree 1000
            assertEqual "deep tree height" 1000 (treeHeight deepTree)
        ]
    ]

-- 创建深度树
createDeepTree :: Int -> BinaryTree Int
createDeepTree 0 = Leaf
createDeepTree n = Node n (createDeepTree (n-1)) Leaf
```

## 测试最佳实践

### 测试组织

```haskell
-- 测试模块组织
module TestModule where

import Test.HUnit
import qualified Data.List as List
import qualified Data.Maybe as Maybe

-- 测试组
allTests :: Test
allTests = TestList
    [ TestLabel "Data.List" listTests
    , TestLabel "Data.Maybe" maybeTests
    , TestLabel "Custom Functions" customTests
    ]

-- 列表测试
listTests :: Test
listTests = TestList
    [ TestLabel "sort" $ TestCase $ 
        assertEqual "sort [3,1,4,2]" [1,2,3,4] (List.sort [3,1,4,2])
    , TestLabel "reverse" $ TestCase $ 
        assertEqual "reverse [1,2,3]" [3,2,1] (List.reverse [1,2,3])
    , TestLabel "length" $ TestCase $ 
        assertEqual "length [1,2,3]" 3 (List.length [1,2,3])
    ]

-- Maybe测试
maybeTests :: Test
maybeTests = TestList
    [ TestLabel "fromJust" $ TestCase $ 
        assertEqual "fromJust (Just 5)" 5 (Maybe.fromJust (Just 5))
    , TestLabel "isJust" $ TestCase $ 
        assertBool "isJust (Just 5)" (Maybe.isJust (Just 5))
    , TestLabel "isNothing" $ TestCase $ 
        assertBool "isNothing Nothing" (Maybe.isNothing Nothing)
    ]

-- 自定义函数测试
customTests :: Test
customTests = TestList
    [ TestLabel "safeDivide" $ TestList
        [ TestCase $ assertEqual "safe divide" (Just 2.5) (safeDivide 5 2)
        , TestCase $ assertEqual "divide by zero" Nothing (safeDivide 5 0)
        ]
    , TestLabel "factorial" $ TestList
        [ TestCase $ assertEqual "factorial 0" 1 (factorial 0)
        , TestCase $ assertEqual "factorial 5" 120 (factorial 5)
        ]
    ]

-- 自定义函数
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

### 测试数据生成

```haskell
-- 测试数据生成器
import Test.QuickCheck

-- 自定义数据类型生成器
instance Arbitrary (BinaryTree Int) where
    arbitrary = sized genTree
        where
            genTree 0 = return Leaf
            genTree n = frequency
                [ (1, return Leaf)
                , (3, do
                    x <- arbitrary
                    left <- genTree (n `div` 2)
                    right <- genTree (n `div` 2)
                    return $ Node x left right)
                ]
    
    shrink Leaf = []
    shrink (Node x left right) = 
        [Leaf] ++  -- 收缩为叶子节点
        [Node x' left right | x' <- shrink x] ++  -- 收缩值
        [Node x left' right | left' <- shrink left] ++  -- 收缩左子树
        [Node x left right' | right' <- shrink right]   -- 收缩右子树

-- 属性测试
prop_tree_size :: BinaryTree Int -> Bool
prop_tree_size tree = 
    let size = treeSize tree
        height = treeHeight tree
    in size <= 2^height - 1

prop_tree_insert :: Int -> BinaryTree Int -> Bool
prop_tree_insert x tree = 
    let newTree = insert x tree
        list = treeToList newTree
    in isSorted list && length list == length (treeToList tree) + 1

-- 检查列表是否有序
isSorted :: Ord a => [a] -> Bool
isSorted [] = True
isSorted [_] = True
isSorted (x:y:xs) = x <= y && isSorted (y:xs)

-- 运行属性测试
runPropertyTests :: IO ()
runPropertyTests = do
    putStrLn "Running property tests..."
    quickCheck prop_tree_size
    quickCheck prop_tree_insert
```

## 测试运行器

### 主测试运行器

```haskell
-- 主测试运行器
main :: IO ()
main = do
    putStrLn "Running Haskell Unit Tests..."
    putStrLn "================================"
    
    -- 运行基本测试
    putStrLn "\n1. Basic Tests:"
    counts1 <- runTestTT basicTests
    printTestResults counts1
    
    -- 运行数据结构测试
    putStrLn "\n2. Data Structure Tests:"
    counts2 <- runTestTT dataStructureTests
    printTestResults counts2
    
    -- 运行算法测试
    putStrLn "\n3. Algorithm Tests:"
    counts3 <- runTestTT algorithmTests
    printTestResults counts3
    
    -- 运行函数式编程测试
    putStrLn "\n4. Functional Programming Tests:"
    counts4 <- runTestTT functionalTests
    printTestResults counts4
    
    -- 运行压力测试
    putStrLn "\n5. Stress Tests:"
    counts5 <- runTestTT stressTest
    printTestResults counts5
    
    -- 运行属性测试
    putStrLn "\n6. Property Tests:"
    runPropertyTests
    
    -- 总结
    putStrLn "\n================================"
    putStrLn "All tests completed!"

-- 打印测试结果
printTestResults :: Counts -> IO ()
printTestResults counts = do
    putStrLn $ "Tests run: " ++ show (cases counts)
    putStrLn $ "Failures: " ++ show (failures counts)
    putStrLn $ "Errors: " ++ show (errors counts)
    
    if failures counts + errors counts == 0
        then putStrLn "✓ All tests passed!"
        else putStrLn "✗ Some tests failed!"

-- 测试套件
basicTests :: Test
basicTests = TestList
    [ testAssertions
    , testCustomAssertion
    ]

dataStructureTests :: Test
dataStructureTests = TestList
    [ testListOperations
    , testCustomListFunctions
    , testBinaryTree
    ]

algorithmTests :: Test
algorithmTests = TestList
    [ testSortingAlgorithms
    , testSearchAlgorithms
    ]

functionalTests :: Test
functionalTests = TestList
    [ testHigherOrderFunctions
    , testCustomHigherOrderFunctions
    , testMonads
    , testCustomMonads
    ]
```

## 总结

本文档展示了Haskell中单元测试的完整实现，包括：

1. **HUnit框架**：基本测试用例、断言函数、测试组织
2. **数据结构测试**：列表操作、树结构、自定义数据类型
3. **算法测试**：排序算法、搜索算法、性能测试
4. **函数式编程测试**：高阶函数、单子、属性测试
5. **性能测试**：基准测试、压力测试、内存使用测试
6. **最佳实践**：测试组织、数据生成、测试运行器

这些技术展示了Haskell在单元测试中的优势：

- **类型安全**：编译时保证测试正确性
- **函数式风格**：清晰的测试表达
- **高阶函数**：抽象测试模式
- **惰性求值**：优化测试性能
- **属性测试**：基于属性的测试方法

通过这些实现，我们可以看到Haskell不仅适合理论研究，也适合实际的软件测试和质量保证。
