# 函子模式

## 概述

函子是函数式编程中最基础的抽象之一，它提供了一种在保持结构的同时映射数据的能力。本文档从数学基础到实际应用，全面介绍函子模式。

## 数学基础

### 函子定义

**定义**: 函子是范畴之间的映射，保持范畴结构。

$$\text{Functor } F: \mathcal{C} \to \mathcal{D}$$

满足以下条件：

1. **对象映射**: $F: \text{Ob}(\mathcal{C}) \to \text{Ob}(\mathcal{D})$
2. **态射映射**: $F: \text{Hom}(A,B) \to \text{Hom}(F(A), F(B))$
3. **单位元保持**: $F(\text{id}_A) = \text{id}_{F(A)}$
4. **复合保持**: $F(g \circ f) = F(g) \circ F(f)$

### 函子定律

在Haskell中，函子必须满足以下定律：

1. **单位律**: `fmap id = id`
2. **复合律**: `fmap (g . f) = fmap g . fmap f`

### 自然变换

**定义**: 自然变换是两个函子之间的映射。

$$\eta: F \to G$$

对于每个对象 $A$，有态射 $\eta_A: F(A) \to G(A)$，满足自然性条件：

$$G(f) \circ \eta_A = \eta_B \circ F(f)$$

## Haskell实现

### 函子类型类

```haskell
-- 函子类型类定义
class Functor f where
    fmap :: (a -> b) -> f a -> f b
    
    -- 函子定律
    -- 1. fmap id = id
    -- 2. fmap (g . f) = fmap g . fmap f

-- 函子定律验证
functorLaws :: (Functor f, Eq (f a), Eq (f b)) => f a -> (a -> b) -> (b -> c) -> Bool
functorLaws fa f g = 
    fmap id fa == fa &&  -- 单位律
    fmap (g . f) fa == fmap g (fmap f fa)  -- 复合律
```

### 基础函子实例

```haskell
-- Maybe函子
instance Functor Maybe where
    fmap _ Nothing  = Nothing
    fmap f (Just x) = Just (f x)

-- 列表函子
instance Functor [] where
    fmap = map

-- Either函子
instance Functor (Either e) where
    fmap _ (Left e)  = Left e
    fmap f (Right a) = Right (f a)

-- 函数函子
instance Functor ((->) r) where
    fmap = (.)

-- 元组函子
instance Functor ((,) a) where
    fmap f (x, y) = (x, f y)
```

### 高级函子实例

```haskell
-- 状态函子
newtype State s a = State { runState :: s -> (a, s) }

instance Functor (State s) where
    fmap f (State g) = State $ \s -> 
        let (a, s') = g s in (f a, s')

-- Reader函子
newtype Reader r a = Reader { runReader :: r -> a }

instance Functor (Reader r) where
    fmap f (Reader g) = Reader $ f . g

-- Writer函子
newtype Writer w a = Writer { runWriter :: (a, w) }

instance Functor (Writer w) where
    fmap f (Writer (a, w)) = Writer (f a, w)

-- 树函子
data Tree a = Leaf a | Node (Tree a) (Tree a)

instance Functor Tree where
    fmap f (Leaf x) = Leaf (f x)
    fmap f (Node l r) = Node (fmap f l) (fmap f r)
```

## 函子组合

### 函子组合器

```haskell
-- 函子组合
newtype Compose f g a = Compose { getCompose :: f (g a) }

instance (Functor f, Functor g) => Functor (Compose f g) where
    fmap f (Compose fga) = Compose (fmap (fmap f) fga)

-- 函子组合定律验证
composeFunctorLaws :: (Functor f, Functor g, Eq (f (g a))) => 
    f (g a) -> (a -> b) -> (b -> c) -> Bool
composeFunctorLaws fga f g = 
    let compose = Compose fga
    in fmap id compose == compose &&  -- 单位律
       fmap (g . f) compose == fmap g (fmap f compose)  -- 复合律
```

### 函子积

```haskell
-- 函子积
data Product f g a = Product (f a) (g a)

instance (Functor f, Functor g) => Functor (Product f g) where
    fmap f (Product fa ga) = Product (fmap f fa) (fmap f ga)

-- 函子积应用
type MaybeList a = Product Maybe [] a

exampleProduct :: MaybeList Int
exampleProduct = Product (Just 5) [1, 2, 3]

mappedProduct :: MaybeList String
mappedProduct = fmap show exampleProduct
```

### 函子和

```haskell
-- 函子和
data Sum f g a = InL (f a) | InR (g a)

instance (Functor f, Functor g) => Functor (Sum f g) where
    fmap f (InL fa) = InL (fmap f fa)
    fmap f (InR ga) = InR (fmap f ga)

-- 函子和应用
type MaybeEither a = Sum Maybe (Either String) a

exampleSum :: MaybeEither Int
exampleSum = InL (Just 42)

mappedSum :: MaybeEither String
mappedSum = fmap show exampleSum
```

## 函子操作

### 函子操作符

```haskell
-- 函子操作符
(<$>) :: Functor f => (a -> b) -> f a -> f b
(<$>) = fmap

(<$) :: Functor f => a -> f b -> f a
(<$) = fmap . const

($>) :: Functor f => f a -> b -> f b
($>) = flip (<$)

-- 使用示例
example1 :: Maybe Int
example1 = (+1) <$> Just 5  -- Just 6

example2 :: [String]
example2 = "prefix" <$> ["a", "b", "c"]  -- ["prefix", "prefix", "prefix"]

example3 :: Maybe String
example3 = Just 42 $> "result"  -- Just "result"
```

### 函子提升

```haskell
-- 函子提升
liftA :: Applicative f => (a -> b) -> f a -> f b
liftA = fmap

liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2 f x y = f <$> x <*> y

liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftA3 f x y z = f <$> x <*> y <*> z

-- 使用示例
addMaybe :: Maybe Int -> Maybe Int -> Maybe Int
addMaybe = liftA2 (+)

combineLists :: [Int] -> [Int] -> [Int] -> [Int]
combineLists = liftA3 (\x y z -> x + y + z)
```

## 实际应用

### 错误处理

```haskell
-- 安全操作
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

safeSqrt :: Double -> Maybe Double
safeSqrt x
    | x < 0 = Nothing
    | otherwise = Just (sqrt x)

-- 使用函子处理错误
processNumber :: Double -> Maybe String
processNumber x = show <$> safeSqrt x

-- 链式错误处理
processNumberChain :: Double -> Maybe String
processNumberChain x = 
    show <$> (safeDivide x 2 >>= safeSqrt)
```

### 配置处理

```haskell
-- 配置类型
data Config = Config {
    port :: Int,
    host :: String,
    debug :: Bool
} deriving Show

-- 配置验证
validatePort :: Int -> Maybe Int
validatePort p
    | p > 0 && p <= 65535 = Just p
    | otherwise = Nothing

validateHost :: String -> Maybe String
validateHost h
    | not (null h) = Just h
    | otherwise = Nothing

-- 使用函子处理配置
processConfig :: Config -> Maybe Config
processConfig (Config p h d) = 
    Config <$> validatePort p <*> validateHost h <*> pure d
```

### 数据处理

```haskell
-- 数据处理管道
data ProcessingStep a b = ProcessingStep {
    process :: a -> Maybe b,
    name :: String
}

-- 函子实例
instance Functor (ProcessingStep a) where
    fmap f (ProcessingStep p n) = ProcessingStep (fmap f . p) n

-- 数据处理示例
parseInt :: ProcessingStep String Int
parseInt = ProcessingStep readMaybe "parseInt"

validateRange :: Int -> Int -> ProcessingStep Int Int
validateRange min max = ProcessingStep validate "validateRange"
  where
    validate x
        | x >= min && x <= max = Just x
        | otherwise = Nothing

-- 使用函子组合
processData :: String -> Maybe Int
processData s = process (fmap (*2) parseInt) s
```

## 高级函子模式

### 双函子

```haskell
-- 双函子类型类
class Bifunctor p where
    bimap :: (a -> b) -> (c -> d) -> p a c -> p b d
    first :: (a -> b) -> p a c -> p b c
    second :: (b -> c) -> p a b -> p a c
    
    first f = bimap f id
    second = bimap id

-- Either双函子
instance Bifunctor Either where
    bimap f _ (Left a) = Left (f a)
    bimap _ g (Right b) = Right (g b)

-- 元组双函子
instance Bifunctor (,) where
    bimap f g (a, b) = (f a, g b)

-- 双函子应用
processEither :: Either String Int -> Either String String
processEither = second show

processTuple :: (String, Int) -> (String, String)
processTuple = bimap (++ "!") show
```

### 逆变函子

```haskell
-- 逆变函子类型类
class Contravariant f where
    contramap :: (b -> a) -> f a -> f b

-- 谓词函子
newtype Predicate a = Predicate { getPredicate :: a -> Bool }

instance Contravariant Predicate where
    contramap f (Predicate p) = Predicate (p . f)

-- 逆变函子应用
isPositive :: Predicate Int
isPositive = Predicate (> 0)

isPositiveString :: Predicate String
isPositiveString = contramap read isPositive
```

### 函子组合模式

```haskell
-- 函子组合器
newtype Compose f g a = Compose { getCompose :: f (g a) }

instance (Functor f, Functor g) => Functor (Compose f g) where
    fmap f (Compose fga) = Compose (fmap (fmap f) fga)

-- 函子组合应用
type MaybeList a = Compose Maybe [] a

exampleCompose :: MaybeList Int
exampleCompose = Compose (Just [1, 2, 3])

mappedCompose :: MaybeList String
mappedCompose = fmap show exampleCompose
```

## 性能优化

### 函子优化

```haskell
-- 优化的函子操作
optimizedFmap :: Functor f => (a -> b) -> f a -> f b
optimizedFmap f = fmap f

-- 批量操作
batchFmap :: Functor f => [a -> b] -> f a -> [f b]
batchFmap fs fa = map (`fmap` fa) fs

-- 条件映射
conditionalFmap :: Functor f => (a -> Bool) -> (a -> b) -> f a -> f a
conditionalFmap p f fa = fmap (\x -> if p x then f x else x) fa
```

### 函子缓存

```haskell
-- 带缓存的函子
newtype Cached f a = Cached { 
    getCached :: f a,
    cache :: Map String a
}

instance Functor f => Functor (Cached f) where
    fmap f (Cached fa cache) = Cached (fmap f fa) (fmap f cache)

-- 缓存操作
withCache :: Functor f => f a -> Cached f a
withCache fa = Cached fa Map.empty

getFromCache :: Ord k => k -> Cached f a -> Maybe a
getFromCache k (Cached _ cache) = Map.lookup k cache
```

## 总结

函子模式是函数式编程的基础抽象，它提供了一种在保持结构的同时映射数据的能力。通过严格的数学定义和Haskell的类型系统，函子确保了程序的正确性和可组合性。

### 关键要点

1. **数学基础**: 函子基于范畴论的映射概念
2. **类型安全**: Haskell的类型系统确保函子使用的正确性
3. **可组合性**: 函子可以组合使用，构建复杂的抽象
4. **实际应用**: 在错误处理、数据处理、配置管理等领域有广泛应用

### 进一步学习

- 范畴论基础
- 应用函子
- 单子
- 高级函子模式

---

**相关链接**：

- [应用函子模式](应用函子模式.md)
- [单子模式](单子模式.md)
- [类型系统](../04-Type-System/类型基础.md)
