# Rust 工作流模式多实现对比

## 1. Petri网与工作流建模

### Petri网基础结构
```rust
pub struct PetriNet<S, T> {
    places: HashMap<String, Place<S>>,
    transitions: HashMap<String, Transition<T>>,
    arcs: Vec<Arc>,
}

pub struct Place<S> {
    id: String,
    tokens: Vec<S>,
    capacity: Option<usize>,
}

pub struct Transition<T> {
    id: String,
    action: Box<dyn Fn(&[&dyn Any]) -> Result<T, String> + Send + Sync>,
    guard: Option<Box<dyn Fn() -> bool + Send + Sync>>,
}

pub enum Arc {
    Input(String, String, usize),   // place_id, transition_id, weight
    Output(String, String, usize),  // transition_id, place_id, weight
}
```

### 工作流与Petri网映射
```rust
pub struct WorkflowEngine<S, A, R> {
    petri_net: PetriNet<S, R>,
    activities: HashMap<String, Box<dyn Fn(A) -> R + Send + Sync>>,
}

impl<S, A, R> WorkflowEngine<S, A, R> 
where 
    S: Clone + Send + Sync + 'static,
    A: Send + Sync + 'static,
    R: Send + Sync + 'static,
{
    pub fn register_activity<F>(&mut self, id: &str, activity: F)
    where
        F: Fn(A) -> R + Send + Sync + 'static 
    {
        let activity_box = Box::new(activity);
        self.activities.insert(id.to_string(), activity_box);
        let transition = Transition::new(id.to_string(), move |inputs| {
            // 实现变迁逻辑
            // ...
        });
        self.petri_net.add_transition(transition);
    }
}
```

### 顺序模式与Petri网
```rust
pub struct SequenceWorkflow<T, R> {
    steps: Vec<Box<dyn Fn(T) -> R + Send + Sync>>,
}

impl<T, R> SequenceWorkflow<T, R>
where
    T: Clone + Send + 'static,
    R: Send + 'static,
{
    pub fn new() -> Self {
        Self { steps: Vec::new() }
    }
    pub fn add_step<F>(&mut self, step: F) -> &mut Self
    where
        F: Fn(T) -> R + Send + Sync + 'static,
    {
        self.steps.push(Box::new(step));
        self
    }
    pub fn execute(&self, input: T) -> Vec<R> {
        let mut results = Vec::new();
        let mut current = input;
        for step in &self.steps {
            let result = step(current.clone());
            results.push(result);
        }
        results
    }
}
```

---

（后续可继续补充并行拆分、同步、判别、合并等工作流模式的多实现代码） 