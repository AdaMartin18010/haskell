# 状态机模式 (State Machine Pattern)

## 概述

状态机模式是一种行为设计模式，它允许对象在其内部状态改变时改变其行为。状态机模式将状态转换逻辑封装在独立的状态对象中，使得状态转换更加清晰和可维护。

## 设计原则

- **状态封装**: 每个状态封装自己的行为
- **状态转换**: 明确定义状态之间的转换规则
- **单一职责**: 每个状态只负责自己的行为
- **开闭原则**: 易于添加新状态而不修改现有代码

## 模式结构

```text
Context
  ↓
State Interface
  ↓
Concrete States
  ↓
State Transitions
```

## Haskell实现

### 基础状态机

```haskell
import Control.Monad.State
import Data.Maybe

-- 状态类型
data TrafficLightState = Red | Yellow | Green deriving (Show, Eq)

-- 状态机上下文
data TrafficLight = TrafficLight
  { currentState :: TrafficLightState
  , timer :: Int
  , maxTimer :: Int
  } deriving (Show)

-- 状态行为类型
type StateAction = TrafficLight -> TrafficLight

-- 状态转换规则
nextState :: TrafficLightState -> TrafficLightState
nextState Red = Green
nextState Green = Yellow
nextState Yellow = Red

-- 状态行为
redState :: StateAction
redState light = light { timer = timer light + 1 }

yellowState :: StateAction
yellowState light = light { timer = timer light + 1 }

greenState :: StateAction
greenState light = light { timer = timer light + 1 }

-- 状态转换检查
shouldTransition :: TrafficLight -> Bool
shouldTransition light = timer light >= maxTimer light

-- 状态机步进
stepStateMachine :: TrafficLight -> TrafficLight
stepStateMachine light = 
  let updatedLight = case currentState light of
        Red -> redState light
        Yellow -> yellowState light
        Green -> greenState light
  in if shouldTransition updatedLight
     then updatedLight { 
       currentState = nextState (currentState light),
       timer = 0 
     }
     else updatedLight

-- 创建状态机
newTrafficLight :: TrafficLight
newTrafficLight = TrafficLight Red 0 10

-- 使用示例
main :: IO ()
main = do
  let light = newTrafficLight
  putStrLn $ "Initial state: " ++ show light
  
  let light1 = stepStateMachine light
  putStrLn $ "After 1 step: " ++ show light1
  
  let light2 = stepStateMachine light1
  putStrLn $ "After 2 steps: " ++ show light2
```

### 使用State Monad的状态机

```haskell
import Control.Monad.State
import Control.Monad.IO.Class

-- 状态机状态
data StateMachineState = StateMachineState
  { currentState :: String
  , data :: Int
  , history :: [String]
  } deriving (Show)

-- 状态机动作
data StateMachineAction = 
  Action1 | Action2 | Action3 deriving (Show)

-- 状态机Monad
type StateMachine = State StateMachineState

-- 状态转换规则
stateTransition :: String -> StateMachineAction -> Maybe String
stateTransition "Idle" Action1 = Just "Processing"
stateTransition "Processing" Action2 = Just "Completed"
stateTransition "Processing" Action3 = Just "Error"
stateTransition "Error" Action1 = Just "Idle"
stateTransition "Completed" Action1 = Just "Idle"
stateTransition _ _ = Nothing

-- 状态行为
stateBehavior :: String -> StateMachineAction -> StateMachine ()
stateBehavior "Idle" Action1 = do
  modify $ \s -> s { data = data s + 1 }
  modify $ \s -> s { history = "Started processing" : history s }

stateBehavior "Processing" Action2 = do
  modify $ \s -> s { data = data s * 2 }
  modify $ \s -> s { history = "Completed successfully" : history s }

stateBehavior "Processing" Action3 = do
  modify $ \s -> s { data = 0 }
  modify $ \s -> s { history = "Error occurred" : history s }

stateBehavior "Error" Action1 = do
  modify $ \s -> s { data = 0 }
  modify $ \s -> s { history = "Reset from error" : history s }

stateBehavior "Completed" Action1 = do
  modify $ \s -> s { data = 0 }
  modify $ \s -> s { history = "Reset after completion" : history s }

stateBehavior _ _ = return ()

-- 执行状态机动作
executeAction :: StateMachineAction -> StateMachine Bool
executeAction action = do
  state <- get
  case stateTransition (currentState state) action of
    Just newState -> do
      stateBehavior (currentState state) action
      put $ state { currentState = newState }
      return True
    Nothing -> return False

-- 创建状态机
newStateMachine :: StateMachineState
newStateMachine = StateMachineState "Idle" 0 []

-- 使用示例
demoStateMachine :: IO ()
demoStateMachine = do
  let initialState = newStateMachine
  let actions = [Action1, Action2, Action1]
  
  let finalState = execState (mapM executeAction actions) initialState
  putStrLn $ "Final state: " ++ show finalState
```

### 使用类型类的状态机

```haskell
import Control.Monad
import Data.Typeable

-- 状态机类型类
class (Show s, Eq s) => StateMachine s where
  initialState :: s
  nextStates :: s -> [s]
  isValidTransition :: s -> s -> Bool
  stateBehavior :: s -> s -> IO ()

-- 具体状态机实现
data OrderState = 
  Pending | Confirmed | Shipped | Delivered | Cancelled
  deriving (Show, Eq)

instance StateMachine OrderState where
  initialState = Pending
  
  nextStates Pending = [Confirmed, Cancelled]
  nextStates Confirmed = [Shipped, Cancelled]
  nextStates Shipped = [Delivered]
  nextStates Delivered = []
  nextStates Cancelled = []
  
  isValidTransition Pending Confirmed = True
  isValidTransition Pending Cancelled = True
  isValidTransition Confirmed Shipped = True
  isValidTransition Confirmed Cancelled = True
  isValidTransition Shipped Delivered = True
  isValidTransition _ _ = False
  
  stateBehavior from to = do
    putStrLn $ "Transitioning from " ++ show from ++ " to " ++ show to
    case (from, to) of
      (Pending, Confirmed) -> putStrLn "Order confirmed"
      (Confirmed, Shipped) -> putStrLn "Order shipped"
      (Shipped, Delivered) -> putStrLn "Order delivered"
      (_, Cancelled) -> putStrLn "Order cancelled"
      _ -> putStrLn "Invalid transition"

-- 状态机上下文
data OrderContext = OrderContext
  { orderId :: String
  , currentState :: OrderState
  , history :: [(OrderState, OrderState)]
  } deriving (Show)

-- 状态转换
transitionState :: OrderContext -> OrderState -> IO (Maybe OrderContext)
transitionState ctx newState = do
  if isValidTransition (currentState ctx) newState
    then do
      stateBehavior (currentState ctx) newState
      let newHistory = (currentState ctx, newState) : history ctx
      return $ Just $ ctx { 
        currentState = newState,
        history = newHistory
      }
    else return Nothing

-- 使用示例
demoOrderStateMachine :: IO ()
demoOrderStateMachine = do
  let order = OrderContext "ORD-001" Pending []
  
  putStrLn "Order state machine demo:"
  
  -- 确认订单
  maybeOrder1 <- transitionState order Confirmed
  case maybeOrder1 of
    Just order1 -> do
      putStrLn $ "Order state: " ++ show (currentState order1)
      
      -- 发货
      maybeOrder2 <- transitionState order1 Shipped
      case maybeOrder2 of
        Just order2 -> do
          putStrLn $ "Order state: " ++ show (currentState order2)
          
          -- 交付
          maybeOrder3 <- transitionState order2 Delivered
          case maybeOrder3 of
            Just order3 -> putStrLn $ "Order state: " ++ show (currentState order3)
            Nothing -> putStrLn "Invalid transition"
        Nothing -> putStrLn "Invalid transition"
    Nothing -> putStrLn "Invalid transition"
```

## Rust实现

### 基础状态机

```rust
use std::collections::HashMap;

// 状态枚举
#[derive(Debug, Clone, PartialEq)]
enum TrafficLightState {
    Red,
    Yellow,
    Green,
}

// 状态机上下文
#[derive(Debug)]
struct TrafficLight {
    current_state: TrafficLightState,
    timer: u32,
    max_timer: u32,
}

// 状态行为trait
trait StateBehavior {
    fn update(&self, light: &mut TrafficLight);
    fn should_transition(&self, light: &TrafficLight) -> bool;
    fn next_state(&self) -> TrafficLightState;
}

// 红灯状态
struct RedState;

impl StateBehavior for RedState {
    fn update(&self, light: &mut TrafficLight) {
        light.timer += 1;
    }
    
    fn should_transition(&self, light: &TrafficLight) -> bool {
        light.timer >= light.max_timer
    }
    
    fn next_state(&self) -> TrafficLightState {
        TrafficLightState::Green
    }
}

// 黄灯状态
struct YellowState;

impl StateBehavior for YellowState {
    fn update(&self, light: &mut TrafficLight) {
        light.timer += 1;
    }
    
    fn should_transition(&self, light: &TrafficLight) -> bool {
        light.timer >= light.max_timer
    }
    
    fn next_state(&self) -> TrafficLightState {
        TrafficLightState::Red
    }
}

// 绿灯状态
struct GreenState;

impl StateBehavior for GreenState {
    fn update(&self, light: &mut TrafficLight) {
        light.timer += 1;
    }
    
    fn should_transition(&self, light: &TrafficLight) -> bool {
        light.timer >= light.max_timer
    }
    
    fn next_state(&self) -> TrafficLightState {
        TrafficLightState::Yellow
    }
}

impl TrafficLight {
    fn new() -> Self {
        Self {
            current_state: TrafficLightState::Red,
            timer: 0,
            max_timer: 10,
        }
    }
    
    fn step(&mut self) {
        let behavior: Box<dyn StateBehavior> = match self.current_state {
            TrafficLightState::Red => Box::new(RedState),
            TrafficLightState::Yellow => Box::new(YellowState),
            TrafficLightState::Green => Box::new(GreenState),
        };
        
        behavior.update(self);
        
        if behavior.should_transition(self) {
            self.current_state = behavior.next_state();
            self.timer = 0;
        }
    }
}

// 使用示例
fn main() {
    let mut light = TrafficLight::new();
    println!("Initial state: {:?}", light);
    
    for i in 1..=15 {
        light.step();
        println!("Step {}: {:?}", i, light);
    }
}
```

### 使用枚举的状态机

```rust
use std::collections::HashMap;

// 状态机事件
#[derive(Debug, Clone)]
enum OrderEvent {
    Confirm,
    Ship,
    Deliver,
    Cancel,
}

// 订单状态
#[derive(Debug, Clone, PartialEq)]
enum OrderState {
    Pending,
    Confirmed,
    Shipped,
    Delivered,
    Cancelled,
}

// 状态机
struct OrderStateMachine {
    current_state: OrderState,
    order_id: String,
    history: Vec<(OrderState, OrderEvent)>,
}

impl OrderStateMachine {
    fn new(order_id: String) -> Self {
        Self {
            current_state: OrderState::Pending,
            order_id,
            history: Vec::new(),
        }
    }
    
    fn transition(&mut self, event: OrderEvent) -> Result<(), String> {
        let new_state = match (&self.current_state, &event) {
            (OrderState::Pending, OrderEvent::Confirm) => OrderState::Confirmed,
            (OrderState::Pending, OrderEvent::Cancel) => OrderState::Cancelled,
            (OrderState::Confirmed, OrderEvent::Ship) => OrderState::Shipped,
            (OrderState::Confirmed, OrderEvent::Cancel) => OrderState::Cancelled,
            (OrderState::Shipped, OrderEvent::Deliver) => OrderState::Delivered,
            _ => return Err(format!("Invalid transition: {:?} -> {:?}", self.current_state, event)),
        };
        
        self.history.push((self.current_state.clone(), event.clone()));
        self.current_state = new_state;
        
        // 执行状态行为
        self.execute_state_behavior(&event);
        
        Ok(())
    }
    
    fn execute_state_behavior(&self, event: &OrderEvent) {
        match event {
            OrderEvent::Confirm => println!("Order {} confirmed", self.order_id),
            OrderEvent::Ship => println!("Order {} shipped", self.order_id),
            OrderEvent::Deliver => println!("Order {} delivered", self.order_id),
            OrderEvent::Cancel => println!("Order {} cancelled", self.order_id),
        }
    }
    
    fn current_state(&self) -> &OrderState {
        &self.current_state
    }
    
    fn history(&self) -> &Vec<(OrderState, OrderEvent)> {
        &self.history
    }
}

// 使用示例
fn demo_order_state_machine() {
    let mut order = OrderStateMachine::new("ORD-001".to_string());
    
    println!("Order state machine demo:");
    println!("Initial state: {:?}", order.current_state());
    
    // 确认订单
    match order.transition(OrderEvent::Confirm) {
        Ok(_) => println!("State after confirm: {:?}", order.current_state()),
        Err(e) => println!("Error: {}", e),
    }
    
    // 发货
    match order.transition(OrderEvent::Ship) {
        Ok(_) => println!("State after ship: {:?}", order.current_state()),
        Err(e) => println!("Error: {}", e),
    }
    
    // 交付
    match order.transition(OrderEvent::Deliver) {
        Ok(_) => println!("State after deliver: {:?}", order.current_state()),
        Err(e) => println!("Error: {}", e),
    }
    
    println!("Final history: {:?}", order.history());
}
```

### 使用宏的状态机

```rust
use std::collections::HashMap;

// 状态机宏
macro_rules! state_machine {
    (
        $name:ident {
            $($state:ident),*
        }
        transitions {
            $($from:ident -> $event:ident -> $to:ident),*
        }
    ) => {
        #[derive(Debug, Clone, PartialEq)]
        enum $name {
            $($state),*
        }
        
        impl $name {
            fn transition(&self, event: &str) -> Option<Self> {
                match (self, event) {
                    $(
                        ($name::$from, $event) => Some($name::$to),
                    )*
                    _ => None,
                }
            }
        }
    };
}

// 定义订单状态机
state_machine! {
    OrderState {
        Pending,
        Confirmed,
        Shipped,
        Delivered,
        Cancelled
    }
    transitions {
        Pending -> "confirm" -> Confirmed,
        Pending -> "cancel" -> Cancelled,
        Confirmed -> "ship" -> Shipped,
        Confirmed -> "cancel" -> Cancelled,
        Shipped -> "deliver" -> Delivered
    }
}

// 状态机上下文
struct OrderContext {
    state: OrderState,
    order_id: String,
    data: HashMap<String, String>,
}

impl OrderContext {
    fn new(order_id: String) -> Self {
        Self {
            state: OrderState::Pending,
            order_id,
            data: HashMap::new(),
        }
    }
    
    fn transition(&mut self, event: &str) -> Result<(), String> {
        if let Some(new_state) = self.state.transition(event) {
            self.state = new_state;
            self.execute_behavior(event);
            Ok(())
        } else {
            Err(format!("Invalid transition: {:?} -> {}", self.state, event))
        }
    }
    
    fn execute_behavior(&self, event: &str) {
        match event {
            "confirm" => println!("Order {} confirmed", self.order_id),
            "ship" => println!("Order {} shipped", self.order_id),
            "deliver" => println!("Order {} delivered", self.order_id),
            "cancel" => println!("Order {} cancelled", self.order_id),
            _ => println!("Unknown event: {}", event),
        }
    }
    
    fn current_state(&self) -> &OrderState {
        &self.state
    }
}

// 使用示例
fn demo_macro_state_machine() {
    let mut order = OrderContext::new("ORD-001".to_string());
    
    println!("Macro-based state machine demo:");
    println!("Initial state: {:?}", order.current_state());
    
    // 执行状态转换
    let events = vec!["confirm", "ship", "deliver"];
    
    for event in events {
        match order.transition(event) {
            Ok(_) => println!("State after {}: {:?}", event, order.current_state()),
            Err(e) => println!("Error: {}", e),
        }
    }
}
```

## Lean实现

### 依赖类型状态机

```lean
-- 状态类型
inductive TrafficLightState
| Red
| Yellow
| Green
deriving Repr

-- 状态机上下文
structure TrafficLight where
  currentState : TrafficLightState
  timer : Nat
  maxTimer : Nat
  deriving Repr

-- 状态转换规则
def nextState : TrafficLightState → TrafficLightState
| TrafficLightState.Red => TrafficLightState.Green
| TrafficLightState.Green => TrafficLightState.Yellow
| TrafficLightState.Yellow => TrafficLightState.Red

-- 状态行为
def updateState : TrafficLightState → TrafficLight → TrafficLight
| TrafficLightState.Red, light => { light with timer := light.timer + 1 }
| TrafficLightState.Yellow, light => { light with timer := light.timer + 1 }
| TrafficLightState.Green, light => { light with timer := light.timer + 1 }

-- 状态转换检查
def shouldTransition : TrafficLight → Bool
| light => light.timer >= light.maxTimer

-- 状态机步进
def stepStateMachine : TrafficLight → TrafficLight
| light => 
  let updatedLight := updateState light.currentState light
  if shouldTransition updatedLight then
    { updatedLight with 
      currentState := nextState light.currentState,
      timer := 0 }
  else
    updatedLight

-- 创建状态机
def newTrafficLight : TrafficLight :=
  TrafficLight.mk TrafficLightState.Red 0 10

-- 使用示例
def demo : IO Unit := do
  let light := newTrafficLight
  IO.println s!"Initial state: {light}"
  
  let light1 := stepStateMachine light
  IO.println s!"After 1 step: {light1}"
  
  let light2 := stepStateMachine light1
  IO.println s!"After 2 steps: {light2}"
```

### 形式化验证的状态机

```lean
-- 状态机规格
structure StateMachineSpec (α : Type) where
  initialState : α
  validTransitions : α → α → Prop
  invariant : α → Prop
  postcondition : α → α → Prop
  deriving Repr

-- 验证状态机
class ValidatedStateMachine (α : Type) (spec : StateMachineSpec α) where
  transition : α → α
  preservesInvariant : ∀ (state : α),
    spec.invariant state → spec.invariant (transition state)
  satisfiesPostcondition : ∀ (state : α),
    spec.invariant state → spec.postcondition state (transition state)
  validTransition : ∀ (state : α),
    spec.invariant state → spec.validTransitions state (transition state)

-- 具体状态机规格
def trafficLightSpec : StateMachineSpec TrafficLight :=
  StateMachineSpec.mk 
    newTrafficLight
    (λ s1 s2 => s2.currentState = nextState s1.currentState ∨ s2.currentState = s1.currentState)
    (λ light => light.timer <= light.maxTimer)
    (λ s1 s2 => s2.timer = s1.timer + 1 ∨ (s2.timer = 0 ∧ s2.currentState ≠ s1.currentState))

-- 验证状态机实现
instance : ValidatedStateMachine TrafficLight trafficLightSpec where
  transition light := stepStateMachine light
  preservesInvariant light h := by
    simp [trafficLightSpec, stepStateMachine, updateState]
    split
    · simp [TrafficLight.maxTimer]
    · simp [TrafficLight.maxTimer]
  satisfiesPostcondition light h := by
    simp [trafficLightSpec, stepStateMachine, updateState]
    split
    · simp [TrafficLight.timer]
    · simp [TrafficLight.timer, TrafficLight.currentState]
  validTransition light h := by
    simp [trafficLightSpec, stepStateMachine, updateState]
    split
    · simp [nextState]
    · simp [nextState]

-- 证明：状态机不会卡死
theorem state_machine_progress 
  (light : TrafficLight) 
  (h : trafficLightSpec.invariant light) :
  ∃ (steps : Nat), 
    let finalState := iterate ValidatedStateMachine.transition steps light
    finalState.timer = 0 := by
  -- 证明存在有限步数使得timer归零
  exists 10
  simp [iterate, ValidatedStateMachine.transition, stepStateMachine]

-- 使用示例
def demoValidated : IO Unit := do
  let light := newTrafficLight
  
  if trafficLightSpec.invariant light then
    let newLight := ValidatedStateMachine.transition light
    IO.println s!"Transitioned to: {newLight}"
    IO.println "Invariant preserved!"
  else
    IO.println "Invalid initial state"
```

### 函数式状态机

```lean
-- 函数式状态机
structure FunctionalStateMachine (α β : Type) where
  transition : α → β → α
  initialState : α
  deriving Repr

-- 状态机组合
def composeStateMachines {α β γ : Type} 
  (f : FunctionalStateMachine β γ) 
  (g : FunctionalStateMachine α β) : 
  FunctionalStateMachine α γ :=
  FunctionalStateMachine.mk 
    (λ state event => g.transition state (f.transition g.initialState event))
    g.initialState

-- 身份状态机
def idStateMachine {α : Type} : FunctionalStateMachine α α :=
  FunctionalStateMachine.mk (λ state _ => state) (default : α)

-- 使用示例
def demoFunctional : IO Unit := do
  -- 创建状态机
  let sm := FunctionalStateMachine.mk 
    (λ light _ => stepStateMachine light)
    newTrafficLight
  
  let light1 := sm.transition sm.initialState ()
  let light2 := sm.transition light1 ()
  
  IO.println s!"Functional state machine result: {light2}"
```

## 模式对比分析

### 语言特性对比

| 特性 | Haskell | Rust | Lean |
|------|---------|------|------|
| 类型安全 | 强类型系统 | 所有权系统 | 依赖类型 |
| 状态管理 | State Monad | 枚举/结构体 | 依赖类型 |
| 内存管理 | GC | 所有权 | GC |
| 形式验证 | QuickCheck | 有限验证 | 完整证明 |
| 性能 | 惰性求值 | 零成本抽象 | 编译时优化 |

### 实现复杂度

1. **Haskell**: 中等复杂度，State Monad提供优雅的状态管理
2. **Rust**: 较高复杂度，需要处理所有权和生命周期
3. **Lean**: 最高复杂度，但提供最强的形式化保证

### 适用场景

- **Haskell**: 函数式编程，复杂状态逻辑，原型开发
- **Rust**: 系统编程，高性能应用，内存安全要求高
- **Lean**: 形式化验证，数学证明，关键系统

## 最佳实践

### 1. 状态设计

- 明确定义所有可能的状态
- 避免状态爆炸，合理抽象
- 保持状态转换的简单性

### 2. 错误处理

- Haskell: 使用Maybe/Either类型处理无效转换
- Rust: 使用Result类型和错误传播
- Lean: 使用Option类型和证明

### 3. 性能优化

- Haskell: 使用严格性注解，避免惰性求值开销
- Rust: 使用零拷贝，内联优化
- Lean: 编译时优化，依赖类型消除

## 总结

状态机模式在不同语言中展现出不同的实现特点：

- **Haskell** 通过State Monad提供了优雅的状态管理和强大的类型安全
- **Rust** 通过枚举和trait确保了内存安全和高效的性能
- **Lean** 通过依赖类型系统提供了最强的形式化保证和验证能力

选择哪种实现方式取决于具体的应用场景、性能要求和安全性需求。
