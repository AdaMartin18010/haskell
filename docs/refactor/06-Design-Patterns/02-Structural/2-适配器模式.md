# 适配器模式 (Adapter Pattern)

## 概述

适配器模式是一种结构型设计模式，它允许不兼容的接口能够一起工作。适配器模式通过包装一个已存在的类，提供一个不同的接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。

## 设计原则

- **单一职责原则**: 适配器只负责接口转换
- **开闭原则**: 对扩展开放，对修改关闭
- **依赖倒置原则**: 依赖抽象而不是具体实现

## 模式结构

```text
Client
  ↓
Target (目标接口)
  ↓
Adapter (适配器)
  ↓
Adaptee (被适配者)
```

## Haskell实现

### 基础适配器模式

```haskell
-- 目标接口
class Target a where
  request :: a -> String

-- 被适配的类
data Adaptee = Adaptee
  { adapteeData :: String
  } deriving Show

-- 被适配者的特定方法
specificRequest :: Adaptee -> String
specificRequest adaptee = "Adaptee: " ++ adapteeData adaptee

-- 适配器
data Adapter = Adapter
  { adaptee :: Adaptee
  } deriving Show

-- 适配器实现目标接口
instance Target Adapter where
  request adapter = "Adapter: " ++ specificRequest (adaptee adapter)

-- 使用示例
main :: IO ()
main = do
  let adaptee = Adaptee "Hello World"
  let adapter = Adapter adaptee
  putStrLn $ request adapter
```

### 使用类型类的适配器

```haskell
-- 目标接口
class TargetInterface a where
  processData :: a -> [Int] -> [Int]
  validateInput :: a -> [Int] -> Bool

-- 被适配的第三方库接口
class ThirdPartyLibrary a where
  transform :: a -> String -> String
  check :: a -> String -> Bool

-- 第三方库实现
data ThirdPartyImpl = ThirdPartyImpl deriving Show

instance ThirdPartyLibrary ThirdPartyImpl where
  transform _ input = "Processed: " ++ input
  check _ input = length input > 0

-- 适配器
data LibraryAdapter = LibraryAdapter
  { thirdParty :: ThirdPartyImpl
  } deriving Show

-- 数据转换函数
stringToInts :: String -> [Int]
stringToInts = map (read . (:[])) . filter (/= ' ')

intsToString :: [Int] -> String
intsToString = concatMap show

instance TargetInterface LibraryAdapter where
  processData adapter ints = 
    let str = intsToString ints
        processed = transform (thirdParty adapter) str
    in stringToInts processed
  
  validateInput adapter ints = 
    let str = intsToString ints
    in check (thirdParty adapter) str

-- 使用示例
demo :: IO ()
demo = do
  let adapter = LibraryAdapter ThirdPartyImpl
  let input = [1, 2, 3, 4, 5]
  
  if validateInput adapter input
    then do
      let result = processData adapter input
      putStrLn $ "Processed: " ++ show result
    else putStrLn "Invalid input"
```

### 函数式适配器

```haskell
-- 高阶函数适配器
type AdapterFunction a b = a -> b

-- 函数适配器
newtype FunctionAdapter from to = FunctionAdapter
  { adapt :: from -> to
  }

-- 组合适配器
composeAdapters :: FunctionAdapter b c -> FunctionAdapter a b -> FunctionAdapter a c
composeAdapters (FunctionAdapter f) (FunctionAdapter g) = FunctionAdapter (f . g)

-- 使用示例
demoFunctional :: IO ()
demoFunctional = do
  -- 原始函数
  let oldFunction :: String -> Int
      oldFunction = length
  
  -- 新接口期望的函数
  let newInterface :: [Char] -> String
      newInterface = id
  
  -- 创建适配器
  let adapter1 = FunctionAdapter oldFunction
  let adapter2 = FunctionAdapter newInterface
  let combined = composeAdapters adapter1 adapter2
  
  let result = adapt combined "Hello"
  putStrLn $ "Result: " ++ show result
```

## Rust实现

### 通用适配器模式

```rust
// 目标特征
trait Target {
    fn request(&self) -> String;
}

// 被适配的类
struct Adaptee {
    data: String,
}

impl Adaptee {
    fn specific_request(&self) -> String {
        format!("Adaptee: {}", self.data)
    }
}

// 适配器
struct Adapter {
    adaptee: Adaptee,
}

impl Adapter {
    fn new(data: String) -> Self {
        Self {
            adaptee: Adaptee { data },
        }
    }
}

impl Target for Adapter {
    fn request(&self) -> String {
        format!("Adapter: {}", self.adaptee.specific_request())
    }
}

// 使用示例
fn main() {
    let adapter = Adapter::new("Hello World".to_string());
    println!("{}", adapter.request());
}
```

### 泛型适配器

```rust
use std::fmt::Display;

// 目标特征
trait DataProcessor<T> {
    fn process(&self, data: T) -> String;
    fn validate(&self, data: &T) -> bool;
}

// 被适配的第三方库
trait ThirdPartyProcessor {
    fn transform(&self, input: &str) -> String;
    fn check(&self, input: &str) -> bool;
}

struct ThirdPartyImpl;

impl ThirdPartyProcessor for ThirdPartyImpl {
    fn transform(&self, input: &str) -> String {
        format!("Processed: {}", input)
    }
    
    fn check(&self, input: &str) -> bool {
        !input.is_empty()
    }
}

// 泛型适配器
struct GenericAdapter<P> {
    processor: P,
}

impl<P: ThirdPartyProcessor> GenericAdapter<P> {
    fn new(processor: P) -> Self {
        Self { processor }
    }
}

impl<P: ThirdPartyProcessor> DataProcessor<Vec<i32>> for GenericAdapter<P> {
    fn process(&self, data: Vec<i32>) -> String {
        let input: String = data.iter().map(|x| x.to_string()).collect();
        self.processor.transform(&input)
    }
    
    fn validate(&self, data: &Vec<i32>) -> bool {
        let input: String = data.iter().map(|x| x.to_string()).collect();
        self.processor.check(&input)
    }
}

// 使用示例
fn demo_generic() {
    let processor = ThirdPartyImpl;
    let adapter = GenericAdapter::new(processor);
    
    let data = vec![1, 2, 3, 4, 5];
    
    if adapter.validate(&data) {
        let result = adapter.process(data);
        println!("{}", result);
    }
}
```

### 异步适配器

```rust
use tokio::time::{sleep, Duration};
use std::future::Future;
use std::pin::Pin;

// 异步目标特征
#[async_trait::async_trait]
trait AsyncTarget {
    async fn async_request(&self) -> String;
    async fn async_process(&self, data: Vec<i32>) -> Vec<i32>;
}

// 同步被适配者
struct SyncAdaptee {
    data: String,
}

impl SyncAdaptee {
    fn sync_request(&self) -> String {
        format!("Sync: {}", self.data)
    }
    
    fn sync_process(&self, data: Vec<i32>) -> Vec<i32> {
        data.into_iter().map(|x| x * 2).collect()
    }
}

// 异步适配器
struct AsyncAdapter {
    adaptee: SyncAdaptee,
}

impl AsyncAdapter {
    fn new(data: String) -> Self {
        Self {
            adaptee: SyncAdaptee { data },
        }
    }
}

#[async_trait::async_trait]
impl AsyncTarget for AsyncAdapter {
    async fn async_request(&self) -> String {
        // 模拟异步操作
        sleep(Duration::from_millis(100)).await;
        format!("Async: {}", self.adaptee.sync_request())
    }
    
    async fn async_process(&self, data: Vec<i32>) -> Vec<i32> {
        // 模拟异步处理
        sleep(Duration::from_millis(50)).await;
        self.adaptee.sync_process(data)
    }
}

// 使用示例
#[tokio::main]
async fn demo_async() {
    let adapter = AsyncAdapter::new("Hello World".to_string());
    
    let result = adapter.async_request().await;
    println!("{}", result);
    
    let data = vec![1, 2, 3, 4, 5];
    let processed = adapter.async_process(data).await;
    println!("Processed: {:?}", processed);
}
```

## Lean实现

### 依赖类型适配器

```lean
-- 目标接口
class Target (α : Type) where
  request : α → String
  process : α → List Nat → List Nat

-- 被适配的类型
structure Adaptee where
  data : String
  deriving Repr

-- 被适配者的方法
def Adaptee.specificRequest (adaptee : Adaptee) : String :=
  s!"Adaptee: {adaptee.data}"

def Adaptee.specificProcess (adaptee : Adaptee) (nums : List Nat) : List Nat :=
  nums.map (· * 2)

-- 适配器
structure Adapter where
  adaptee : Adaptee
  deriving Repr

-- 适配器实现目标接口
instance : Target Adapter where
  request adapter := s!"Adapter: {adapter.adaptee.specificRequest}"
  process adapter nums := adapter.adaptee.specificProcess nums

-- 使用示例
def demo : IO Unit := do
  let adaptee := Adaptee.mk "Hello World"
  let adapter := Adapter.mk adaptee
  
  IO.println (Target.request adapter)
  IO.println s!"Processed: {Target.process adapter [1, 2, 3, 4, 5]}"
```

### 形式化验证的适配器

```lean
-- 适配器规格
structure AdapterSpec where
  inputType : Type
  outputType : Type
  invariant : inputType → Prop
  postcondition : inputType → outputType → Prop
  deriving Repr

-- 验证适配器
class ValidatedAdapter (α : Type) (spec : AdapterSpec) where
  adapt : α → spec.inputType → spec.outputType
  preservesInvariant : ∀ (adapter : α) (input : spec.inputType), 
    spec.invariant input → spec.invariant input
  satisfiesPostcondition : ∀ (adapter : α) (input : spec.inputType),
    spec.invariant input → spec.postcondition input (adapt adapter input)

-- 具体适配器实现
structure ValidatedStringAdapter where
  deriving Repr

-- 字符串适配器规格
def stringAdapterSpec : AdapterSpec :=
  AdapterSpec.mk String String (λ s => s.length > 0) (λ input output => output.length > input.length)

instance : ValidatedAdapter ValidatedStringAdapter stringAdapterSpec where
  adapt _ input := s!"Processed: {input}"
  preservesInvariant _ input h := h
  satisfiesPostcondition _ input h := by
    simp [stringAdapterSpec, adapt]
    have : input.length > 0 := h
    have : (s!"Processed: {input}").length > input.length := by
      simp [String.length]
      exact Nat.add_lt_add_left (by simp) input.length
    exact this

-- 证明：适配器保持不变量
theorem adapter_preserves_invariant 
  (adapter : ValidatedStringAdapter) 
  (input : String) 
  (h : stringAdapterSpec.invariant input) :
  stringAdapterSpec.invariant input :=
  ValidatedAdapter.preservesInvariant adapter input h

-- 使用示例
def demoValidated : IO Unit := do
  let adapter := ValidatedStringAdapter.mk
  let input := "Hello"
  
  if stringAdapterSpec.invariant input then
    let output := ValidatedAdapter.adapt adapter input
    IO.println s!"Input: {input}"
    IO.println s!"Output: {output}"
    IO.println "Postcondition satisfied!"
  else
    IO.println "Invalid input"
```

### 函数式适配器1

```lean
-- 函数适配器
structure FunctionAdapter (α β : Type) where
  adapt : α → β
  deriving Repr

-- 适配器组合
def composeAdapters {α β γ : Type} 
  (f : FunctionAdapter β γ) 
  (g : FunctionAdapter α β) : 
  FunctionAdapter α γ :=
  FunctionAdapter.mk (f.adapt ∘ g.adapt)

-- 身份适配器
def idAdapter {α : Type} : FunctionAdapter α α :=
  FunctionAdapter.mk id

-- 使用示例
def demoFunctional : IO Unit := do
  -- 原始函数：字符串长度
  let lengthAdapter := FunctionAdapter.mk String.length
  
  -- 新接口：字符列表长度
  let charListAdapter := FunctionAdapter.mk String.toList
  
  -- 组合适配器
  let combined := composeAdapters lengthAdapter charListAdapter
  
  let input := "Hello"
  let result := combined.adapt input
  
  IO.println s!"Input: {input}"
  IO.println s!"Result: {result}"
```

## 模式对比分析

### 语言特性对比

| 特性 | Haskell | Rust | Lean |
|------|---------|------|------|
| 类型安全 | 强类型系统 | 所有权系统 | 依赖类型 |
| 抽象能力 | 类型类 | 特征 | 类型类 |
| 泛型支持 | 类型参数 | 泛型 | 依赖类型 |
| 异步支持 | IO Monad | async/await | 有限支持 |
| 形式验证 | QuickCheck | 有限验证 | 完整证明 |

### 实现复杂度

1. **Haskell**: 中等复杂度，类型类提供优雅的抽象
2. **Rust**: 较高复杂度，需要处理所有权和生命周期
3. **Lean**: 最高复杂度，但提供最强的形式化保证

### 适用场景

- **Haskell**: 函数式编程，数学计算，接口转换
- **Rust**: 系统编程，高性能应用，内存安全要求高
- **Lean**: 形式化验证，数学证明，关键系统

## 最佳实践

### 1. 接口设计

- 保持目标接口简洁明确
- 避免过度适配
- 考虑向后兼容性

### 2. 性能优化

- Haskell: 惰性求值，避免不必要的计算
- Rust: 零拷贝，内联优化
- Lean: 编译时优化，依赖类型消除

### 3. 错误处理

- Haskell: 使用Maybe/Either类型
- Rust: 使用Result类型
- Lean: 使用Option类型和证明

## 总结

适配器模式在不同语言中展现出不同的实现特点：

- **Haskell** 通过类型类提供了优雅的接口转换和强大的类型安全
- **Rust** 通过所有权系统确保了内存安全和高效的性能
- **Lean** 通过依赖类型系统提供了最强的形式化保证和验证能力

选择哪种实现方式取决于具体的应用场景、性能要求和安全性需求。
