# Rust 并行模式多实现对比

## 1. 数据并行模式（Data Parallelism）

### 异步实现

```rust
use std::thread;
use futures::future::join_all;

#[tokio::main]
async fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let chunk_size = data.len() / 4; // 将数据分成4块
    let mut handles = vec![];
    for chunk in data.chunks(chunk_size) {
        let chunk = chunk.to_vec();
        let handle = tokio::spawn(async move {
            let sum: i32 = chunk.iter().sum();
            println!("Sum of chunk: {}", sum);
        });
        handles.push(handle);
    }
    join_all(handles).await;
}
```

### 多线程实现

```rust
use std::thread;

fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let chunk_size = data.len() / 4; // 将数据分成4块
    let mut handles = vec![];
    for chunk in data.chunks(chunk_size) {
        let handle = thread::spawn(move || {
            let sum: i32 = chunk.iter().sum();
            println!("Sum of chunk: {}", sum);
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 2. 任务并行模式（Task Parallelism）

### 异步实现

```rust
use tokio::task;

#[tokio::main]
async fn main() {
    let mut handles = vec![];
    for i in 0..10 {
        let handle = task::spawn(async move {
            println!("Task {} is running", i);
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 多线程实现

```rust
use std::thread;

fn task(id: usize) {
    println!("Task {} is running", id);
}

fn main() {
    let mut handles = vec![];
    for i in 0..10 {
        let handle = thread::spawn(move || {
            task(i);
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

## 3. 流水线并行模式（Pipeline Parallelism）

### 异步实现

```rust
use tokio::sync::mpsc;

async fn stage_one(data: Vec<i32>) -> Vec<i32> {
    data.into_iter().map(|x| x + 1).collect()
}

async fn stage_two(data: Vec<i32>) -> Vec<i32> {
    data.into_iter().map(|x| x * 2).collect()
}

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);
    let data = vec![1, 2, 3, 4, 5];
    tokio::spawn(async move {
        let result = stage_one(data).await;
        tx.send(result).await.unwrap();
    });
    let result = rx.recv().await.unwrap();
    let final_result = stage_two(result).await;
    println!("Final Result: {:?}", final_result);
}
```

### 多线程实现

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn stage_one(data: Vec<i32>) -> Vec<i32> {
    data.into_iter().map(|x| x + 1).collect()
}

fn stage_two(data: Vec<i32>) -> Vec<i32> {
    data.into_iter().map(|x| x * 2).collect()
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let data = Arc::new(Mutex::new(data));
    let data_clone = Arc::clone(&data);
    let handle_one = thread::spawn(move || {
        let data = data_clone.lock().unwrap();
        stage_one(data.clone())
    });
    let data_clone = Arc::clone(&data);
    let handle_two = thread::spawn(move || {
        let data = data_clone.lock().unwrap();
        stage_two(data.clone())
    });
    let result_one = handle_one.join().unwrap();
    let result_two = handle_two.join().unwrap();
    println!("Stage One Result: {:?}", result_one);
    println!("Stage Two Result: {:?}", result_two);
}
```

---

（后续可继续补充工作分解、工作窃取、主从、分而治之等模式的多实现代码）

# Haskell 典型实现片段

## 高阶函数与map

```haskell
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
```

## 递归与分治

```haskell
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

---

（可按需在各并行模式下补充更细致的Haskell实现）
