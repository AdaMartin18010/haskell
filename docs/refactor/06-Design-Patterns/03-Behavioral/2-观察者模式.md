# 观察者模式 (Observer Pattern)

## 概述

观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并自动更新。

## 设计原则

- **开闭原则**: 对扩展开放，对修改关闭
- **单一职责原则**: 主题和观察者各自负责自己的职责
- **依赖倒置原则**: 依赖抽象而不是具体实现

## 模式结构

```
Subject (主题)
  ↓
Observer (观察者接口)
  ↓
ConcreteObserver (具体观察者)
```

## Haskell实现

### 基础观察者模式

```haskell
-- 观察者类型类
class Observer a where
  update :: a -> String -> IO ()

-- 主题类型类
class Subject a where
  attach :: a -> Observer b => b -> IO ()
  detach :: a -> Observer b => b -> IO ()
  notify :: a -> String -> IO ()

-- 具体观察者
data ConcreteObserver = ConcreteObserver
  { observerName :: String
  } deriving Show

instance Observer ConcreteObserver where
  update observer message = 
    putStrLn $ observerName observer ++ " received: " ++ message

-- 主题实现
data SubjectImpl = SubjectImpl
  { observers :: [SomeObserver]
  } deriving Show

-- 观察者包装器
data SomeObserver where
  SomeObserver :: Observer o => o -> SomeObserver

-- 主题实现
instance Subject SubjectImpl where
  attach subject observer = do
    let newObservers = SomeObserver observer : observers subject
    return $ subject { observers = newObservers }
  
  detach subject observer = do
    let filteredObservers = filter (not . isObserver observer) (observers subject)
    return $ subject { observers = filteredObservers }
  
  notify subject message = do
    mapM_ (\(SomeObserver obs) -> update obs message) (observers subject)

-- 辅助函数
isObserver :: Observer o => o -> SomeObserver -> Bool
isObserver _ (SomeObserver _) = True -- 简化实现

-- 使用示例
main :: IO ()
main = do
  let subject = SubjectImpl []
  let observer1 = ConcreteObserver "Observer1"
  let observer2 = ConcreteObserver "Observer2"
  
  -- 添加观察者
  subject' <- attach subject observer1
  subject'' <- attach subject' observer2
  
  -- 通知观察者
  notify subject'' "Hello World!"
```

### 使用IORef的观察者模式

```haskell
import Data.IORef
import Control.Monad

-- 观察者类型
type Observer = String -> IO ()

-- 主题类型
data Subject = Subject
  { observers :: IORef [Observer]
  }

-- 创建主题
newSubject :: IO Subject
newSubject = do
  ref <- newIORef []
  return $ Subject ref

-- 添加观察者
addObserver :: Subject -> Observer -> IO ()
addObserver subject observer = do
  modifyIORef (observers subject) (observer :)

-- 移除观察者
removeObserver :: Subject -> Observer -> IO ()
removeObserver subject observer = do
  modifyIORef (observers subject) (filter (/= observer))

-- 通知所有观察者
notifyObservers :: Subject -> String -> IO ()
notifyObservers subject message = do
  obs <- readIORef (observers subject)
  mapM_ ($ message) obs

-- 具体观察者
createObserver :: String -> Observer
createObserver name message = 
  putStrLn $ name ++ " received: " ++ message

-- 使用示例
demo :: IO ()
demo = do
  subject <- newSubject
  
  -- 添加观察者
  let observer1 = createObserver "Observer1"
  let observer2 = createObserver "Observer2"
  
  addObserver subject observer1
  addObserver subject observer2
  
  -- 发送通知
  notifyObservers subject "Hello from Subject!"
  
  -- 移除观察者
  removeObserver subject observer1
  notifyObservers subject "Observer1 removed!"
```

### 使用STM的并发观察者

```haskell
import Control.Concurrent.STM
import Control.Monad

-- 观察者类型
type Observer = String -> IO ()

-- 主题类型
data STMSubject = STMSubject
  { stmObservers :: TVar [Observer]
  }

-- 创建主题
newSTMSubject :: IO STMSubject
newSTMSubject = do
  ref <- newTVarIO []
  return $ STMSubject ref

-- 添加观察者
addSTMObserver :: STMSubject -> Observer -> IO ()
addSTMObserver subject observer = 
  atomically $ modifyTVar (stmObservers subject) (observer :)

-- 通知观察者
notifySTMObservers :: STMSubject -> String -> IO ()
notifySTMObservers subject message = do
  obs <- atomically $ readTVar (stmObservers subject)
  mapM_ ($ message) obs

-- 并发安全的观察者
concurrentObserver :: String -> Observer
concurrentObserver name message = do
  threadDelay 1000 -- 模拟处理时间
  putStrLn $ name ++ " (concurrent) received: " ++ message

-- 使用示例
demoConcurrent :: IO ()
demoConcurrent = do
  subject <- newSTMSubject
  
  -- 添加多个观察者
  mapM_ (addSTMObserver subject) 
    [ concurrentObserver "Observer1"
    , concurrentObserver "Observer2"
    , concurrentObserver "Observer3"
    ]
  
  -- 并发通知
  replicateM_ 3 $ notifySTMObservers subject "Concurrent message!"
```

## Rust实现

### 基础观察者模式

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// 观察者特征
trait Observer: Send + Sync {
    fn update(&self, message: &str);
}

// 主题特征
trait Subject {
    fn attach(&mut self, observer: Arc<dyn Observer>);
    fn detach(&mut self, observer_id: &str);
    fn notify(&self, message: &str);
}

// 具体观察者
struct ConcreteObserver {
    name: String,
}

impl ConcreteObserver {
    fn new(name: String) -> Self {
        Self { name }
    }
}

impl Observer for ConcreteObserver {
    fn update(&self, message: &str) {
        println!("{} received: {}", self.name, message);
    }
}

// 主题实现
struct SubjectImpl {
    observers: Arc<Mutex<HashMap<String, Arc<dyn Observer>>>>,
}

impl SubjectImpl {
    fn new() -> Self {
        Self {
            observers: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

impl Subject for SubjectImpl {
    fn attach(&mut self, observer: Arc<dyn Observer>) {
        let name = format!("observer_{}", std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos());
        
        if let Ok(mut observers) = self.observers.lock() {
            observers.insert(name, observer);
        }
    }
    
    fn detach(&mut self, observer_id: &str) {
        if let Ok(mut observers) = self.observers.lock() {
            observers.remove(observer_id);
        }
    }
    
    fn notify(&self, message: &str) {
        if let Ok(observers) = self.observers.lock() {
            for observer in observers.values() {
                observer.update(message);
            }
        }
    }
}

// 使用示例
fn main() {
    let mut subject = SubjectImpl::new();
    
    let observer1 = Arc::new(ConcreteObserver::new("Observer1".to_string()));
    let observer2 = Arc::new(ConcreteObserver::new("Observer2".to_string()));
    
    subject.attach(observer1);
    subject.attach(observer2);
    
    subject.notify("Hello World!");
}
```

### 异步观察者模式

```rust
use tokio::sync::broadcast;
use std::sync::Arc;

// 异步观察者特征
#[async_trait::async_trait]
trait AsyncObserver: Send + Sync {
    async fn update(&self, message: String);
}

// 异步主题
struct AsyncSubject {
    tx: broadcast::Sender<String>,
}

impl AsyncSubject {
    fn new() -> Self {
        let (tx, _) = broadcast::channel(100);
        Self { tx }
    }
    
    async fn notify(&self, message: String) {
        let _ = self.tx.send(message);
    }
}

// 异步观察者实现
struct AsyncConcreteObserver {
    name: String,
    rx: broadcast::Receiver<String>,
}

impl AsyncConcreteObserver {
    fn new(name: String, rx: broadcast::Receiver<String>) -> Self {
        Self { name, rx }
    }
    
    async fn listen(&mut self) {
        while let Ok(message) = self.rx.recv().await {
            println!("{} received: {}", self.name, message);
        }
    }
}

#[async_trait::async_trait]
impl AsyncObserver for AsyncConcreteObserver {
    async fn update(&self, message: String) {
        println!("{} received: {}", self.name, message);
    }
}

// 使用示例
#[tokio::main]
async fn demo_async() {
    let subject = Arc::new(AsyncSubject::new());
    
    // 创建观察者
    let mut observer1 = AsyncConcreteObserver::new(
        "Observer1".to_string(),
        subject.tx.subscribe()
    );
    
    let mut observer2 = AsyncConcreteObserver::new(
        "Observer2".to_string(),
        subject.tx.subscribe()
    );
    
    // 启动观察者监听
    let handle1 = tokio::spawn(async move {
        observer1.listen().await;
    });
    
    let handle2 = tokio::spawn(async move {
        observer2.listen().await;
    });
    
    // 发送通知
    for i in 0..5 {
        subject.notify(format!("Message {}", i)).await;
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    }
    
    // 等待观察者完成
    let _ = tokio::join!(handle1, handle2);
}
```

### 泛型观察者模式

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// 泛型观察者特征
trait GenericObserver<T>: Send + Sync {
    fn update(&self, data: &T);
}

// 泛型主题
struct GenericSubject<T> {
    observers: Arc<Mutex<HashMap<String, Arc<dyn GenericObserver<T> + Send + Sync>>>>,
}

impl<T: Send + Sync + 'static> GenericSubject<T> {
    fn new() -> Self {
        Self {
            observers: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn attach(&self, id: String, observer: Arc<dyn GenericObserver<T> + Send + Sync>) {
        if let Ok(mut observers) = self.observers.lock() {
            observers.insert(id, observer);
        }
    }
    
    fn detach(&self, id: &str) {
        if let Ok(mut observers) = self.observers.lock() {
            observers.remove(id);
        }
    }
    
    fn notify(&self, data: &T) {
        if let Ok(observers) = self.observers.lock() {
            for observer in observers.values() {
                observer.update(data);
            }
        }
    }
}

// 具体观察者实现
struct DataObserver {
    name: String,
}

impl DataObserver {
    fn new(name: String) -> Self {
        Self { name }
    }
}

impl GenericObserver<i32> for DataObserver {
    fn update(&self, data: &i32) {
        println!("{} received number: {}", self.name, data);
    }
}

impl GenericObserver<String> for DataObserver {
    fn update(&self, data: &String) {
        println!("{} received string: {}", self.name, data);
    }
}

// 使用示例
fn demo_generic() {
    // 数字主题
    let number_subject = Arc::new(GenericSubject::<i32>::new());
    let number_observer = Arc::new(DataObserver::new("NumberObserver".to_string()));
    
    number_subject.attach("num_obs".to_string(), number_observer);
    number_subject.notify(&42);
    
    // 字符串主题
    let string_subject = Arc::new(GenericSubject::<String>::new());
    let string_observer = Arc::new(DataObserver::new("StringObserver".to_string()));
    
    string_subject.attach("str_obs".to_string(), string_observer);
    string_subject.notify(&"Hello World".to_string());
}
```

## Lean实现

### 依赖类型观察者

```lean
-- 观察者类型类
class Observer (α : Type) where
  update : α → String → IO Unit

-- 主题类型类
class Subject (α : Type) where
  attach : α → Observer β → IO α
  detach : α → Observer β → IO α
  notify : α → String → IO Unit

-- 具体观察者
structure ConcreteObserver where
  name : String
  deriving Repr

instance : Observer ConcreteObserver where
  update observer message := 
    IO.println s!"{observer.name} received: {message}"

-- 主题实现
structure SubjectImpl where
  observers : List (Σ β, Observer β)
  deriving Repr

-- 观察者包装
def SomeObserver := Σ β, Observer β

-- 主题实现
instance : Subject SubjectImpl where
  attach subject observer := do
    let newObservers := ⟨_, observer⟩ :: subject.observers
    return { subject with observers := newObservers }
  
  detach subject observer := do
    let filteredObservers := subject.observers.filter (λ obs => obs.snd ≠ observer)
    return { subject with observers := filteredObservers }
  
  notify subject message := do
    for obs in subject.observers do
      Observer.update obs.snd message

-- 使用示例
def demo : IO Unit := do
  let subject := SubjectImpl.mk []
  let observer1 := ConcreteObserver.mk "Observer1"
  let observer2 := ConcreteObserver.mk "Observer2"
  
  -- 添加观察者
  subject' ← Subject.attach subject observer1
  subject'' ← Subject.attach subject' observer2
  
  -- 通知观察者
  Subject.notify subject'' "Hello World!"
```

### 形式化验证的观察者

```lean
-- 观察者规格
structure ObserverSpec where
  observerType : Type
  invariant : observerType → Prop
  postcondition : observerType → String → Prop
  deriving Repr

-- 验证观察者
class ValidatedObserver (α : Type) (spec : ObserverSpec) where
  update : α → String → IO Unit
  preservesInvariant : ∀ (observer : α) (message : String),
    spec.invariant observer → spec.invariant observer
  satisfiesPostcondition : ∀ (observer : α) (message : String),
    spec.invariant observer → spec.postcondition observer message

-- 具体验证观察者
structure ValidatedConcreteObserver where
  name : String
  messageCount : Nat
  deriving Repr

-- 观察者规格
def observerSpec : ObserverSpec :=
  ObserverSpec.mk ValidatedConcreteObserver 
    (λ obs => obs.messageCount ≥ 0) 
    (λ obs message => obs.messageCount > 0)

instance : ValidatedObserver ValidatedConcreteObserver observerSpec where
  update observer message := do
    let newObserver := { observer with messageCount := observer.messageCount + 1 }
    IO.println s!"{newObserver.name} received: {message}"
  
  preservesInvariant observer message h := by
    simp [observerSpec, update]
    exact Nat.add_pos_right observer.messageCount (by simp)
  
  satisfiesPostcondition observer message h := by
    simp [observerSpec, update]
    exact Nat.add_pos_right observer.messageCount (by simp)

-- 证明：观察者保持不变量
theorem observer_preserves_invariant 
  (observer : ValidatedConcreteObserver) 
  (message : String) 
  (h : observerSpec.invariant observer) :
  observerSpec.invariant observer :=
  ValidatedObserver.preservesInvariant observer message h

-- 使用示例
def demoValidated : IO Unit := do
  let observer := ValidatedConcreteObserver.mk "ValidatedObserver" 0
  
  if observerSpec.invariant observer then
    ValidatedObserver.update observer "Hello World!"
    IO.println "Observer updated successfully!"
  else
    IO.println "Invalid observer state"
```

### 函数式观察者

```lean
-- 函数式观察者
structure FunctionObserver (α : Type) where
  update : α → String → IO Unit
  deriving Repr

-- 观察者组合
def composeObservers {α β : Type} 
  (f : FunctionObserver β) 
  (g : α → β) : 
  FunctionObserver α :=
  FunctionObserver.mk (λ a message => f.update (g a) message)

-- 身份观察者
def idObserver {α : Type} : FunctionObserver α :=
  FunctionObserver.mk (λ _ message => IO.println s!"Received: {message}")

-- 使用示例
def demoFunctional : IO Unit := do
  -- 创建观察者
  let observer := FunctionObserver.mk (λ data message => 
    IO.println s!"Data: {data}, Message: {message}")
  
  -- 使用观察者
  observer.update "Test Data" "Hello World!"
```

## 模式对比分析

### 语言特性对比

| 特性 | Haskell | Rust | Lean |
|------|---------|------|------|
| 类型安全 | 强类型系统 | 所有权系统 | 依赖类型 |
| 并发支持 | STM/IO | 多线程/异步 | 有限支持 |
| 内存管理 | GC | 所有权 | GC |
| 形式验证 | QuickCheck | 有限验证 | 完整证明 |
| 性能 | 惰性求值 | 零成本抽象 | 编译时优化 |

### 实现复杂度

1. **Haskell**: 中等复杂度，STM提供优雅的并发支持
2. **Rust**: 较高复杂度，需要处理所有权和生命周期
3. **Lean**: 最高复杂度，但提供最强的形式化保证

### 适用场景

- **Haskell**: 函数式编程，并发编程，事件驱动系统
- **Rust**: 系统编程，高性能应用，内存安全要求高
- **Lean**: 形式化验证，数学证明，关键系统

## 最佳实践

### 1. 内存管理

- Haskell: 使用GC，避免内存泄漏
- Rust: 使用所有权系统，确保内存安全
- Lean: 使用GC，依赖类型系统

### 2. 并发处理

- Haskell: 使用STM进行原子操作
- Rust: 使用Arc和Mutex进行线程安全
- Lean: 单线程，使用IO Monad

### 3. 性能优化

- Haskell: 惰性求值，避免不必要的计算
- Rust: 零拷贝，内联优化
- Lean: 编译时优化，依赖类型消除

## 总结

观察者模式在不同语言中展现出不同的实现特点：

- **Haskell** 通过STM提供了优雅的并发支持和强大的类型安全
- **Rust** 通过所有权系统确保了内存安全和高效的性能
- **Lean** 通过依赖类型系统提供了最强的形式化保证和验证能力

选择哪种实现方式取决于具体的应用场景、性能要求和安全性需求。
