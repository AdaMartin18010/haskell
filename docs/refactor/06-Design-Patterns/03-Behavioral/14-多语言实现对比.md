# Rust 行为型模式多实现对比

## 1. 责任链模式（Chain of Responsibility Pattern）

### 异步实现

```rust
use std::sync::{Arc, Mutex};
trait Handler {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler>;
    fn handle(&self, request: &str) -> Option<String>;
}
struct ConcreteHandlerA {
    next_handler: Option<Arc<dyn Handler>>,
}
impl Handler for ConcreteHandlerA {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }
    fn handle(&self, request: &str) -> Option<String> {
        if request == "A" {
            Some("Handled by ConcreteHandlerA".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}
struct ConcreteHandlerB {
    next_handler: Option<Arc<dyn Handler>>,
}
impl Handler for ConcreteHandlerB {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }
    fn handle(&self, request: &str) -> Option<String> {
        if request == "B" {
            Some("Handled by ConcreteHandlerB".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}
#[tokio::main]
async fn main() {
    let handler_a = Arc::new(Mutex::new(ConcreteHandlerA { next_handler: None }));
    let handler_b = Arc::new(Mutex::new(ConcreteHandlerB { next_handler: None }));
    handler_a.lock().unwrap().set_next(handler_b.clone());
    let result = handler_a.lock().unwrap().handle("A");
    println!("{:?}", result); // 输出: Some("Handled by ConcreteHandlerA")
    let result = handler_a.lock().unwrap().handle("B");
    println!("{:?}", result); // 输出: Some("Handled by ConcreteHandlerB")
    let result = handler_a.lock().unwrap().handle("C");
    println!("{:?}", result); // 输出: None
}
```

### 同步实现

```rust
use std::sync::{Arc, Mutex};
trait Handler {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler>;
    fn handle(&self, request: &str) -> Option<String>;
}
struct ConcreteHandlerA {
    next_handler: Option<Arc<dyn Handler>>,
}
impl Handler for ConcreteHandlerA {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }
    fn handle(&self, request: &str) -> Option<String> {
        if request == "A" {
            Some("Handled by ConcreteHandlerA".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}
struct ConcreteHandlerB {
    next_handler: Option<Arc<dyn Handler>>,
}
impl Handler for ConcreteHandlerB {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }
    fn handle(&self, request: &str) -> Option<String> {
        if request == "B" {
            Some("Handled by ConcreteHandlerB".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}
fn main() {
    let handler_a = Arc::new(Mutex::new(ConcreteHandlerA { next_handler: None }));
    let handler_b = Arc::new(Mutex::new(ConcreteHandlerB { next_handler: None }));
    handler_a.lock().unwrap().set_next(handler_b.clone());
    let request_a = handler_a.lock().unwrap().handle("A");
    println!("{:?}", request_a); // 输出: Some("Handled by ConcreteHandlerA")
    let request_b = handler_a.lock().unwrap().handle("B");
    println!("{:?}", request_b); // 输出: Some("Handled by ConcreteHandlerB")
    let request_c = handler_a.lock().unwrap().handle("C");
    println!("{:?}", request_c); // 输出: None
}
```

---

## 2. 命令模式（Command Pattern）

### 异步实现

```rust
trait Command {
    fn execute(&self);
}
struct ConcreteCommand {
    receiver: Arc<dyn Receiver>,
}
impl Command for ConcreteCommand {
    fn execute(&self) {
        self.receiver.action();
    }
}
trait Receiver {
    fn action(&self);
}
struct ConcreteReceiver;
impl Receiver for ConcreteReceiver {
    fn action(&self) {
        println!("ConcreteReceiver: Action performed.");
    }
}
struct Invoker {
    command: Option<Box<dyn Command>>,
}
impl Invoker {
    fn set_command(&mut self, command: Box<dyn Command>) {
        self.command = Some(command);
    }
    fn invoke(&self) {
        if let Some(command) = &self.command {
            command.execute();
        }
    }
}
#[tokio::main]
async fn main() {
    let receiver = Arc::new(ConcreteReceiver);
    let command = Box::new(ConcreteCommand { receiver });
    let mut invoker = Invoker { command: None };
    invoker.set_command(command);
    invoker.invoke(); // 输出: ConcreteReceiver: Action performed.
}
```

### 同步实现

```rust
trait Command {
    fn execute(&self);
}
struct ConcreteCommand {
    receiver: Arc<dyn Receiver>,
}
impl Command for ConcreteCommand {
    fn execute(&self) {
        self.receiver.action();
    }
}
trait Receiver {
    fn action(&self);
}
struct ConcreteReceiver;
impl Receiver for ConcreteReceiver {
    fn action(&self) {
        println!("ConcreteReceiver: Action performed.");
    }
}
struct Invoker {
    command: Option<Box<dyn Command>>,
}
impl Invoker {
    fn set_command(&mut self, command: Box<dyn Command>) {
        self.command = Some(command);
    }
    fn invoke(&self) {
        if let Some(command) = &self.command {
            command.execute();
        }
    }
}
fn main() {
    let receiver = Arc::new(ConcreteReceiver);
    let command = Box::new(ConcreteCommand { receiver });
    let mut invoker = Invoker { command: None };
    invoker.set_command(command);
    invoker.invoke(); // 输出: ConcreteReceiver: Action performed.
}
```

---

（后续可继续补充观察者、解释器、迭代器等模式的多实现代码）

# Haskell 典型实现片段

## Monad与安全运算

```haskell
-- Maybe Monad
safeDiv :: Double -> Double -> Maybe Double
safeDiv _ 0 = Nothing
safeDiv x y = Just (x / y)
```

## 高阶函数与map

```haskell
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
```

## 模式匹配与递归

```haskell
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

## QuickCheck属性测试

```haskell
import Test.QuickCheck

prop_reverse :: [Int] -> Bool
prop_reverse xs = reverse (reverse xs) == xs
```

---

（可按需在各行为型模式下补充更细致的Haskell实现）
