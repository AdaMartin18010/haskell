# Rust 行为型模式多实现对比

## 1. 责任链模式（Chain of Responsibility Pattern）

### 异步实现

```rust
use std::sync::{Arc, Mutex};
trait Handler {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler>;
    fn handle(&self, request: &str) -> Option<String>;
}
struct ConcreteHandlerA {
    next_handler: Option<Arc<dyn Handler>>,
}
impl Handler for ConcreteHandlerA {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }
    fn handle(&self, request: &str) -> Option<String> {
        if request == "A" {
            Some("Handled by ConcreteHandlerA".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}
struct ConcreteHandlerB {
    next_handler: Option<Arc<dyn Handler>>,
}
impl Handler for ConcreteHandlerB {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }
    fn handle(&self, request: &str) -> Option<String> {
        if request == "B" {
            Some("Handled by ConcreteHandlerB".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}
#[tokio::main]
async fn main() {
    let handler_a = Arc::new(Mutex::new(ConcreteHandlerA { next_handler: None }));
    let handler_b = Arc::new(Mutex::new(ConcreteHandlerB { next_handler: None }));
    handler_a.lock().unwrap().set_next(handler_b.clone());
    let result = handler_a.lock().unwrap().handle("A");
    println!("{:?}", result); // 输出: Some("Handled by ConcreteHandlerA")
    let result = handler_a.lock().unwrap().handle("B");
    println!("{:?}", result); // 输出: Some("Handled by ConcreteHandlerB")
    let result = handler_a.lock().unwrap().handle("C");
    println!("{:?}", result); // 输出: None
}
```

### 同步实现

```rust
use std::sync::{Arc, Mutex};
trait Handler {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler>;
    fn handle(&self, request: &str) -> Option<String>;
}
struct ConcreteHandlerA {
    next_handler: Option<Arc<dyn Handler>>,
}
impl Handler for ConcreteHandlerA {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }
    fn handle(&self, request: &str) -> Option<String> {
        if request == "A" {
            Some("Handled by ConcreteHandlerA".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}
struct ConcreteHandlerB {
    next_handler: Option<Arc<dyn Handler>>,
}
impl Handler for ConcreteHandlerB {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }
    fn handle(&self, request: &str) -> Option<String> {
        if request == "B" {
            Some("Handled by ConcreteHandlerB".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}
fn main() {
    let handler_a = Arc::new(Mutex::new(ConcreteHandlerA { next_handler: None }));
    let handler_b = Arc::new(Mutex::new(ConcreteHandlerB { next_handler: None }));
    handler_a.lock().unwrap().set_next(handler_b.clone());
    let request_a = handler_a.lock().unwrap().handle("A");
    println!("{:?}", request_a); // 输出: Some("Handled by ConcreteHandlerA")
    let request_b = handler_a.lock().unwrap().handle("B");
    println!("{:?}", request_b); // 输出: Some("Handled by ConcreteHandlerB")
    let request_c = handler_a.lock().unwrap().handle("C");
    println!("{:?}", request_c); // 输出: None
}
```

---

## 2. 命令模式（Command Pattern）

### 异步实现

```rust
trait Command {
    fn execute(&self);
}
struct ConcreteCommand {
    receiver: Arc<dyn Receiver>,
}
impl Command for ConcreteCommand {
    fn execute(&self) {
        self.receiver.action();
    }
}
trait Receiver {
    fn action(&self);
}
struct ConcreteReceiver;
impl Receiver for ConcreteReceiver {
    fn action(&self) {
        println!("ConcreteReceiver: Action performed.");
    }
}
struct Invoker {
    command: Option<Box<dyn Command>>,
}
impl Invoker {
    fn set_command(&mut self, command: Box<dyn Command>) {
        self.command = Some(command);
    }
    fn invoke(&self) {
        if let Some(command) = &self.command {
            command.execute();
        }
    }
}
#[tokio::main]
async fn main() {
    let receiver = Arc::new(ConcreteReceiver);
    let command = Box::new(ConcreteCommand { receiver });
    let mut invoker = Invoker { command: None };
    invoker.set_command(command);
    invoker.invoke(); // 输出: ConcreteReceiver: Action performed.
}
```

### 同步实现

```rust
trait Command {
    fn execute(&self);
}
struct ConcreteCommand {
    receiver: Arc<dyn Receiver>,
}
impl Command for ConcreteCommand {
    fn execute(&self) {
        self.receiver.action();
    }
}
trait Receiver {
    fn action(&self);
}
struct ConcreteReceiver;
impl Receiver for ConcreteReceiver {
    fn action(&self) {
        println!("ConcreteReceiver: Action performed.");
    }
}
struct Invoker {
    command: Option<Box<dyn Command>>,
}
impl Invoker {
    fn set_command(&mut self, command: Box<dyn Command>) {
        self.command = Some(command);
    }
    fn invoke(&self) {
        if let Some(command) = &self.command {
            command.execute();
        }
    }
}
fn main() {
    let receiver = Arc::new(ConcreteReceiver);
    let command = Box::new(ConcreteCommand { receiver });
    let mut invoker = Invoker { command: None };
    invoker.set_command(command);
    invoker.invoke(); // 输出: ConcreteReceiver: Action performed.
}
```

---

（后续可继续补充观察者、解释器、迭代器等模式的多实现代码）

# Haskell 典型实现片段

## Monad与安全运算

```haskell
-- Maybe Monad
safeDiv :: Double -> Double -> Maybe Double
safeDiv _ 0 = Nothing
safeDiv x y = Just (x / y)
```

## 高阶函数与map

```haskell
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
```

## 模式匹配与递归

```haskell
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

## QuickCheck属性测试

```haskell
import Test.QuickCheck

prop_reverse :: [Int] -> Bool
prop_reverse xs = reverse (reverse xs) == xs
```

---

（可按需在各行为型模式下补充更细致的Haskell实现）

# Lean 典型实现片段

## 函数式编程与证明

```lean
-- 高阶函数
def map {α β : Type} (f : α → β) : List α → List β
  | [] => []
  | x :: xs => f x :: map f xs

-- 命题即类型
def All {α : Type} (P : α → Prop) : List α → Prop
  | [] => True
  | x :: xs => P x ∧ All P xs
```

## 责任链模式

```lean
-- 处理器接口
def Handler := String → Option String

-- 具体处理器
def ConcreteHandlerA : Handler := λ s => 
  if s.contains "A" then some ("HandlerA: " ++ s) else none

def ConcreteHandlerB : Handler := λ s => 
  if s.contains "B" then some ("HandlerB: " ++ s) else none

-- 链式处理
def Chain (handlers : List Handler) : Handler := λ s =>
  match handlers with
  | [] => none
  | h :: hs => match h s with
    | some result => some result
    | none => Chain hs s
```

## 命令模式

```lean
-- 命令接口
def Command := String → String

-- 具体命令
def ConcreteCommand : Command := λ s => "Executed: " ++ s

-- 调用者
def Invoker := Command → String → String

-- 调用者实现
def execute : Invoker := λ cmd s => cmd s
```

## 解释器模式

```lean
-- 表达式
inductive Expression where
  | Literal (value : Nat) : Expression
  | Add (left right : Expression) : Expression
  | Multiply (left right : Expression) : Expression

-- 解释器
def Expression.interpret : Expression → Nat
  | Expression.Literal n => n
  | Expression.Add left right => interpret left + interpret right
  | Expression.Multiply left right => interpret left * interpret right
```

## 迭代器模式

```lean
-- 迭代器接口
structure Iterator (α : Type) where
  hasNext : Bool
  next : Option α
  advance : Iterator α

-- 列表迭代器
def ListIterator {α : Type} (xs : List α) : Iterator α :=
  { hasNext := not xs.isEmpty
    next := xs.head?
    advance := ListIterator xs.tail }
```

## 中介者模式

```lean
-- 同事接口
def Colleague := String → String

-- 中介者
structure Mediator where
  colleagueA : Colleague
  colleagueB : Colleague

-- 中介者方法
def Mediator.mediate (m : Mediator) (message : String) : String :=
  let resultA := m.colleagueA message
  m.colleagueB resultA
```

## 备忘录模式

```lean
-- 备忘录
structure Memento where
  state : String

-- 发起人
structure Originator where
  state : String

-- 创建备忘录
def Originator.createMemento (o : Originator) : Memento :=
  { state := o.state }

-- 恢复状态
def Originator.restore (o : Originator) (m : Memento) : Originator :=
  { state := m.state }
```

## 观察者模式

```lean
-- 观察者接口
def Observer := String → Unit

-- 主题
structure Subject where
  observers : List Observer
  state : String

-- 通知观察者
def Subject.notify (s : Subject) : Subject :=
  { s with observers := List.map (λ obs => obs s.state) s.observers }
```

## 状态模式

```lean
-- 状态接口
def State := String → String

-- 具体状态
def ConcreteStateA : State := λ s => "StateA: " ++ s
def ConcreteStateB : State := λ s => "StateB: " ++ s

-- 上下文
structure Context where
  state : State

-- 请求处理
def Context.request (c : Context) (s : String) : String :=
  c.state s
```

## 策略模式

```lean
-- 策略接口
def Strategy := String → String

-- 具体策略
def ConcreteStrategyA : Strategy := λ s => "StrategyA: " ++ s
def ConcreteStrategyB : Strategy := λ s => "StrategyB: " ++ s

-- 上下文
structure Context where
  strategy : Strategy

-- 执行策略
def Context.execute (c : Context) (s : String) : String :=
  c.strategy s
```

## 模板方法模式

```lean
-- 模板
def Template (primitive1 primitive2 : String → String) : String → String :=
  λ s => let step1 := primitive1 s
         let step2 := primitive2 step1
         "Template: " ++ step2

-- 具体实现
def ConcretePrimitive1 : String → String := λ s => "Step1: " ++ s
def ConcretePrimitive2 : String → String := λ s => "Step2: " ++ s

-- 使用模板
def concreteTemplate : String → String := Template ConcretePrimitive1 ConcretePrimitive2
```

## 访问者模式

```lean
-- 元素接口
inductive Element where
  | ElementA (value : String) : Element
  | ElementB (value : String) : Element

-- 访问者接口
def Visitor := Element → String

-- 具体访问者
def ConcreteVisitor : Visitor := λ e =>
  match e with
  | Element.ElementA v => "Visited A: " ++ v
  | Element.ElementB v => "Visited B: " ++ v

-- 接受访问
def Element.accept : Element → Visitor → String := λ e v => v e
```

## 证明系统

```lean
-- 策略语言
theorem command_execution (s : String) : 
  execute ConcreteCommand s = "Executed: " ++ s := by simp

-- 自动化证明
theorem strategy_execution (s : String) :
  Context.execute { strategy := ConcreteStrategyA } s = "StrategyA: " ++ s := by simp
```

---

（可按需在各模式下补充更细致的Lean实现）
