# 工厂模式 (Factory Pattern)

## 概述

工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

## 设计原则

- **单一职责原则**: 工厂类只负责对象的创建
- **开闭原则**: 对扩展开放，对修改关闭
- **依赖倒置原则**: 依赖抽象而不是具体实现

## 模式结构

```
Client
  ↓
Factory (抽象工厂)
  ↓
ConcreteFactory (具体工厂)
  ↓
Product (抽象产品)
  ↓
ConcreteProduct (具体产品)
```

## Haskell实现

### 基础工厂模式

```haskell
-- 抽象产品
class Product a where
  operation :: a -> String

-- 具体产品
data ConcreteProductA = ConcreteProductA deriving Show
data ConcreteProductB = ConcreteProductB deriving Show

instance Product ConcreteProductA where
  operation _ = "ConcreteProductA operation"

instance Product ConcreteProductB where
  operation _ = "ConcreteProductB operation"

-- 抽象工厂
class Factory f where
  createProduct :: f -> String -> Maybe (SomeProduct f)

-- 具体工厂
data ConcreteFactory = ConcreteFactory

instance Factory ConcreteFactory where
  createProduct _ "A" = Just (SomeProduct ConcreteProductA)
  createProduct _ "B" = Just (SomeProduct ConcreteProductB)
  createProduct _ _ = Nothing

-- 产品包装器
data SomeProduct f where
  SomeProduct :: Product p => p -> SomeProduct f

-- 使用示例
main :: IO ()
main = do
  let factory = ConcreteFactory
  case createProduct factory "A" of
    Just (SomeProduct product) -> putStrLn $ operation product
    Nothing -> putStrLn "Product not found"
```

### 使用类型类的工厂模式

```haskell
-- 产品类型类
class Product p where
  name :: p -> String
  price :: p -> Double
  description :: p -> String

-- 具体产品
data Book = Book
  { bookTitle :: String
  , bookAuthor :: String
  , bookPrice :: Double
  } deriving Show

data Electronics = Electronics
  { deviceName :: String
  , deviceBrand :: String
  , devicePrice :: Double
  } deriving Show

instance Product Book where
  name = bookTitle
  price = bookPrice
  description book = bookTitle book ++ " by " ++ bookAuthor book

instance Product Electronics where
  name = deviceName
  price = devicePrice
  description device = deviceName device ++ " by " ++ deviceBrand device

-- 工厂类型类
class Factory f where
  createBook :: f -> String -> String -> Double -> Book
  createElectronics :: f -> String -> String -> Double -> Electronics

-- 具体工厂
data ProductFactory = ProductFactory

instance Factory ProductFactory where
  createBook _ title author price = Book title author price
  createElectronics _ name brand price = Electronics name brand price

-- 使用示例
demo :: IO ()
demo = do
  let factory = ProductFactory
  let book = createBook factory "Haskell Programming" "Simon Peyton Jones" 49.99
  let device = createElectronics factory "Laptop" "Dell" 999.99
  
  putStrLn $ "Book: " ++ description book
  putStrLn $ "Device: " ++ description device
```

## Rust实现

### 通用工厂模式

```rust
use std::collections::HashMap;

// 抽象产品特征
trait Product {
    fn operation(&self) -> String;
    fn get_name(&self) -> String;
}

// 具体产品
struct ConcreteProductA {
    name: String,
}

struct ConcreteProductB {
    name: String,
}

impl Product for ConcreteProductA {
    fn operation(&self) -> String {
        format!("{}: Operation A", self.name)
    }
    
    fn get_name(&self) -> String {
        self.name.clone()
    }
}

impl Product for ConcreteProductB {
    fn operation(&self) -> String {
        format!("{}: Operation B", self.name)
    }
    
    fn get_name(&self) -> String {
        self.name.clone()
    }
}

// 抽象工厂特征
trait Factory {
    fn create_product(&self, product_type: &str) -> Option<Box<dyn Product>>;
}

// 具体工厂
struct ConcreteFactory;

impl Factory for ConcreteFactory {
    fn create_product(&self, product_type: &str) -> Option<Box<dyn Product>> {
        match product_type {
            "A" => Some(Box::new(ConcreteProductA {
                name: "Product A".to_string(),
            })),
            "B" => Some(Box::new(ConcreteProductB {
                name: "Product B".to_string(),
            })),
            _ => None,
        }
    }
}

// 使用示例
fn main() {
    let factory = ConcreteFactory;
    
    if let Some(product) = factory.create_product("A") {
        println!("{}", product.operation());
    }
    
    if let Some(product) = factory.create_product("B") {
        println!("{}", product.operation());
    }
}
```

### 多线程安全工厂

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

// 线程安全的产品注册表
struct ProductRegistry {
    creators: Mutex<HashMap<String, Box<dyn Fn() -> Box<dyn Product> + Send + Sync>>>,
}

impl ProductRegistry {
    fn new() -> Self {
        Self {
            creators: Mutex::new(HashMap::new()),
        }
    }
    
    fn register_product<F>(&self, name: String, creator: F)
    where
        F: Fn() -> Box<dyn Product> + Send + Sync + 'static,
    {
        let mut creators = self.creators.lock().unwrap();
        creators.insert(name, Box::new(creator));
    }
    
    fn create_product(&self, name: &str) -> Option<Box<dyn Product>> {
        let creators = self.creators.lock().unwrap();
        if let Some(creator) = creators.get(name) {
            Some(creator())
        } else {
            None
        }
    }
}

// 使用示例
fn demo_thread_safe_factory() {
    let registry = Arc::new(ProductRegistry::new());
    
    // 注册产品创建器
    registry.register_product("A".to_string(), || {
        Box::new(ConcreteProductA {
            name: "Product A".to_string(),
        })
    });
    
    registry.register_product("B".to_string(), || {
        Box::new(ConcreteProductB {
            name: "Product B".to_string(),
        })
    });
    
    // 多线程使用
    let handles: Vec<_> = (0..4)
        .map(|i| {
            let registry = Arc::clone(&registry);
            std::thread::spawn(move || {
                let product_type = if i % 2 == 0 { "A" } else { "B" };
                if let Some(product) = registry.create_product(product_type) {
                    println!("Thread {}: {}", i, product.operation());
                }
            })
        })
        .collect();
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 异步工厂模式

```rust
use tokio::sync::RwLock;
use std::collections::HashMap;

// 异步产品特征
#[async_trait::async_trait]
trait AsyncProduct {
    async fn operation(&self) -> String;
    async fn initialize(&mut self) -> Result<(), String>;
}

// 异步具体产品
struct AsyncConcreteProduct {
    name: String,
    initialized: bool,
}

#[async_trait::async_trait]
impl AsyncProduct for AsyncConcreteProduct {
    async fn operation(&self) -> String {
        if self.initialized {
            format!("{}: Async operation completed", self.name)
        } else {
            "Product not initialized".to_string()
        }
    }
    
    async fn initialize(&mut self) -> Result<(), String> {
        // 模拟异步初始化
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        self.initialized = true;
        Ok(())
    }
}

// 异步工厂
struct AsyncFactory {
    creators: RwLock<HashMap<String, Box<dyn Fn() -> Box<dyn AsyncProduct> + Send + Sync>>>,
}

impl AsyncFactory {
    fn new() -> Self {
        Self {
            creators: RwLock::new(HashMap::new()),
        }
    }
    
    async fn register_product<F>(&self, name: String, creator: F)
    where
        F: Fn() -> Box<dyn AsyncProduct> + Send + Sync + 'static,
    {
        let mut creators = self.creators.write().await;
        creators.insert(name, Box::new(creator));
    }
    
    async fn create_product(&self, name: &str) -> Option<Box<dyn AsyncProduct>> {
        let creators = self.creators.read().await;
        if let Some(creator) = creators.get(name) {
            Some(creator())
        } else {
            None
        }
    }
}

// 使用示例
#[tokio::main]
async fn demo_async_factory() {
    let factory = AsyncFactory::new();
    
    // 注册产品
    factory.register_product("async".to_string(), || {
        Box::new(AsyncConcreteProduct {
            name: "Async Product".to_string(),
            initialized: false,
        })
    }).await;
    
    // 创建和使用产品
    if let Some(mut product) = factory.create_product("async").await {
        if let Ok(()) = product.initialize().await {
            println!("{}", product.operation().await);
        }
    }
}
```

## Lean实现

### 依赖类型工厂模式

```lean
-- 产品类型
inductive ProductType
| Book
| Electronics
| Clothing

-- 产品接口
class Product (α : Type) where
  name : α → String
  price : α → Nat
  description : α → String

-- 具体产品
structure Book where
  title : String
  author : String
  price : Nat
  deriving Repr

structure Electronics where
  name : String
  brand : String
  price : Nat
  deriving Repr

-- 产品实例
instance : Product Book where
  name book := book.title
  price book := book.price
  description book := s!"{book.title} by {book.author}"

instance : Product Electronics where
  name device := device.name
  price device := device.price
  description device := s!"{device.name} by {device.brand}"

-- 工厂类型
class Factory (α : Type) where
  createBook : String → String → Nat → Book
  createElectronics : String → String → Nat → Electronics

-- 具体工厂
structure ProductFactory where
  deriving Repr

instance : Factory ProductFactory where
  createBook title author price := ⟨title, author, price⟩
  createElectronics name brand price := ⟨name, brand, price⟩

-- 类型安全的工厂函数
def createProduct {α : Type} [Factory α] (factory : α) 
  (productType : ProductType) : 
  match productType with
  | ProductType.Book => Book
  | ProductType.Electronics => Electronics
  | ProductType.Clothing => Unit :=
  match productType with
  | ProductType.Book => Factory.createBook factory "Default Book" "Unknown Author" 0
  | ProductType.Electronics => Factory.createElectronics factory "Default Device" "Unknown Brand" 0
  | ProductType.Clothing => ()

-- 使用示例
def demo : IO Unit := do
  let factory := ProductFactory.mk
  let book := Factory.createBook factory "Lean Programming" "Jeremy Avigad" 45
  let device := Factory.createElectronics factory "Computer" "Dell" 1200
  
  IO.println s!"Book: {Product.description book}"
  IO.println s!"Device: {Product.description device}"
```

### 形式化验证的工厂

```lean
-- 产品规格
structure ProductSpec where
  minPrice : Nat
  maxPrice : Nat
  requiredFields : List String
  deriving Repr

-- 验证产品是否符合规格
def validateProduct {α : Type} [Product α] (product : α) (spec : ProductSpec) : Prop :=
  Product.price product ≥ spec.minPrice ∧
  Product.price product ≤ spec.maxPrice ∧
  Product.name product ≠ ""

-- 工厂验证
class ValidatedFactory (α : Type) where
  createValidatedBook : String → String → Nat → ProductSpec → Option Book
  createValidatedElectronics : String → String → Nat → ProductSpec → Option Electronics

instance : ValidatedFactory ProductFactory where
  createValidatedBook title author price spec :=
    let book := ⟨title, author, price⟩
    if validateProduct book spec then some book else none
  
  createValidatedElectronics name brand price spec :=
    let device := ⟨name, brand, price⟩
    if validateProduct device spec then some device else none

-- 证明：工厂创建的产品符合规格
theorem factory_creates_valid_products 
  (factory : ProductFactory) 
  (spec : ProductSpec) 
  (title author : String) 
  (price : Nat) :
  let book := ValidatedFactory.createValidatedBook factory title author price spec
  match book with
  | some b => validateProduct b spec
  | none => True := by
  simp [ValidatedFactory.createValidatedBook, validateProduct]
  split
  · simp [validateProduct]
  · simp

-- 使用示例
def demoValidated : IO Unit := do
  let factory := ProductFactory.mk
  let spec := ProductSpec.mk 10 1000 ["title", "author"]
  
  match ValidatedFactory.createValidatedBook factory "Valid Book" "Author" 50 spec with
  | some book => IO.println s!"Created valid book: {Product.description book}"
  | none => IO.println "Failed to create book - validation failed"
```

## 模式对比分析

### 语言特性对比

| 特性 | Haskell | Rust | Lean |
|------|---------|------|------|
| 类型安全 | 强类型系统 | 所有权系统 | 依赖类型 |
| 抽象能力 | 类型类 | 特征 | 类型类 |
| 并发支持 | STM/IO | 多线程/异步 | 单线程 |
| 形式验证 | QuickCheck | 有限验证 | 完整证明 |
| 性能 | 惰性求值 | 零成本抽象 | 编译时优化 |

### 实现复杂度

1. **Haskell**: 中等复杂度，类型类提供优雅的抽象
2. **Rust**: 较高复杂度，需要处理所有权和生命周期
3. **Lean**: 最高复杂度，但提供最强的形式化保证

### 适用场景

- **Haskell**: 函数式编程，数学计算，原型开发
- **Rust**: 系统编程，高性能应用，内存安全要求高
- **Lean**: 形式化验证，数学证明，关键系统

## 最佳实践

### 1. 错误处理

- Haskell: 使用Maybe/Either类型
- Rust: 使用Result类型
- Lean: 使用Option类型和证明

### 2. 性能优化

- Haskell: 惰性求值，严格性注解
- Rust: 零拷贝，内联优化
- Lean: 编译时优化，依赖类型消除

### 3. 测试策略

- Haskell: QuickCheck属性测试
- Rust: 单元测试，集成测试
- Lean: 形式化证明，类型检查

## 总结

工厂模式在不同语言中展现出不同的实现特点：

- **Haskell** 通过类型类提供了优雅的抽象和强大的类型安全
- **Rust** 通过所有权系统确保了内存安全和并发安全
- **Lean** 通过依赖类型系统提供了最强的形式化保证

选择哪种实现方式取决于具体的应用场景和需求。
