# Rust 并发模式多实现对比

## 1. 线程池模式（Thread Pool Pattern）

### 异步实现
```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

struct ThreadPool {
    workers: Vec<Worker>,
    tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>,
}

impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        let tasks = Arc::new(Mutex::new(VecDeque::new()));
        let mut workers = Vec::with_capacity(size);
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&tasks)));
        }
        ThreadPool { workers, tasks }
    }
    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mut tasks = self.tasks.lock().unwrap();
        tasks.push_back(Box::new(f));
    }
}
struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}
impl Worker {
    fn new(id: usize, tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let task = {
                let mut tasks = tasks.lock().unwrap();
                tasks.pop_front()
            };
            if let Some(task) = task {
                task();
            } else {
                break;
            }
        });
        Worker { id, thread: Some(thread) }
    }
}
fn main() {
    let pool = ThreadPool::new(4);
    for i in 0..10 {
        pool.execute(move || {
            println!("Task {} is running", i);
        });
    }
}
```

### 同步实现
```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: Arc<Mutex<VecDeque<Job>>>,
}
type Job = Box<dyn FnOnce() + Send + 'static>;
impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        let sender = Arc::new(Mutex::new(VecDeque::new()));
        let mut workers = Vec::with_capacity(size);
        for _ in 0..size {
            workers.push(Worker::new(sender.clone()));
        }
        ThreadPool { workers, sender }
    }
    fn execute<F>(&self, job: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mut sender = self.sender.lock().unwrap();
        sender.push_back(Box::new(job));
    }
}
struct Worker {
    thread: Option<thread::JoinHandle<()>>,
}
impl Worker {
    fn new(sender: Arc<Mutex<VecDeque<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = {
                let mut sender = sender.lock().unwrap();
                sender.pop_front()
            };
            if let Some(job) = job {
                job();
            }
        });
        Worker { thread: Some(thread) }
    }
}
fn main() {
    let pool = ThreadPool::new(4);
    for i in 0..10 {
        pool.execute(move || {
            println!("Executing job {}", i);
        });
    }
}
```

---

## 2. Future模式（Future Pattern）

### 异步实现
```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio::task;

struct SimpleFuture {
    value: Option<i32>,
}
impl Future for SimpleFuture {
    type Output = i32;
    fn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
        if let Some(value) = self.value {
            Poll::Ready(value)
        } else {
            Poll::Pending
        }
    }
}
#[tokio::main]
async fn main() {
    let future = SimpleFuture { value: Some(42) };
    let result = future.await;
    println!("Future result: {}", result);
}
```

### 同步实现
```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::thread;
use std::time::Duration;

struct SimpleFuture {
    value: Option<i32>,
}
impl Future for SimpleFuture {
    type Output = i32;
    fn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
        if let Some(value) = self.value {
            Poll::Ready(value)
        } else {
            Poll::Pending
        }
    }
}
fn main() {
    let future = SimpleFuture { value: Some(42) };
    let result = futures::executor::block_on(future);
    println!("Future result: {}", result);
}
```

---

（后续可继续补充Promise、Reactor、Proactor等模式的多实现代码） 