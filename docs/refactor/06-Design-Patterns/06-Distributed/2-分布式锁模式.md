# 分布式锁模式 (Distributed Lock Pattern)

## 概述

分布式锁模式是一种分布式设计模式，用于在分布式系统中协调对共享资源的访问。它确保在多个节点或服务之间，同一时间只有一个节点能够访问特定的资源，从而避免数据不一致和竞态条件。

## 设计原则

- **互斥性**: 同一时间只有一个客户端能持有锁
- **防死锁**: 锁必须能够被释放，避免死锁
- **容错性**: 在节点故障时能够正确处理
- **高性能**: 锁的获取和释放操作要高效

## 模式结构

```text
Client A
  ↓
Distributed Lock Service
  ↓
Shared Resource
  ↓
Client B
```

## Haskell实现

### 基础分布式锁

```haskell
import Control.Concurrent
import Control.Concurrent.STM
import Control.Monad
import Data.Time
import Data.Maybe

-- 锁状态
data LockState = Locked | Unlocked deriving (Show, Eq)

-- 分布式锁
data DistributedLock = DistributedLock
  { lockId :: String
  , state :: TVar LockState
  , owner :: TVar (Maybe String)
  , timestamp :: TVar UTCTime
  , ttl :: NominalDiffTime
  }

-- 创建分布式锁
newDistributedLock :: String -> NominalDiffTime -> IO DistributedLock
newDistributedLock lockId ttl = do
  state <- newTVarIO Unlocked
  owner <- newTVarIO Nothing
  timestamp <- newTVarIO =<< getCurrentTime
  return $ DistributedLock lockId state owner timestamp ttl

-- 尝试获取锁
tryAcquireLock :: DistributedLock -> String -> IO Bool
tryAcquireLock lock clientId = atomically $ do
  currentState <- readTVar (state lock)
  currentOwner <- readTVar (owner lock)
  currentTime <- readTVar (timestamp lock)
  now <- unsafeIOToSTM getCurrentTime
  
  case currentState of
    Unlocked -> do
      writeTVar (state lock) Locked
      writeTVar (owner lock) (Just clientId)
      writeTVar (timestamp lock) now
      return True
    Locked -> do
      -- 检查锁是否过期
      if diffUTCTime now currentTime > ttl lock
        then do
          writeTVar (state lock) Locked
          writeTVar (owner lock) (Just clientId)
          writeTVar (timestamp lock) now
          return True
        else return False

-- 释放锁
releaseLock :: DistributedLock -> String -> IO Bool
releaseLock lock clientId = atomically $ do
  currentState <- readTVar (state lock)
  currentOwner <- readTVar (owner lock)
  
  case (currentState, currentOwner) of
    (Locked, Just ownerId) | ownerId == clientId -> do
      writeTVar (state lock) Unlocked
      writeTVar (owner lock) Nothing
      return True
    _ -> return False

-- 使用示例
main :: IO ()
main = do
  lock <- newDistributedLock "resource1" 30 -- 30秒TTL
  
  -- 客户端A尝试获取锁
  acquired1 <- tryAcquireLock lock "clientA"
  putStrLn $ "Client A acquired lock: " ++ show acquired1
  
  -- 客户端B尝试获取锁
  acquired2 <- tryAcquireLock lock "clientB"
  putStrLn $ "Client B acquired lock: " ++ show acquired2
  
  -- 客户端A释放锁
  released <- releaseLock lock "clientA"
  putStrLn $ "Client A released lock: " ++ show released
  
  -- 客户端B再次尝试获取锁
  acquired3 <- tryAcquireLock lock "clientB"
  putStrLn $ "Client B acquired lock after release: " ++ show acquired3
```

### 使用Redis的分布式锁

```haskell
import Database.Redis
import Control.Monad
import Data.Time
import Data.Text (Text)
import qualified Data.Text as T

-- Redis分布式锁
data RedisDistributedLock = RedisDistributedLock
  { redisConn :: Connection
  , lockKey :: Text
  , lockValue :: Text
  , ttlSeconds :: Integer
  }

-- 创建Redis分布式锁
newRedisDistributedLock :: Connection -> Text -> Integer -> IO RedisDistributedLock
newRedisDistributedLock conn key ttl = do
  value <- T.pack <$> show <$> getCurrentTime
  return $ RedisDistributedLock conn key value ttl

-- 尝试获取Redis锁
tryAcquireRedisLock :: RedisDistributedLock -> IO Bool
tryAcquireRedisLock lock = do
  result <- runRedis (redisConn lock) $ do
    set (lockKey lock) (lockValue lock) (SetOpts (Just (ttlSeconds lock)) Nothing Nothing)
  case result of
    Right Ok -> return True
    Right (Error _) -> return False
    Left _ -> return False

-- 释放Redis锁
releaseRedisLock :: RedisDistributedLock -> IO Bool
releaseRedisLock lock = do
  result <- runRedis (redisConn lock) $ do
    eval (T.pack "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end") 
         [lockKey lock] 
         [lockValue lock]
  case result of
    Right (Integer 1) -> return True
    _ -> return False

-- 使用示例
demoRedisLock :: IO ()
demoRedisLock = do
  conn <- checkedConnect defaultConnectInfo
  lock <- newRedisDistributedLock conn "resource1" 30
  
  -- 尝试获取锁
  acquired <- tryAcquireRedisLock lock
  putStrLn $ "Acquired Redis lock: " ++ show acquired
  
  -- 释放锁
  released <- releaseRedisLock lock
  putStrLn $ "Released Redis lock: " ++ show released
```

### 使用Zookeeper的分布式锁

```haskell
import Control.Concurrent
import Control.Monad
import Data.Time

-- Zookeeper分布式锁
data ZookeeperDistributedLock = ZookeeperDistributedLock
  { zkPath :: String
  , clientId :: String
  , lockPath :: TVar (Maybe String)
  }

-- 创建Zookeeper分布式锁
newZookeeperDistributedLock :: String -> String -> IO ZookeeperDistributedLock
newZookeeperDistributedLock path clientId = do
  lockPath <- newTVarIO Nothing
  return $ ZookeeperDistributedLock path clientId lockPath

-- 尝试获取Zookeeper锁
tryAcquireZookeeperLock :: ZookeeperDistributedLock -> IO Bool
tryAcquireZookeeperLock lock = atomically $ do
  currentPath <- readTVar (lockPath lock)
  case currentPath of
    Just _ -> return False -- 已经持有锁
    Nothing -> do
      -- 模拟创建临时节点
      let newPath = zkPath lock ++ "/lock-" ++ clientId lock
      writeTVar (lockPath lock) (Just newPath)
      return True

-- 释放Zookeeper锁
releaseZookeeperDistributedLock :: ZookeeperDistributedLock -> IO Bool
releaseZookeeperDistributedLock lock = atomically $ do
  currentPath <- readTVar (lockPath lock)
  case currentPath of
    Just _ -> do
      writeTVar (lockPath lock) Nothing
      return True
    Nothing -> return False

-- 使用示例
demoZookeeperLock :: IO ()
demoZookeeperLock = do
  lock <- newZookeeperDistributedLock "/locks/resource1" "clientA"
  
  -- 尝试获取锁
  acquired <- tryAcquireZookeeperLock lock
  putStrLn $ "Acquired Zookeeper lock: " ++ show acquired
  
  -- 释放锁
  released <- releaseZookeeperDistributedLock lock
  putStrLn $ "Released Zookeeper lock: " ++ show released
```

## Rust实现

### 基础分布式锁1

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use std::time::Instant;

// 锁状态
#[derive(Debug, Clone, PartialEq)]
enum LockState {
    Locked,
    Unlocked,
}

// 锁信息
#[derive(Debug)]
struct LockInfo {
    state: LockState,
    owner: Option<String>,
    timestamp: u64,
    ttl: u64,
}

// 分布式锁服务
struct DistributedLockService {
    locks: Arc<Mutex<HashMap<String, LockInfo>>>,
}

impl DistributedLockService {
    fn new() -> Self {
        Self {
            locks: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    fn try_acquire_lock(&self, lock_id: &str, client_id: &str, ttl: u64) -> bool {
        let mut locks = self.locks.lock().unwrap();
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        let lock_info = locks.entry(lock_id.to_string()).or_insert(LockInfo {
            state: LockState::Unlocked,
            owner: None,
            timestamp: now,
            ttl,
        });
        
        match lock_info.state {
            LockState::Unlocked => {
                lock_info.state = LockState::Locked;
                lock_info.owner = Some(client_id.to_string());
                lock_info.timestamp = now;
                true
            }
            LockState::Locked => {
                // 检查锁是否过期
                if now - lock_info.timestamp > lock_info.ttl {
                    lock_info.state = LockState::Locked;
                    lock_info.owner = Some(client_id.to_string());
                    lock_info.timestamp = now;
                    true
                } else {
                    false
                }
            }
        }
    }
    
    fn release_lock(&self, lock_id: &str, client_id: &str) -> bool {
        let mut locks = self.locks.lock().unwrap();
        
        if let Some(lock_info) = locks.get_mut(lock_id) {
            if lock_info.owner.as_ref() == Some(&client_id.to_string()) {
                lock_info.state = LockState::Unlocked;
                lock_info.owner = None;
                true
            } else {
                false
            }
        } else {
            false
        }
    }
}

// 使用示例
fn main() {
    let lock_service = Arc::new(DistributedLockService::new());
    
    // 客户端A尝试获取锁
    let service_a = Arc::clone(&lock_service);
    let handle_a = thread::spawn(move || {
        let acquired = service_a.try_acquire_lock("resource1", "clientA", 30);
        println!("Client A acquired lock: {}", acquired);
        
        if acquired {
            thread::sleep(Duration::from_secs(2));
            let released = service_a.release_lock("resource1", "clientA");
            println!("Client A released lock: {}", released);
        }
    });
    
    // 客户端B尝试获取锁
    let service_b = Arc::clone(&lock_service);
    let handle_b = thread::spawn(move || {
        thread::sleep(Duration::from_millis(100));
        let acquired = service_b.try_acquire_lock("resource1", "clientB", 30);
        println!("Client B acquired lock: {}", acquired);
        
        if acquired {
            let released = service_b.release_lock("resource1", "clientB");
            println!("Client B released lock: {}", released);
        }
    });
    
    handle_a.join().unwrap();
    handle_b.join().unwrap();
}
```

### 使用Redis的分布式锁1

```rust
use redis::{Client, Connection, Commands};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// Redis分布式锁
struct RedisDistributedLock {
    conn: Connection,
    lock_key: String,
    lock_value: String,
    ttl: u64,
}

impl RedisDistributedLock {
    fn new(conn: Connection, lock_key: String, ttl: u64) -> Self {
        let lock_value = Uuid::new_v4().to_string();
        Self {
            conn,
            lock_key,
            lock_value,
            ttl,
        }
    }
    
    fn try_acquire(&mut self) -> Result<bool, redis::RedisError> {
        let result: Result<String, redis::RedisError> = redis::cmd("SET")
            .arg(&self.lock_key)
            .arg(&self.lock_value)
            .arg("NX")
            .arg("EX")
            .arg(self.ttl)
            .query(&mut self.conn);
        
        match result {
            Ok(_) => Ok(true),
            Err(_) => Ok(false),
        }
    }
    
    fn release(&mut self) -> Result<bool, redis::RedisError> {
        let script = r#"
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('del', KEYS[1])
            else
                return 0
            end
        "#;
        
        let result: Result<i32, redis::RedisError> = redis::cmd("EVAL")
            .arg(script)
            .arg(1)
            .arg(&self.lock_key)
            .arg(&self.lock_value)
            .query(&mut self.conn);
        
        match result {
            Ok(1) => Ok(true),
            _ => Ok(false),
        }
    }
}

// 使用示例
fn demo_redis_lock() -> Result<(), redis::RedisError> {
    let client = Client::open("redis://127.0.0.1/")?;
    let mut conn = client.get_connection()?;
    
    let mut lock = RedisDistributedLock::new(conn, "resource1".to_string(), 30);
    
    // 尝试获取锁
    let acquired = lock.try_acquire()?;
    println!("Acquired Redis lock: {}", acquired);
    
    if acquired {
        // 释放锁
        let released = lock.release()?;
        println!("Released Redis lock: {}", released);
    }
    
    Ok(())
}
```

### 使用etcd的分布式锁

```rust
use etcd_client::{Client, LockClient, LockOptions};
use std::time::Duration;

// etcd分布式锁
struct EtcdDistributedLock {
    client: Client,
    lock_name: String,
    lease_id: Option<i64>,
}

impl EtcdDistributedLock {
    fn new(client: Client, lock_name: String) -> Self {
        Self {
            client,
            lock_name,
            lease_id: None,
        }
    }
    
    async fn try_acquire(&mut self, ttl: u64) -> Result<bool, etcd_client::Error> {
        let mut lock_client = self.client.lock_client();
        
        // 创建租约
        let mut lease_client = self.client.lease_client();
        let lease = lease_client.grant(ttl, None).await?;
        let lease_id = lease.id();
        
        // 尝试获取锁
        let lock_options = LockOptions::new()
            .with_lease(lease_id);
        
        match lock_client.lock(self.lock_name.as_bytes(), Some(lock_options)).await {
            Ok(_) => {
                self.lease_id = Some(lease_id);
                Ok(true)
            }
            Err(_) => Ok(false),
        }
    }
    
    async fn release(&mut self) -> Result<bool, etcd_client::Error> {
        if let Some(lease_id) = self.lease_id {
            let mut lock_client = self.client.lock_client();
            lock_client.unlock(self.lock_name.as_bytes()).await?;
            
            // 撤销租约
            let mut lease_client = self.client.lease_client();
            lease_client.revoke(lease_id).await?;
            
            self.lease_id = None;
            Ok(true)
        } else {
            Ok(false)
        }
    }
}

// 使用示例
#[tokio::main]
async fn demo_etcd_lock() -> Result<(), etcd_client::Error> {
    let client = Client::connect(["127.0.0.1:2379"], None).await?;
    let mut lock = EtcdDistributedLock::new(client, "resource1".to_string());
    
    // 尝试获取锁
    let acquired = lock.try_acquire(30).await?;
    println!("Acquired etcd lock: {}", acquired);
    
    if acquired {
        // 释放锁
        let released = lock.release().await?;
        println!("Released etcd lock: {}", released);
    }
    
    Ok(())
}
```

## Lean实现

### 依赖类型分布式锁

```lean
-- 锁状态
inductive LockState
| Locked
| Unlocked
deriving Repr

-- 分布式锁
structure DistributedLock (α : Type) where
  lockId : String
  state : LockState
  owner : Option String
  timestamp : Nat
  ttl : Nat
  deriving Repr

-- 锁操作结果
inductive LockResult
| Success
| AlreadyLocked
| NotOwner
| Expired
deriving Repr

-- 基础分布式锁实现
def basicDistributedLock {α : Type} (lockId : String) (ttl : Nat) : DistributedLock α :=
  DistributedLock.mk lockId LockState.Unlocked none 0 ttl

-- 尝试获取锁
def tryAcquireLock {α : Type} 
  (lock : DistributedLock α) 
  (clientId : String) 
  (currentTime : Nat) : 
  LockResult × DistributedLock α :=
  match lock.state with
  | LockState.Unlocked => 
    (LockResult.Success, { lock with 
      state := LockState.Locked, 
      owner := some clientId, 
      timestamp := currentTime })
  | LockState.Locked => 
    if currentTime - lock.timestamp > lock.ttl then
      (LockResult.Success, { lock with 
        state := LockState.Locked, 
        owner := some clientId, 
        timestamp := currentTime })
    else
      (LockResult.AlreadyLocked, lock)

-- 释放锁
def releaseLock {α : Type} 
  (lock : DistributedLock α) 
  (clientId : String) : 
  LockResult × DistributedLock α :=
  match lock.state, lock.owner with
  | LockState.Locked, some ownerId => 
    if ownerId = clientId then
      (LockResult.Success, { lock with 
        state := LockState.Unlocked, 
        owner := none })
    else
      (LockResult.NotOwner, lock)
  | _, _ => (LockResult.NotOwner, lock)

-- 使用示例
def demo : IO Unit := do
  let lock := basicDistributedLock "resource1" 30
  let currentTime := 1000
  
  -- 客户端A尝试获取锁
  let (result1, lock1) := tryAcquireLock lock "clientA" currentTime
  IO.println s!"Client A acquire result: {result1}"
  
  -- 客户端B尝试获取锁
  let (result2, lock2) := tryAcquireLock lock1 "clientB" currentTime
  IO.println s!"Client B acquire result: {result2}"
  
  -- 客户端A释放锁
  let (result3, lock3) := releaseLock lock1 "clientA"
  IO.println s!"Client A release result: {result3}"
```

### 形式化验证的分布式锁

```lean
-- 分布式锁规格
structure DistributedLockSpec where
  lockType : Type
  invariant : DistributedLock lockType → Prop
  acquirePostcondition : DistributedLock lockType → String → LockResult → Prop
  releasePostcondition : DistributedLock lockType → String → LockResult → Prop
  deriving Repr

-- 验证分布式锁
class ValidatedDistributedLock (α : Type) (spec : DistributedLockSpec) where
  tryAcquire : DistributedLock α → String → Nat → LockResult × DistributedLock α
  release : DistributedLock α → String → LockResult × DistributedLock α
  preservesInvariant : ∀ (lock : DistributedLock α) (clientId : String) (time : Nat),
    spec.invariant lock → spec.invariant (tryAcquire lock clientId time).snd
  satisfiesAcquirePostcondition : ∀ (lock : DistributedLock α) (clientId : String) (time : Nat),
    spec.invariant lock → spec.acquirePostcondition lock clientId (tryAcquire lock clientId time).fst
  satisfiesReleasePostcondition : ∀ (lock : DistributedLock α) (clientId : String),
    spec.invariant lock → spec.releasePostcondition lock clientId (release lock clientId).fst

-- 具体分布式锁规格
def stringLockSpec : DistributedLockSpec :=
  DistributedLockSpec.mk 
    String 
    (λ lock => lock.ttl > 0)
    (λ lock clientId result => 
      result = LockResult.Success → lock.state = LockState.Locked ∧ lock.owner = some clientId)
    (λ lock clientId result => 
      result = LockResult.Success → lock.state = LockState.Unlocked ∧ lock.owner = none)

-- 验证分布式锁实现
instance : ValidatedDistributedLock String stringLockSpec where
  tryAcquire lock clientId currentTime := tryAcquireLock lock clientId currentTime
  release lock clientId := releaseLock lock clientId
  preservesInvariant lock clientId time h := by
    simp [stringLockSpec, tryAcquireLock]
    split
    · simp [DistributedLock.ttl]
    · simp [DistributedLock.ttl]
  satisfiesAcquirePostcondition lock clientId time h := by
    simp [stringLockSpec, tryAcquireLock]
    split
    · simp [LockState.Locked]
    · simp [LockState.Locked]
  satisfiesReleasePostcondition lock clientId h := by
    simp [stringLockSpec, releaseLock]
    split
    · simp [LockState.Unlocked]
    · simp [LockState.Unlocked]

-- 证明：锁的互斥性
theorem lock_mutual_exclusion 
  (lock : DistributedLock String) 
  (clientId1 clientId2 : String) 
  (time : Nat) 
  (h : stringLockSpec.invariant lock) :
  let (result1, lock1) := tryAcquireLock lock clientId1 time
  let (result2, lock2) := tryAcquireLock lock1 clientId2 time
  result1 = LockResult.Success → result2 = LockResult.AlreadyLocked := by
  simp [tryAcquireLock]
  intro h1
  have : lock1.state = LockState.Locked := by
    simp [tryAcquireLock] at h1
    split at h1
    · simp [LockState.Locked]
    · contradiction
  simp [tryAcquireLock, this]

-- 使用示例
def demoValidated : IO Unit := do
  let lock := basicDistributedLock "resource1" 30
  
  if stringLockSpec.invariant lock then
    let (result, newLock) := ValidatedDistributedLock.tryAcquire lock "clientA" 1000
    IO.println s!"Acquire result: {result}"
    IO.println "Postcondition satisfied!"
  else
    IO.println "Invalid lock state"
```

### 函数式分布式锁

```lean
-- 函数式分布式锁
structure FunctionalDistributedLock (α : Type) where
  tryAcquire : String → Nat → DistributedLock α → LockResult × DistributedLock α
  release : String → DistributedLock α → LockResult × DistributedLock α
  deriving Repr

-- 分布式锁组合
def composeDistributedLocks {α β : Type} 
  (f : FunctionalDistributedLock β) 
  (g : FunctionalDistributedLock α) : 
  FunctionalDistributedLock α :=
  FunctionalDistributedLock.mk 
    (λ clientId time lock => g.tryAcquire clientId time lock)
    (λ clientId lock => g.release clientId lock)

-- 身份分布式锁
def idDistributedLock {α : Type} : FunctionalDistributedLock α :=
  FunctionalDistributedLock.mk 
    (λ clientId time lock => tryAcquireLock lock clientId time)
    (λ clientId lock => releaseLock lock clientId)

-- 使用示例
def demoFunctional : IO Unit := do
  -- 创建分布式锁
  let lock1 := FunctionalDistributedLock.mk 
    (λ clientId time lock => tryAcquireLock lock clientId time)
    (λ clientId lock => releaseLock lock clientId)
  
  let lock := basicDistributedLock "resource1" 30
  let (result, newLock) := lock1.tryAcquire "clientA" 1000 lock
  
  IO.println s!"Functional lock result: {result}"
```

## 模式对比分析

### 语言特性对比

| 特性 | Haskell | Rust | Lean |
|------|---------|------|------|
| 类型安全 | 强类型系统 | 所有权系统 | 依赖类型 |
| 并发支持 | STM/IO | 多线程/异步 | 有限支持 |
| 内存管理 | GC | 所有权 | GC |
| 形式验证 | QuickCheck | 有限验证 | 完整证明 |
| 性能 | 惰性求值 | 零成本抽象 | 编译时优化 |

### 实现复杂度

1. **Haskell**: 中等复杂度，STM提供优雅的并发抽象
2. **Rust**: 较高复杂度，需要处理所有权和生命周期
3. **Lean**: 最高复杂度，但提供最强的形式化保证

### 适用场景

- **Haskell**: 函数式编程，分布式系统，原型开发
- **Rust**: 系统编程，高性能应用，内存安全要求高
- **Lean**: 形式化验证，数学证明，关键系统

## 最佳实践

### 1. 锁的粒度

- 选择合适的锁粒度，避免过度锁定
- 考虑锁的持有时间，尽量缩短
- 避免嵌套锁，防止死锁

### 2. 错误处理

- Haskell: 使用Either类型和异常处理
- Rust: 使用Result类型和错误传播
- Lean: 使用Option类型和证明

### 3. 性能优化

- Haskell: 使用严格性注解，避免惰性求值开销
- Rust: 使用零拷贝，内联优化
- Lean: 编译时优化，依赖类型消除

## 总结

分布式锁模式在不同语言中展现出不同的实现特点：

- **Haskell** 通过STM提供了优雅的并发抽象和强大的类型安全
- **Rust** 通过所有权系统确保了内存安全和高效的性能
- **Lean** 通过依赖类型系统提供了最强的形式化保证和验证能力

选择哪种实现方式取决于具体的应用场景、性能要求和安全性需求。
