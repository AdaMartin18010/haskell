# Rust 分布式系统模式多实现对比

## 1. 通信模式

### 请求-响应模式
```rust
use std::future::Future;
use std::pin::Pin;
use tokio::sync::mpsc;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Request<T> {
    id: String,
    payload: T,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Response<R> {
    request_id: String,
    payload: R,
}

struct RequestResponseService<T, R, F, Fut>
where
    T: Send + 'static,
    R: Send + 'static,
    F: Fn(Request<T>) -> Fut + Send + Sync + 'static,
    Fut: Future<Output = Response<R>> + Send,
{
    handler: F,
    request_rx: mpsc::Receiver<(Request<T>, mpsc::Sender<Response<R>>)>,
}

impl<T, R, F, Fut> RequestResponseService<T, R, F, Fut>
where
    T: Send + 'static,
    R: Send + 'static,
    F: Fn(Request<T>) -> Fut + Send + Sync + 'static,
    Fut: Future<Output = Response<R>> + Send,
{
    fn new(handler: F) -> (Self, mpsc::Sender<(Request<T>, mpsc::Sender<Response<R>>)>) {
        let (tx, rx) = mpsc::channel(100);
        (Self { handler, request_rx: rx }, tx)
    }
    async fn run(&mut self) {
        while let Some((request, response_tx)) = self.request_rx.recv().await {
            let handler = &self.handler;
            let response = handler(request).await;
            let _ = response_tx.send(response).await;
        }
    }
}

struct Client<T, R> {
    request_tx: mpsc::Sender<(Request<T>, mpsc::Sender<Response<R>>)>,
}
impl<T, R> Client<T, R>
where
    T: Send + 'static,
    R: Send + 'static,
{
    fn new(request_tx: mpsc::Sender<(Request<T>, mpsc::Sender<Response<R>>)>) -> Self {
        Self { request_tx }
    }
    async fn send_request(&self, request: Request<T>) -> Result<Response<R>, String> {
        let (response_tx, mut response_rx) = mpsc::channel(1);
        if self.request_tx.send((request, response_tx)).await.is_err() {
            return Err("服务已关闭".to_string());
        }
        response_rx.recv().await.ok_or_else(|| "无法获取响应".to_string())
    }
}
#[tokio::main]
async fn main() {
    let handler = |req: Request<String>| async move {
        println!("处理请求: {:?}", req);
        Response {
            request_id: req.id,
            payload: format!("已处理: {}", req.payload),
        }
    };
    let (mut service, request_tx) = RequestResponseService::new(handler);
    tokio::spawn(async move {
        service.run().await;
    });
    let client = Client::new(request_tx);
    let request = Request {
        id: "req-1".to_string(),
        payload: "Hello, Service!".to_string(),
    };
    let response = client.send_request(request).await.unwrap();
    println!("收到响应: {:?}", response);
}
```

---

（后续可继续补充发布-订阅、消息队列、共识、分区、容错、事务等模式的多实现代码） 