# Ê∏∏ÊàèAIÁêÜËÆ∫ (Game AI Theory)

## üìã ÊñáÊ°£‰ø°ÊÅØ

- **ÊñáÊ°£ÁºñÂè∑**: 05-08-02
- **ÊâÄÂ±ûÂ±ÇÁ∫ß**: ‰∫ß‰∏öÂ±Ç - Ê∏∏ÊàèÂºÄÂèë
- **ÂàõÂª∫Êó∂Èó¥**: 2024Âπ¥12Êúà19Êó•
- **ÊúÄÂêéÊõ¥Êñ∞**: 2024Âπ¥12Êúà19Êó•
- **ÊñáÊ°£Áä∂ÊÄÅ**: ÂÆåÊàê

---

## üéØ Ê¶ÇËø∞

Ê∏∏ÊàèAIÊòØÊ∏∏ÊàèÂºÄÂèë‰∏≠ÁöÑÊ†∏ÂøÉÊäÄÊúØÔºåÊ∂âÂèäÊô∫ËÉΩ‰ΩìË°å‰∏∫ÊéßÂà∂„ÄÅË∑ØÂæÑËßÑÂàí„ÄÅÂÜ≥Á≠ñÂà∂ÂÆöÁ≠â„ÄÇÊú¨ÊñáÊ°£Á≥ªÁªüÊÄßÂú∞‰ªãÁªçÊ∏∏ÊàèAIÁöÑÁêÜËÆ∫Âü∫Á°Ä„ÄÅÁÆóÊ≥ïÂÆûÁé∞ÂíåÂÆûÈôÖÂ∫îÁî®„ÄÇ

## üìö ÁêÜËÆ∫Âü∫Á°Ä

### 1. Ë∑ØÂæÑËßÑÂàíÁÆóÊ≥ï

#### 1.1 A*ÁÆóÊ≥ï

A*ÁÆóÊ≥ïÁöÑËØÑ‰º∞ÂáΩÊï∞Ôºö

$$f(n) = g(n) + h(n)$$

ÂÖ∂‰∏≠ $g(n)$ ÊòØ‰ªéËµ∑ÁÇπÂà∞ËäÇÁÇπnÁöÑÂÆûÈôÖ‰ª£‰ª∑Ôºå$h(n)$ ÊòØ‰ªéËäÇÁÇπnÂà∞ÁõÆÊ†áÁöÑÂêØÂèëÂºè‰º∞ËÆ°„ÄÇ

#### 1.2 DijkstraÁÆóÊ≥ï

DijkstraÁÆóÊ≥ïÁöÑÊúÄÁü≠Ë∑ØÂæÑÔºö

$$d[v] = \min(d[v], d[u] + w(u,v))$$

ÂÖ∂‰∏≠ $w(u,v)$ ÊòØËæπ(u,v)ÁöÑÊùÉÈáç„ÄÇ

#### 1.3 ÂØºËà™ÁΩëÊ†º

ÂØºËà™ÁΩëÊ†ºÁöÑ‰∏âËßíÂΩ¢ÂâñÂàÜÔºö

$$T = \{t_1, t_2, \ldots, t_n\}$$

ÂÖ∂‰∏≠ÊØè‰∏™‰∏âËßíÂΩ¢ $t_i$ ÈÉΩÊòØÂèØÈÄöË°åÁöÑÂå∫Âüü„ÄÇ

### 2. ÂÜ≥Á≠ñÁêÜËÆ∫

#### 2.1 ÊïàÁî®ÁêÜËÆ∫

ÊïàÁî®ÂáΩÊï∞Ôºö

$$U(a) = \sum_{s \in S} P(s|a) \cdot V(s)$$

ÂÖ∂‰∏≠ $P(s|a)$ ÊòØÊâßË°åÂä®‰ΩúaÂêéÁä∂ÊÄÅsÁöÑÊ¶ÇÁéáÔºå$V(s)$ ÊòØÁä∂ÊÄÅsÁöÑ‰ª∑ÂÄº„ÄÇ

#### 2.2 ÂçöÂºàËÆ∫

Á∫≥‰ªÄÂùáË°°Ôºö

$$\forall i, \forall s_i': u_i(s_i^*, s_{-i}^*) \geq u_i(s_i', s_{-i}^*)$$

### 3. Êú∫Âô®Â≠¶‰π†

#### 3.1 Âº∫ÂåñÂ≠¶‰π†

Q-learningÊõ¥Êñ∞ËßÑÂàôÔºö

$$Q(s,a) \leftarrow Q(s,a) + \alpha[r + \gamma \max_{a'} Q(s',a') - Q(s,a)]$$

#### 3.2 Á•ûÁªèÁΩëÁªú

ÂâçÂêë‰º†Êí≠Ôºö

$$y = \sigma(W^T x + b)$$

## üîß HaskellÂÆûÁé∞

### 1. Ë∑ØÂæÑËßÑÂàí

```haskell
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleInstances #-}

module GameAI.Pathfinding where

import Data.List
import Data.Maybe
import Control.Monad.State
import Data.PriorityQueue
import Data.Graph
import Data.Vector (Vector)
import qualified Data.Vector as V

-- Ê∏∏Êàè‰∏ñÁïåÂùêÊ†á
type Position = (Int, Int)
type Cost = Double

-- Ê∏∏Êàè‰∏ñÁïå
data GameWorld = GameWorld
  { width :: Int
  , height :: Int
  , obstacles :: [Position]
  , terrain :: Matrix TerrainType
  } deriving Show

-- Âú∞ÂΩ¢Á±ªÂûã
data TerrainType = 
  Grass
  | Water
  | Mountain
  | Road
  deriving (Show, Eq)

-- Áü©ÈòµÁ±ªÂûã
data Matrix a = Matrix
  { rows :: Int
  , cols :: Int
  , elements :: [[a]]
  } deriving Show

-- ÂàõÂª∫Ê∏∏Êàè‰∏ñÁïå
createGameWorld :: Int -> Int -> GameWorld
createGameWorld w h = 
  let terrain = Matrix h w (replicate h (replicate w Grass))
  in GameWorld w h [] terrain

-- A*ÁÆóÊ≥ïËäÇÁÇπ
data AStarNode = AStarNode
  { position :: Position
  , gCost :: Cost
  , hCost :: Cost
  , fCost :: Cost
  , parent :: Maybe Position
  } deriving Show

-- A*ÁÆóÊ≥ïÂÆûÁé∞
aStarPathfinding :: GameWorld -> Position -> Position -> Maybe [Position]
aStarPathfinding world start goal = 
  let -- ÂàùÂßãÂåñÂºÄÊîæÂàóË°®ÂíåÂÖ≥Èó≠ÂàóË°®
      initialNode = AStarNode start 0 (heuristic start goal) (heuristic start goal) Nothing
      openList = singleton (fCost initialNode) initialNode
      closedList = []
      
      -- ÊâßË°åA*ÊêúÁ¥¢
      result = aStarSearch world openList closedList goal
  in result

-- A*ÊêúÁ¥¢
aStarSearch :: GameWorld -> PriorityQueue AStarNode -> [Position] -> Position -> Maybe [Position]
aStarSearch world openList closedList goal = 
  if isEmpty openList
  then Nothing  -- Ê≤°ÊúâÊâæÂà∞Ë∑ØÂæÑ
  else 
    let (currentNode, remainingOpen) = deleteMin openList
        currentPos = position currentNode
    in if currentPos == goal
       then Just (reconstructPath currentNode)  -- ÊâæÂà∞ÁõÆÊ†á
       else 
         let -- Â∞ÜÂΩìÂâçËäÇÁÇπÂä†ÂÖ•ÂÖ≥Èó≠ÂàóË°®
             newClosedList = currentPos : closedList
             
             -- Ëé∑ÂèñÈÇªÂ±ÖËäÇÁÇπ
             neighbors = getNeighbors world currentPos
             validNeighbors = filter (\pos -> not (pos `elem` newClosedList)) neighbors
             
             -- Â§ÑÁêÜÊØè‰∏™ÈÇªÂ±Ö
             updatedOpenList = foldl (\open neighbor -> 
                                       processNeighbor currentNode neighbor goal open) 
                                     remainingOpen validNeighbors
         in aStarSearch world updatedOpenList newClosedList goal

-- ÂêØÂèëÂºèÂáΩÊï∞ÔºàÊõºÂìàÈ°øË∑ùÁ¶ªÔºâ
heuristic :: Position -> Position -> Cost
heuristic (x1, y1) (x2, y2) = fromIntegral (abs (x1 - x2) + abs (y1 - y2))

-- Ëé∑ÂèñÈÇªÂ±ÖËäÇÁÇπ
getNeighbors :: GameWorld -> Position -> [Position]
getNeighbors world (x, y) = 
  let directions = [(0,1), (1,0), (0,-1), (-1,0)]  -- Âõõ‰∏™ÊñπÂêë
      neighbors = [(x+dx, y+dy) | (dx, dy) <- directions]
      validNeighbors = filter (isValidPosition world) neighbors
  in validNeighbors

-- Ê£ÄÊü•‰ΩçÁΩÆÊòØÂê¶ÊúâÊïà
isValidPosition :: GameWorld -> Position -> Bool
isValidPosition world (x, y) = 
  x >= 0 && x < width world && 
  y >= 0 && y < height world && 
  not ((x, y) `elem` obstacles world)

-- Â§ÑÁêÜÈÇªÂ±ÖËäÇÁÇπ
processNeighbor :: AStarNode -> Position -> Position -> PriorityQueue AStarNode -> PriorityQueue AStarQueue
processNeighbor currentNode neighbor goal openList = 
  let -- ËÆ°ÁÆó‰ªéËµ∑ÁÇπÁªèËøáÂΩìÂâçËäÇÁÇπÂà∞ÈÇªÂ±ÖÁöÑ‰ª£‰ª∑
      newGCost = gCost currentNode + getMovementCost currentNode neighbor
      
      -- Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂú®ÂºÄÊîæÂàóË°®‰∏≠
      existingNode = findNode openList neighbor
  in case existingNode of
       Just node -> 
         if newGCost < gCost node
         then -- Êõ¥Êñ∞ËäÇÁÇπ
              let updatedNode = node { gCost = newGCost, fCost = newGCost + hCost node, parent = Just (position currentNode) }
              in updateNode openList neighbor updatedNode
         else openList
       Nothing -> 
         -- Ê∑ªÂä†Êñ∞ËäÇÁÇπ
         let hCost = heuristic neighbor goal
             newNode = AStarNode neighbor newGCost hCost (newGCost + hCost) (Just (position currentNode))
         in insert (fCost newNode) newNode openList

-- Ëé∑ÂèñÁßªÂä®‰ª£‰ª∑
getMovementCost :: AStarNode -> Position -> Cost
getMovementCost _ _ = 1.0  -- ÁÆÄÂåñÔºöÁªü‰∏Ä‰ª£‰ª∑

-- ÈáçÂª∫Ë∑ØÂæÑ
reconstructPath :: AStarNode -> [Position]
reconstructPath node = 
  let path = reverse (buildPath node [])
  in path
  where buildPath (AStarNode pos _ _ _ Nothing) acc = pos : acc
        buildPath (AStarNode pos _ _ _ (Just parent)) acc = 
          buildPath (findParentNode parent) (pos : acc)

-- Êü•ÊâæÁà∂ËäÇÁÇπÔºàÁÆÄÂåñÂÆûÁé∞Ôºâ
findParentNode :: Position -> AStarNode
findParentNode pos = AStarNode pos 0 0 0 Nothing

-- ‰ºòÂÖàÁ∫ßÈòüÂàóÂÆûÁé∞
data PriorityQueue a = PriorityQueue [(Double, a)]
  deriving Show

-- ÂàõÂª∫Á©∫ÈòüÂàó
empty :: PriorityQueue a
empty = PriorityQueue []

-- Ê£ÄÊü•ÈòüÂàóÊòØÂê¶‰∏∫Á©∫
isEmpty :: PriorityQueue a -> Bool
isEmpty (PriorityQueue []) = True
isEmpty _ = False

-- ÊèíÂÖ•ÂÖÉÁ¥†
insert :: Double -> a -> PriorityQueue a -> PriorityQueue a
insert priority value (PriorityQueue queue) = 
  PriorityQueue (insertSorted (priority, value) queue)
  where insertSorted item [] = [item]
        insertSorted item@(p1, _) ((p2, v2):rest) = 
          if p1 <= p2
          then item : (p2, v2) : rest
          else (p2, v2) : insertSorted item rest

-- Âà†Èô§ÊúÄÂ∞èÂÖÉÁ¥†
deleteMin :: PriorityQueue a -> (a, PriorityQueue a)
deleteMin (PriorityQueue ((_, value):rest)) = (value, PriorityQueue rest)
deleteMin (PriorityQueue []) = error "Empty queue"

-- Êü•ÊâæËäÇÁÇπ
findNode :: PriorityQueue AStarNode -> Position -> Maybe AStarNode
findNode (PriorityQueue queue) pos = 
  case find (\(_, node) -> position node == pos) queue of
    Just (_, node) -> Just node
    Nothing -> Nothing

-- Êõ¥Êñ∞ËäÇÁÇπ
updateNode :: PriorityQueue AStarNode -> Position -> AStarNode -> PriorityQueue AStarNode
updateNode (PriorityQueue queue) pos newNode = 
  let filtered = filter (\(_, node) -> position node /= pos) queue
  in PriorityQueue (insertSorted (fCost newNode, newNode) filtered)
  where insertSorted item [] = [item]
        insertSorted item@(p1, _) ((p2, v2):rest) = 
          if p1 <= p2
          then item : (p2, v2) : rest
          else (p2, v2) : insertSorted item rest

-- Âçï‰æãÈòüÂàó
singleton :: Double -> a -> PriorityQueue a
singleton priority value = PriorityQueue [(priority, value)]
```

### 2. ÂÜ≥Á≠ñÊ†ë

```haskell
-- ÂÜ≥Á≠ñÊ†ëËäÇÁÇπ
data DecisionNode = 
  ActionNode GameAction
  | ConditionNode Condition DecisionNode DecisionNode
  deriving Show

-- Ê∏∏ÊàèÂä®‰Ωú
data GameAction = 
  Move Position
  | Attack Position
  | Defend
  | UseItem String
  | Wait
  deriving Show

-- Êù°‰ª∂
data Condition = 
  HealthBelow Double
  | EnemyNearby Position
  | HasItem String
  | IsInDanger
  | CanAttack Position
  deriving Show

-- Ê∏∏ÊàèÁä∂ÊÄÅ
data GameState = GameState
  { playerPosition :: Position
  , playerHealth :: Double
  , playerItems :: [String]
  , enemies :: [Enemy]
  , world :: GameWorld
  } deriving Show

-- Êïå‰∫∫
data Enemy = Enemy
  { enemyPosition :: Position
  , enemyHealth :: Double
  , enemyType :: EnemyType
  } deriving Show

-- Êïå‰∫∫Á±ªÂûã
data EnemyType = 
  Goblin
  | Orc
  | Dragon
  deriving Show

-- ÂÜ≥Á≠ñÊ†ë
data DecisionTree = DecisionTree
  { root :: DecisionNode
  , name :: String
  } deriving Show

-- ÂàõÂª∫ÁÆÄÂçïÂÜ≥Á≠ñÊ†ë
createSimpleDecisionTree :: DecisionTree
createSimpleDecisionTree = 
  let -- Ê†πËäÇÁÇπÔºöÊ£ÄÊü•ÂÅ•Â∫∑ÂÄº
      healthCheck = ConditionNode (HealthBelow 0.3) 
                    (ActionNode Defend)  -- ÂÅ•Â∫∑ÂÄº‰ΩéÊó∂Èò≤Âæ°
                    (ConditionNode (EnemyNearby (0,0)) 
                      (ActionNode (Attack (0,0)))  -- ÊúâÊïå‰∫∫Êó∂ÊîªÂáª
                      (ActionNode (Move (1,1))))   -- Âê¶ÂàôÁßªÂä®
  in DecisionTree healthCheck "SimpleAI"

-- ÊâßË°åÂÜ≥Á≠ñÊ†ë
executeDecisionTree :: DecisionTree -> GameState -> GameAction
executeDecisionTree (DecisionTree root _) state = 
  evaluateNode root state

-- ËØÑ‰º∞ËäÇÁÇπ
evaluateNode :: DecisionNode -> GameState -> GameAction
evaluateNode (ActionNode action) _ = action
evaluateNode (ConditionNode condition trueBranch falseBranch) state = 
  if evaluateCondition condition state
  then evaluateNode trueBranch state
  else evaluateNode falseBranch state

-- ËØÑ‰º∞Êù°‰ª∂
evaluateCondition :: Condition -> GameState -> Bool
evaluateCondition condition state = case condition of
  HealthBelow threshold -> playerHealth state < threshold
  EnemyNearby pos -> any (\enemy -> distance (playerPosition state) (enemyPosition enemy) < 5) (enemies state)
  HasItem item -> item `elem` playerItems state
  IsInDanger -> any (\enemy -> distance (playerPosition state) (enemyPosition enemy) < 2) (enemies state)
  CanAttack pos -> distance (playerPosition state) pos <= 1

-- ËÆ°ÁÆóË∑ùÁ¶ª
distance :: Position -> Position -> Double
distance (x1, y1) (x2, y2) = sqrt (fromIntegral ((x1-x2)^2 + (y1-y2)^2))

-- ÂàõÂª∫Â§çÊùÇÂÜ≥Á≠ñÊ†ë
createComplexDecisionTree :: DecisionTree
createComplexDecisionTree = 
  let -- Ê£ÄÊü•ÊòØÂê¶ÊúâÊ≤ªÁñóÁâ©ÂìÅ
      hasHealingItem = ConditionNode (HasItem "Potion") 
                        (ConditionNode (HealthBelow 0.5) 
                          (ActionNode (UseItem "Potion"))  -- ‰ΩøÁî®Ê≤ªÁñóÁâ©ÂìÅ
                          (combatDecisionTree))           -- ËøõÂÖ•ÊàòÊñóÂÜ≥Á≠ñ
                        (combatDecisionTree)              -- Ê≤°ÊúâÊ≤ªÁñóÁâ©ÂìÅÔºåÁõ¥Êé•ÊàòÊñó
  in DecisionTree hasHealingItem "ComplexAI"

-- ÊàòÊñóÂÜ≥Á≠ñÊ†ë
combatDecisionTree :: DecisionNode
combatDecisionTree = 
  ConditionNode IsInDanger
    (ConditionNode (HasItem "Shield") 
      (ActionNode Defend)  -- ÊúâÁõæÁâåÊó∂Èò≤Âæ°
      (ActionNode (Move (0,1))))  -- Ê≤°ÊúâÁõæÁâåÊó∂ÈÄÉË∑ë
    (ConditionNode (EnemyNearby (0,0)) 
      (ActionNode (Attack (0,0)))  -- ÊîªÂáªÊïå‰∫∫
      (ActionNode (Move (1,0)))    -- Êé¢Á¥¢Âú∞Âõæ
    )

-- Âä®ÊÄÅÂÜ≥Á≠ñÊ†ë
data DynamicDecisionTree = DynamicDecisionTree
  { staticTree :: DecisionTree
  , learningRate :: Double
  , experience :: [(GameState, GameAction, Double)]  -- Áä∂ÊÄÅ„ÄÅÂä®‰Ωú„ÄÅÂ•ñÂä±
  } deriving Show

-- ÂàõÂª∫Âä®ÊÄÅÂÜ≥Á≠ñÊ†ë
createDynamicDecisionTree :: DecisionTree -> Double -> DynamicDecisionTree
createDynamicDecisionTree tree rate = 
  DynamicDecisionTree tree rate []

-- Â≠¶‰π†Êñ∞ÁªèÈ™å
learnFromExperience :: DynamicDecisionTree -> GameState -> GameAction -> Double -> DynamicDecisionTree
learnFromExperience (DynamicDecisionTree tree rate exp) state action reward = 
  let newExperience = (state, action, reward) : exp
      -- ÈôêÂà∂ÁªèÈ™åÊï∞Èáè
      limitedExp = take 1000 newExperience
  in DynamicDecisionTree tree rate limitedExp

-- Âü∫‰∫éÁªèÈ™åÊîπËøõÂÜ≥Á≠ñ
improveDecision :: DynamicDecisionTree -> GameState -> GameAction
improveDecision (DynamicDecisionTree tree _ exp) state = 
  let -- Êü•ÊâæÁõ∏‰ººÁä∂ÊÄÅÁöÑÁªèÈ™å
      similarExperiences = filter (\(expState, _, _) -> isSimilarState state expState) exp
      
      -- Â¶ÇÊûúÊ≤°ÊúâÁõ∏‰ººÁªèÈ™åÔºå‰ΩøÁî®ÈùôÊÄÅÂÜ≥Á≠ñÊ†ë
      baseAction = executeDecisionTree tree state
  in if null similarExperiences
     then baseAction
     else 
       let -- ÈÄâÊã©Â•ñÂä±ÊúÄÈ´òÁöÑÂä®‰Ωú
           bestExperience = maximumBy (\(_, _, r1) (_, _, r2) -> compare r1 r2) similarExperiences
           (_, bestAction, _) = bestExperience
       in bestAction

-- Ê£ÄÊü•Áä∂ÊÄÅÁõ∏‰ººÊÄß
isSimilarState :: GameState -> GameState -> Bool
isSimilarState state1 state2 = 
  let healthDiff = abs (playerHealth state1 - playerHealth state2)
      positionDiff = distance (playerPosition state1) (playerPosition state2)
  in healthDiff < 0.2 && positionDiff < 3.0
```

### 3. Ë°å‰∏∫Ê†ë

```haskell
-- Ë°å‰∏∫Ê†ëËäÇÁÇπ
data BehaviorNode = 
  SequenceNode [BehaviorNode]
  | SelectorNode [BehaviorNode]
  | ActionNode GameAction
  | ConditionNode Condition
  | DecoratorNode BehaviorDecorator BehaviorNode
  deriving Show

-- Ë°å‰∏∫Ë£ÖÈ•∞Âô®
data BehaviorDecorator = 
  Inverter
  | Repeater Int
  | UntilSuccess
  | UntilFailure
  deriving Show

-- Ë°å‰∏∫Áä∂ÊÄÅ
data BehaviorStatus = 
  Success
  | Failure
  | Running
  deriving (Show, Eq)

-- Ë°å‰∏∫Ê†ë
data BehaviorTree = BehaviorTree
  { root :: BehaviorNode
  , name :: String
  } deriving Show

-- ÂàõÂª∫Ë°å‰∏∫Ê†ë
createBehaviorTree :: BehaviorTree
createBehaviorTree = 
  let -- Ê†πËäÇÁÇπÔºöÈÄâÊã©Âô®
      root = SelectorNode [
        -- ‰ºòÂÖàÁ∫ß1ÔºöÊ£ÄÊü•ÂÅ•Â∫∑ÂÄº
        SequenceNode [
          ConditionNode (HealthBelow 0.3),
          ActionNode (UseItem "Potion")
        ],
        -- ‰ºòÂÖàÁ∫ß2ÔºöÊîªÂáªÊïå‰∫∫
        SequenceNode [
          ConditionNode (EnemyNearby (0,0)),
          ActionNode (Attack (0,0))
        ],
        -- ‰ºòÂÖàÁ∫ß3ÔºöÊé¢Á¥¢
        ActionNode (Move (1,0))
      ]
  in BehaviorTree root "CombatAI"

-- ÊâßË°åË°å‰∏∫Ê†ë
executeBehaviorTree :: BehaviorTree -> GameState -> (BehaviorStatus, GameState)
executeBehaviorTree (BehaviorTree root _) state = 
  executeNode root state

-- ÊâßË°åËäÇÁÇπ
executeNode :: BehaviorNode -> GameState -> (BehaviorStatus, GameState)
executeNode node state = case node of
  SequenceNode children -> executeSequence children state
  SelectorNode children -> executeSelector children state
  ActionNode action -> executeAction action state
  ConditionNode condition -> executeCondition condition state
  DecoratorNode decorator child -> executeDecorator decorator child state

-- ÊâßË°åÂ∫èÂàóËäÇÁÇπ
executeSequence :: [BehaviorNode] -> GameState -> (BehaviorStatus, GameState)
executeSequence [] state = (Success, state)
executeSequence (child:children) state = 
  let (status, newState) = executeNode child state
  in case status of
       Failure -> (Failure, newState)
       Success -> executeSequence children newState
       Running -> (Running, newState)

-- ÊâßË°åÈÄâÊã©Âô®ËäÇÁÇπ
executeSelector :: [BehaviorNode] -> GameState -> (BehaviorStatus, GameState)
executeSelector [] state = (Failure, state)
executeSelector (child:children) state = 
  let (status, newState) = executeNode child state
  in case status of
       Success -> (Success, newState)
       Failure -> executeSelector children newState
       Running -> (Running, newState)

-- ÊâßË°åÂä®‰Ωú
executeAction :: GameAction -> GameState -> (BehaviorStatus, GameState)
executeAction action state = 
  let newState = applyAction action state
  in (Success, newState)

-- Â∫îÁî®Âä®‰Ωú
applyAction :: GameAction -> GameState -> GameState
applyAction action state = case action of
  Move pos -> state { playerPosition = pos }
  Attack pos -> 
    let -- ÂáèÂ∞ëÊïå‰∫∫ÂÅ•Â∫∑ÂÄº
        updatedEnemies = map (\enemy -> 
                              if enemyPosition enemy == pos
                              then enemy { enemyHealth = max 0 (enemyHealth enemy - 10) }
                              else enemy) (enemies state)
    in state { enemies = updatedEnemies }
  Defend -> state  -- Èò≤Âæ°‰∏çÊîπÂèòÁä∂ÊÄÅ
  UseItem item -> 
    let -- ‰ΩøÁî®Áâ©ÂìÅ
        updatedItems = filter (/= item) (playerItems state)
        updatedHealth = if item == "Potion" 
                        then min 100 (playerHealth state + 30)
                        else playerHealth state
    in state { playerItems = updatedItems, playerHealth = updatedHealth }
  Wait -> state

-- ÊâßË°åÊù°‰ª∂
executeCondition :: Condition -> GameState -> (BehaviorStatus, GameState)
executeCondition condition state = 
  let result = evaluateCondition condition state
  in if result then (Success, state) else (Failure, state)

-- ÊâßË°åË£ÖÈ•∞Âô®
executeDecorator :: BehaviorDecorator -> BehaviorNode -> GameState -> (BehaviorStatus, GameState)
executeDecorator decorator child state = case decorator of
  Inverter -> 
    let (status, newState) = executeNode child state
    in case status of
         Success -> (Failure, newState)
         Failure -> (Success, newState)
         Running -> (Running, newState)
  
  Repeater count -> 
    if count <= 0
    then (Success, state)
    else 
      let (status, newState) = executeNode child state
      in case status of
           Success -> executeDecorator (Repeater (count-1)) child newState
           Failure -> (Failure, newState)
           Running -> (Running, newState)
  
  UntilSuccess -> 
    let (status, newState) = executeNode child state
    in case status of
         Success -> (Success, newState)
         Failure -> executeDecorator UntilSuccess child newState
         Running -> (Running, newState)
  
  UntilFailure -> 
    let (status, newState) = executeNode child state
    in case status of
         Failure -> (Failure, newState)
         Success -> executeDecorator UntilFailure child newState
         Running -> (Running, newState)

-- ÂàõÂª∫Â§çÊùÇË°å‰∏∫Ê†ë
createComplexBehaviorTree :: BehaviorTree
createComplexBehaviorTree = 
  let -- ‰∏ªÈÄâÊã©Âô®
      mainSelector = SelectorNode [
        -- Á¥ßÊÄ•ÊÉÖÂÜµÂ§ÑÁêÜ
        SequenceNode [
          ConditionNode IsInDanger,
          SelectorNode [
            ActionNode Defend,
            ActionNode (UseItem "TeleportScroll")
          ]
        ],
        -- ÊàòÊñóË°å‰∏∫
        SequenceNode [
          ConditionNode (EnemyNearby (0,0)),
          SelectorNode [
            SequenceNode [
              ConditionNode (HasItem "Sword"),
              ActionNode (Attack (0,0))
            ],
            ActionNode (Move (0,1))  -- ÈÄÉË∑ë
          ]
        ],
        -- Êé¢Á¥¢Ë°å‰∏∫
        DecoratorNode (Repeater 3) (
          SelectorNode [
            ActionNode (Move (1,0)),
            ActionNode (Move (0,1)),
            ActionNode (Move (-1,0)),
            ActionNode (Move (0,-1))
          ]
        )
      ]
  in BehaviorTree mainSelector "ComplexBehaviorAI"
```

### 4. Áä∂ÊÄÅÊú∫

```haskell
-- Áä∂ÊÄÅÊú∫Áä∂ÊÄÅ
data AIState = 
  Idle
  | Patrol
  | Chase
  | Attack
  | Flee
  | Search
  deriving (Show, Eq)

-- Áä∂ÊÄÅËΩ¨Êç¢
data StateTransition = StateTransition
  { fromState :: AIState
  , toState :: AIState
  , condition :: GameState -> Bool
  , priority :: Int
  } deriving Show

-- Áä∂ÊÄÅÊú∫
data StateMachine = StateMachine
  { currentState :: AIState
  , transitions :: [StateTransition]
  , stateActions :: [(AIState, GameAction)]
  } deriving Show

-- ÂàõÂª∫Áä∂ÊÄÅÊú∫
createStateMachine :: StateMachine
createStateMachine = 
  let transitions = [
        StateTransition Idle Patrol (\state -> True) 1,
        StateTransition Patrol Chase (\state -> any (\enemy -> distance (playerPosition state) (enemyPosition enemy) < 5) (enemies state)) 2,
        StateTransition Chase Attack (\state -> any (\enemy -> distance (playerPosition state) (enemyPosition enemy) < 1) (enemies state)) 3,
        StateTransition Attack Flee (\state -> playerHealth state < 0.3) 4,
        StateTransition Flee Search (\state -> not (any (\enemy -> distance (playerPosition state) (enemyPosition enemy) < 3) (enemies state))) 1,
        StateTransition Search Patrol (\state -> True) 1
      ]
      
      actions = [
        (Idle, Wait),
        (Patrol, Move (1,0)),
        (Chase, Move (0,0)),  -- ÊúùÂêëÊïå‰∫∫ÁßªÂä®
        (Attack, Attack (0,0)),
        (Flee, Move (-1,-1)),
        (Search, Move (0,1))
      ]
  in StateMachine Idle transitions actions

-- ÊâßË°åÁä∂ÊÄÅÊú∫
executeStateMachine :: StateMachine -> GameState -> (GameAction, StateMachine)
executeStateMachine machine state = 
  let -- Ê£ÄÊü•Áä∂ÊÄÅËΩ¨Êç¢
      validTransitions = filter (\trans -> 
                                  fromState trans == currentState machine && 
                                  condition trans state) (transitions machine)
      
      -- ÈÄâÊã©‰ºòÂÖàÁ∫ßÊúÄÈ´òÁöÑËΩ¨Êç¢
      bestTransition = if null validTransitions
                       then Nothing
                       else Just (maximumBy (\a b -> compare (priority a) (priority b)) validTransitions)
      
      -- Êõ¥Êñ∞Áä∂ÊÄÅ
      newState = case bestTransition of
                   Just trans -> toState trans
                   Nothing -> currentState machine
      
      -- ÊâßË°åÂΩìÂâçÁä∂ÊÄÅÁöÑÂä®‰Ωú
      action = getStateAction newState (stateActions machine)
      
      updatedMachine = machine { currentState = newState }
  in (action, updatedMachine)

-- Ëé∑ÂèñÁä∂ÊÄÅÂä®‰Ωú
getStateAction :: AIState -> [(AIState, GameAction)] -> GameAction
getStateAction state actions = 
  case lookup state actions of
    Just action -> action
    Nothing -> Wait  -- ÈªòËÆ§Âä®‰Ωú
```

## üìä Â∫îÁî®ÂÆû‰æã

### 1. ËßíËâ≤AIÁ≥ªÁªü

```haskell
-- ËßíËâ≤AI
data CharacterAI = CharacterAI
  { decisionTree :: DecisionTree
  , behaviorTree :: BehaviorTree
  , stateMachine :: StateMachine
  , pathfinding :: GameWorld -> Position -> Position -> Maybe [Position]
  } deriving Show

-- ÂàõÂª∫ËßíËâ≤AI
createCharacterAI :: CharacterAI
createCharacterAI = 
  CharacterAI 
    createSimpleDecisionTree
    createBehaviorTree
    createStateMachine
    aStarPathfinding

-- ÊâßË°åËßíËâ≤AI
executeCharacterAI :: CharacterAI -> GameState -> GameAction
executeCharacterAI ai state = 
  let -- ‰ΩøÁî®ÂÜ≥Á≠ñÊ†ë
      decisionAction = executeDecisionTree (decisionTree ai) state
      
      -- ‰ΩøÁî®Ë°å‰∏∫Ê†ë
      (behaviorStatus, _) = executeBehaviorTree (behaviorTree ai) state
      
      -- ‰ΩøÁî®Áä∂ÊÄÅÊú∫
      (stateAction, _) = executeStateMachine (stateMachine ai) state
      
      -- ÈÄâÊã©ÊúÄÁªàÂä®‰ΩúÔºàÁÆÄÂåñÔºö‰ºòÂÖà‰ΩøÁî®ÂÜ≥Á≠ñÊ†ëÔºâ
      finalAction = decisionAction
  in finalAction
```

### 2. Áæ§‰ΩìAI

```haskell
-- Áæ§‰ΩìAI
data SwarmAI = SwarmAI
  { agents :: [Agent]
  , flockingRules :: [FlockingRule]
  } deriving Show

-- Êô∫ËÉΩ‰Ωì
data Agent = Agent
  { agentId :: Int
  , agentPosition :: Position
  , agentVelocity :: (Double, Double)
  , agentType :: AgentType
  } deriving Show

-- Êô∫ËÉΩ‰ΩìÁ±ªÂûã
data AgentType = 
  Boid
  | Predator
  | Prey
  deriving Show

-- Áæ§‰ΩìËßÑÂàô
data FlockingRule = 
  Separation Double  -- ÂàÜÁ¶ªË∑ùÁ¶ª
  | Alignment Double  -- ÂØπÈΩêÂº∫Â∫¶
  | Cohesion Double   -- ÂáùËÅöÂº∫Â∫¶
  deriving Show

-- ÂàõÂª∫Áæ§‰ΩìAI
createSwarmAI :: Int -> SwarmAI
createSwarmAI numAgents = 
  let agents = [Agent i (i `mod` 10, i `div` 10) (0.0, 0.0) Boid | i <- [0..numAgents-1]]
      rules = [Separation 2.0, Alignment 0.5, Cohesion 0.3]
  in SwarmAI agents rules

-- ÊâßË°åÁæ§‰ΩìAI
executeSwarmAI :: SwarmAI -> SwarmAI
executeSwarmAI swarm = 
  let updatedAgents = map (updateAgent swarm) (agents swarm)
  in swarm { agents = updatedAgents }

-- Êõ¥Êñ∞Êô∫ËÉΩ‰Ωì
updateAgent :: SwarmAI -> Agent -> Agent
updateAgent swarm agent = 
  let -- ËÆ°ÁÆóÁæ§‰ΩìÂäõ
      separationForce = calculateSeparation agent (agents swarm)
      alignmentForce = calculateAlignment agent (agents swarm)
      cohesionForce = calculateCohesion agent (agents swarm)
      
      -- ÂêàÊàêÂäõ
      totalForce = addForces [separationForce, alignmentForce, cohesionForce]
      
      -- Êõ¥Êñ∞‰ΩçÁΩÆÂíåÈÄüÂ∫¶
      newVelocity = addVectors (agentVelocity agent) totalForce
      newPosition = addVectors (agentPosition agent) newVelocity
  in agent { agentPosition = newPosition, agentVelocity = newVelocity }

-- ËÆ°ÁÆóÂàÜÁ¶ªÂäõ
calculateSeparation :: Agent -> [Agent] -> (Double, Double)
calculateSeparation agent allAgents = 
  let nearbyAgents = filter (\a -> agentId a /= agentId agent && 
                                   distance (agentPosition agent) (agentPosition a) < 2.0) allAgents
      separationVectors = map (\a -> 
                                let diff = subtractVectors (agentPosition agent) (agentPosition a)
                                    dist = distance (agentPosition agent) (agentPosition a)
                                in if dist > 0
                                   then scaleVector (1.0 / dist) diff
                                   else (0.0, 0.0)) nearbyAgents
  in if null separationVectors
     then (0.0, 0.0)
     else scaleVector (1.0 / fromIntegral (length separationVectors)) (sumVectors separationVectors)

-- ËÆ°ÁÆóÂØπÈΩêÂäõ
calculateAlignment :: Agent -> [Agent] -> (Double, Double)
calculateAlignment agent allAgents = 
  let nearbyAgents = filter (\a -> agentId a /= agentId agent && 
                                   distance (agentPosition agent) (agentPosition a) < 5.0) allAgents
      averageVelocity = if null nearbyAgents
                        then (0.0, 0.0)
                        else scaleVector (1.0 / fromIntegral (length nearbyAgents)) 
                                        (sumVectors (map agentVelocity nearbyAgents))
  in averageVelocity

-- ËÆ°ÁÆóÂáùËÅöÂäõ
calculateCohesion :: Agent -> [Agent] -> (Double, Double)
calculateCohesion agent allAgents = 
  let nearbyAgents = filter (\a -> agentId a /= agentId agent && 
                                   distance (agentPosition agent) (agentPosition a) < 5.0) allAgents
      centerOfMass = if null nearbyAgents
                     then agentPosition agent
                     else scaleVector (1.0 / fromIntegral (length nearbyAgents)) 
                                     (sumVectors (map agentPosition nearbyAgents))
      cohesionVector = subtractVectors centerOfMass (agentPosition agent)
  in cohesionVector

-- ÂêëÈáèÊìç‰Ωú
addVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)

subtractVectors :: (Double, Double) -> (Double, Double) -> (Double, Double)
subtractVectors (x1, y1) (x2, y2) = (x1 - x2, y1 - y2)

scaleVector :: Double -> (Double, Double) -> (Double, Double)
scaleVector s (x, y) = (s * x, s * y)

sumVectors :: [(Double, Double)] -> (Double, Double)
sumVectors = foldl addVectors (0.0, 0.0)

addForces :: [(Double, Double)] -> (Double, Double)
addForces = sumVectors
```

### 3. ÊàòÊúØAI

```haskell
-- ÊàòÊúØAI
data TacticalAI = TacticalAI
  { formation :: Formation
  , tactics :: [Tactic]
  , currentTactic :: Maybe Tactic
  } deriving Show

-- ÈòµÂûã
data Formation = 
  LineFormation
  | CircleFormation
  | WedgeFormation
  deriving Show

-- ÊàòÊúØ
data Tactic = 
  Flanking
  | Ambush
  | Defensive
  | Aggressive
  deriving Show

-- ÂàõÂª∫ÊàòÊúØAI
createTacticalAI :: TacticalAI
createTacticalAI = 
  TacticalAI LineFormation [Flanking, Ambush, Defensive, Aggressive] Nothing

-- ÊâßË°åÊàòÊúØAI
executeTacticalAI :: TacticalAI -> GameState -> [GameAction]
executeTacticalAI ai state = 
  let -- ÈÄâÊã©ÊàòÊúØ
      selectedTactic = selectTactic ai state
      
      -- ÊâßË°åÊàòÊúØ
      actions = executeTactic selectedTactic state
  in actions

-- ÈÄâÊã©ÊàòÊúØ
selectTactic :: TacticalAI -> GameState -> Tactic
selectTactic ai state = 
  let enemyCount = length (enemies state)
      playerHealth = playerHealth state
  in if playerHealth < 0.3
     then Defensive
     else if enemyCount > 3
          then Flanking
          else Aggressive

-- ÊâßË°åÊàòÊúØ
executeTactic :: Tactic -> GameState -> [GameAction]
executeTactic tactic state = case tactic of
  Flanking -> [Move (1,1), Attack (0,0)]
  Ambush -> [Wait, Attack (0,0)]
  Defensive -> [Defend, Move (0,1)]
  Aggressive -> [Attack (0,0), Move (1,0)]
```

## üîó Áõ∏ÂÖ≥ÁêÜËÆ∫

- [Ê∏∏ÊàèÂºïÊìéÊû∂ÊûÑ](../08-Game-Development/01-Game-Engine-Architecture.md)
- [ÂõæÂΩ¢Ê∏≤ÊüìÁêÜËÆ∫](../07-Computer-Graphics/01-Rendering-Theory.md)
- [Áâ©ÁêÜ‰ªøÁúüÁêÜËÆ∫](../07-Computer-Graphics/03-Physics-Simulation.md)
- [Êú∫Âô®Â≠¶‰π†ÁêÜËÆ∫](../14-Machine-Learning/01-Supervised-Learning.md)
- [‰ºòÂåñÁÆóÊ≥ïÁêÜËÆ∫](../10-Mathematical-Physics/03-Optimization-Theory.md)

## üìö ÂèÇËÄÉÊñáÁåÆ

1. Millington, I., & Funge, J. (2009). *Artificial Intelligence for Games*. CRC Press.
2. Buckland, M. (2004). *Programming Game AI by Example*. Wordware Publishing.
3. LaMothe, A. (2002). *Tricks of the Windows Game Programming Gurus*. Sams.

---

**ÊñáÊ°£ÁâàÊú¨**: 1.0.0  
**Áª¥Êä§ËÄÖ**: AI Assistant  
**ÊúÄÂêéÊõ¥Êñ∞**: 2024Âπ¥12Êúà19Êó•
