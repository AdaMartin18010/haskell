# 定理证明示例 - Haskell实现

## 1. 自然数归纳法

### 理论背景

自然数归纳法是数学证明的基本方法，在Haskell中可以通过递归函数来体现。

### Haskell实现

```haskell
-- 自然数数据类型
data Nat = Zero | Succ Nat

-- 自然数加法
add :: Nat -> Nat -> Nat
add Zero n = n
add (Succ m) n = Succ (add m n)

-- 自然数乘法
mult :: Nat -> Nat -> Nat
mult Zero _ = Zero
mult (Succ m) n = add n (mult m n)

-- 自然数相等
eqNat :: Nat -> Nat -> Bool
eqNat Zero Zero = True
eqNat Zero (Succ _) = False
eqNat (Succ _) Zero = False
eqNat (Succ m) (Succ n) = eqNat m n

-- 使用示例
two = Succ (Succ Zero)
three = Succ two
five = add two three  -- Succ (Succ (Succ (Succ (Succ Zero))))
```

### 形式化证明

**定理**：加法结合律
对于任何自然数a, b, c，有 `add (add a b) c = add a (add b c)`

**证明**：

```haskell
-- 对a进行归纳
-- 基础情况：a = Zero
add (add Zero b) c = add b c = add Zero (add b c)

-- 归纳步骤：假设 add (add a b) c = add a (add b c)
-- 证明 add (add (Succ a) b) c = add (Succ a) (add b c)
add (add (Succ a) b) c 
= add (Succ (add a b)) c
= Succ (add (add a b) c)
= Succ (add a (add b c))  -- 归纳假设
= add (Succ a) (add b c)
```

## 2. 列表归纳法

### 理论背景

列表归纳法是函数式编程中常用的证明方法。

### Haskell实现

```haskell
-- 列表长度
length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs

-- 列表连接
append :: [a] -> [a] -> [a]
append [] ys = ys
append (x:xs) ys = x : append xs ys

-- 列表反转
reverse :: [a] -> [a]
reverse [] = []
reverse (x:xs) = reverse xs `append` [x]

-- 列表映射
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs

-- 使用示例
example1 = append [1, 2] [3, 4]  -- [1, 2, 3, 4]
example2 = reverse [1, 2, 3]     -- [3, 2, 1]
example3 = map (+1) [1, 2, 3]    -- [2, 3, 4]
```

### 形式化证明

**定理**：append结合律
对于任何列表xs, ys, zs，有 `append (append xs ys) zs = append xs (append ys zs)`

**证明**：

```haskell
-- 对xs进行归纳
-- 基础情况：xs = []
append (append [] ys) zs = append ys zs = append [] (append ys zs)

-- 归纳步骤：假设 append (append xs ys) zs = append xs (append ys zs)
-- 证明 append (append (x:xs) ys) zs = append (x:xs) (append ys zs)
append (append (x:xs) ys) zs
= append (x : append xs ys) zs
= x : append (append xs ys) zs
= x : append xs (append ys zs)  -- 归纳假设
= append (x:xs) (append ys zs)
```

## 3. 类型安全证明

### 理论背景

Haskell的类型系统提供了编译时的类型安全保证。

### Haskell实现

```haskell
-- 类型安全的函数
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

-- 类型安全的除法
safeDiv :: Double -> Double -> Maybe Double
safeDiv _ 0 = Nothing
safeDiv x y = Just (x / y)

-- 类型安全的查找
lookup :: Eq a => a -> [(a, b)] -> Maybe b
lookup _ [] = Nothing
lookup key ((k, v):xs)
    | key == k = Just v
    | otherwise = lookup key xs

-- 使用示例
example4 = safeHead [1, 2, 3]  -- Just 1
example5 = safeHead []         -- Nothing
example6 = safeDiv 10 2        -- Just 5.0
example7 = safeDiv 10 0        -- Nothing
```

### 形式化证明

**定理**：类型安全
如果表达式e有类型τ，则e不会产生类型错误。

**证明**：

```haskell
-- 类型推导规则
-- 变量规则：x:τ ∈ Γ
--           --------
--           Γ ⊢ x:τ

-- 应用规则：Γ ⊢ e1:τ1→τ2  Γ ⊢ e2:τ1
--           ------------------------
--           Γ ⊢ e1 e2:τ2

-- 抽象规则：Γ,x:τ1 ⊢ e:τ2
--           --------------
--           Γ ⊢ λx.e:τ1→τ2

-- 由于所有类型推导规则都保持类型安全
-- 因此类型化的表达式不会产生类型错误
```

## 4. 程序等价性证明

### 理论背景

程序等价性证明是形式化方法中的重要内容。

### Haskell实现

```haskell
-- 两种实现方式
-- 方式1：使用foldr
sum1 :: Num a => [a] -> a
sum1 = foldr (+) 0

-- 方式2：使用递归
sum2 :: Num a => [a] -> a
sum2 [] = 0
sum2 (x:xs) = x + sum2 xs

-- 方式3：使用foldl
sum3 :: Num a => [a] -> a
sum3 = foldl (+) 0

-- 使用示例
example8 = sum1 [1, 2, 3, 4, 5]  -- 15
example9 = sum2 [1, 2, 3, 4, 5]  -- 15
example10 = sum3 [1, 2, 3, 4, 5] -- 15
```

### 形式化证明

**定理**：sum1和sum2等价
对于任何数值列表xs，有 `sum1 xs = sum2 xs`

**证明**：

```haskell
-- 对xs进行归纳
-- 基础情况：xs = []
sum1 [] = foldr (+) 0 [] = 0 = sum2 []

-- 归纳步骤：假设 sum1 xs = sum2 xs
-- 证明 sum1 (x:xs) = sum2 (x:xs)
sum1 (x:xs) = foldr (+) 0 (x:xs) = x + foldr (+) 0 xs = x + sum1 xs
sum2 (x:xs) = x + sum2 xs

-- 由归纳假设 sum1 xs = sum2 xs
-- 因此 sum1 (x:xs) = sum2 (x:xs)
```

## 5. 算法正确性证明

### 理论背景

算法正确性证明确保算法满足其规范。

### Haskell实现

```haskell
-- 最大公约数算法
gcd :: Integral a => a -> a -> a
gcd a 0 = a
gcd a b = gcd b (a `mod` b)

-- 最小公倍数
lcm :: Integral a => a -> a -> a
lcm a b = (a * b) `div` gcd a b

-- 判断素数
isPrime :: Integral a => a -> Bool
isPrime n
    | n < 2 = False
    | n == 2 = True
    | even n = False
    | otherwise = not (any (\d -> n `mod` d == 0) [3, 5..sqrtN])
    where sqrtN = floor (sqrt (fromIntegral n))

-- 使用示例
example11 = gcd 48 18  -- 6
example12 = lcm 12 18  -- 36
example13 = isPrime 17 -- True
example14 = isPrime 24 -- False
```

### 形式化证明

**定理**：GCD算法的正确性
对于任何正整数a, b，gcd a b返回a和b的最大公约数。

**证明**：

```haskell
-- 基于欧几里得算法的正确性
-- 关键性质：gcd(a, b) = gcd(b, a mod b)

-- 基础情况：b = 0
gcd a 0 = a  -- a是a和0的最大公约数

-- 归纳步骤：假设gcd b (a mod b)正确
-- 由于gcd(a, b) = gcd(b, a mod b)
-- 因此gcd a b = gcd b (a mod b)是正确的
```

## 6. 数据结构不变性证明

### 理论背景

数据结构不变性确保数据结构在操作后保持其性质。

### Haskell实现

```haskell
-- 二叉搜索树
data BST a = Empty | Node a (BST a) (BST a)

-- 插入元素
insert :: Ord a => a -> BST a -> BST a
insert x Empty = Node x Empty Empty
insert x (Node v left right)
    | x < v = Node v (insert x left) right
    | x > v = Node v left (insert x right)
    | otherwise = Node v left right

-- 查找元素
search :: Ord a => a -> BST a -> Bool
search _ Empty = False
search x (Node v left right)
    | x < v = search x left
    | x > v = search x right
    | otherwise = True

-- 中序遍历
inorder :: BST a -> [a]
inorder Empty = []
inorder (Node v left right) = inorder left ++ [v] ++ inorder right

-- 使用示例
tree = insert 5 (insert 3 (insert 7 Empty))
example15 = search 3 tree  -- True
example16 = search 4 tree  -- False
example17 = inorder tree   -- [3, 5, 7]
```

### 形式化证明

**定理**：BST不变性
如果t是二叉搜索树，则insert x t也是二叉搜索树。

**证明**：

```haskell
-- 对t进行归纳
-- 基础情况：t = Empty
insert x Empty = Node x Empty Empty  -- 单节点树是BST

-- 归纳步骤：假设left和right是BST
-- 证明insert x (Node v left right)是BST
insert x (Node v left right)
| x < v = Node v (insert x left) right
-- 由于insert x left是BST（归纳假设）
-- 且x < v，所有insert x left中的元素 < v
-- 且right中的所有元素 > v
-- 因此结果是BST

| x > v = Node v left (insert x right)
-- 类似可证

| x == v = Node v left right
-- 直接返回原树，保持BST性质
```

## 7. 程序终止性证明

### 理论背景

程序终止性证明确保程序不会无限循环。

### Haskell实现

```haskell
-- 计算阶乘
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)

-- 计算斐波那契数
fibonacci :: Integer -> Integer
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)

-- 快速幂
power :: Num a => a -> Integer -> a
power _ 0 = 1
power x n
    | even n = power (x * x) (n `div` 2)
    | otherwise = x * power (x * x) (n `div` 2)

-- 使用示例
example18 = factorial 5  -- 120
example19 = fibonacci 6  -- 8
example20 = power 2 10   -- 1024
```

### 形式化证明

**定理**：factorial函数终止
对于任何非负整数n，factorial n终止。

**证明**：

```haskell
-- 对n进行归纳
-- 基础情况：n = 0
factorial 0 = 1  -- 立即终止

-- 归纳步骤：假设factorial (n-1)终止
factorial n = n * factorial (n - 1)
-- 由于n > 0，n-1 < n
-- 由归纳假设，factorial (n-1)终止
-- 因此factorial n终止
```

## 8. 程序复杂度证明

### 理论背景

程序复杂度证明分析算法的时间和空间复杂度。

### Haskell实现

```haskell
-- 线性搜索
linearSearch :: Eq a => a -> [a] -> Maybe Int
linearSearch _ [] = Nothing
linearSearch x (y:ys)
    | x == y = Just 0
    | otherwise = fmap (+1) (linearSearch x ys)

-- 二分搜索（要求列表已排序）
binarySearch :: Ord a => a -> [a] -> Maybe Int
binarySearch _ [] = Nothing
binarySearch x xs = binarySearch' x xs 0 (length xs - 1)

binarySearch' :: Ord a => a -> [a] -> Int -> Int -> Maybe Int
binarySearch' _ _ low high
    | low > high = Nothing
binarySearch' x xs low high = 
    let mid = (low + high) `div` 2
        midVal = xs !! mid
    in case compare x midVal of
        EQ -> Just mid
        LT -> binarySearch' x xs low (mid - 1)
        GT -> binarySearch' x xs (mid + 1) high

-- 使用示例
example21 = linearSearch 3 [1, 2, 3, 4, 5]  -- Just 2
example22 = binarySearch 3 [1, 2, 3, 4, 5]  -- Just 2
```

### 形式化证明

**定理**：线性搜索时间复杂度
linearSearch的时间复杂度为O(n)，其中n是列表长度。

**证明**：

```haskell
-- 最坏情况：目标元素不在列表中
-- 需要遍历整个列表
-- 每次递归调用处理一个元素
-- 因此总时间复杂度为O(n)

-- 空间复杂度：O(1)（尾递归优化后）
```

## 总结

定理证明示例展示了Haskell在形式化方法方面的优势：

1. **归纳法**：自然数、列表等数据类型的归纳证明
2. **类型安全**：编译时类型检查保证
3. **程序等价性**：不同实现方式的等价性证明
4. **算法正确性**：算法满足规范的证明
5. **数据结构不变性**：操作后保持性质的证明
6. **程序终止性**：避免无限循环的证明
7. **程序复杂度**：时间和空间复杂度的分析

这些特性使得Haskell成为形式化方法和程序验证的理想语言。

## 相关链接

- [形式化方法理论](../../03-Theory/04-Formal-Methods/)
- [定理证明系统](../../03-Theory/04-Formal-Methods/02-Theorem-Proving/)
- [抽象解释](../../03-Theory/04-Formal-Methods/03-Abstract-Interpretation/)
- [算法实现](../03-算法实现/)
