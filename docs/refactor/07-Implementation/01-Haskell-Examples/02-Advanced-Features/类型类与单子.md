# 类型类与单子 - Haskell示例

## 1. 类型类系统

### 理论背景

类型类是Haskell中实现特设多态性的机制，类似于其他语言中的接口或特质。

### Haskell实现

```haskell
-- 基本类型类定义
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    
    -- 默认实现
    x /= y = not (x == y)

-- 类型类继承
class (Eq a) => Ord a where
    compare :: a -> a -> Ordering
    (<) :: a -> a -> Bool
    (<=) :: a -> a -> Bool
    (>) :: a -> a -> Bool
    (>=) :: a -> a -> Bool
    max :: a -> a -> a
    min :: a -> a -> a

-- 自定义数据类型实例
data Point = Point Double Double

instance Eq Point where
    (Point x1 y1) == (Point x2 y2) = x1 == x2 && y1 == y2

instance Ord Point where
    compare (Point x1 y1) (Point x2 y2) = 
        case compare x1 x2 of
            EQ -> compare y1 y2
            other -> other

-- 多参数类型类
class Monoid a where
    mempty :: a
    mappend :: a -> a -> a
    
    -- 默认实现
    mconcat :: [a] -> a
    mconcat = foldr mappend mempty

-- 实例定义
instance Monoid [a] where
    mempty = []
    mappend = (++)

instance Monoid Int where
    mempty = 0
    mappend = (+)
```

### 形式化证明

**定理**：类型类实例的唯一性
对于任何类型a和类型类C，如果存在实例C a，则该实例是唯一的。

**证明**：
```haskell
-- 假设存在两个不同的实例
instance C a where
    method1 = implementation1
    method2 = implementation2

instance C a where
    method1 = implementation1'
    method2 = implementation2'

-- 由于Haskell不允许重复实例声明
-- 因此实例是唯一的
```

## 2. 函子（Functor）

### 理论背景

函子是范畴论中的概念，在Haskell中表示可以映射的类型构造器。

### Haskell实现

```haskell
-- 函子类型类
class Functor f where
    fmap :: (a -> b) -> f a -> f b
    
    -- 函子定律
    -- 1. fmap id = id
    -- 2. fmap (f . g) = fmap f . fmap g

-- Maybe函子实例
instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)

-- 列表函子实例
instance Functor [] where
    fmap = map

-- 元组函子实例（对第二个类型参数）
instance Functor ((,) a) where
    fmap f (x, y) = (x, f y)

-- 使用函子
maybeExample :: Maybe Int
maybeExample = Just 5

squaredMaybe :: Maybe Int
squaredMaybe = fmap (^2) maybeExample  -- Just 25

listExample :: [Int]
listExample = [1, 2, 3, 4, 5]

squaredList :: [Int]
squaredList = fmap (^2) listExample  -- [1, 4, 9, 16, 25]
```

### 形式化证明

**定理**：函子定律
对于任何函子f，以下定律成立：
1. `fmap id = id`
2. `fmap (f . g) = fmap f . fmap g`

**证明**：
```haskell
-- 对于Maybe函子
-- 定律1：fmap id = id
fmap id Nothing = Nothing = id Nothing
fmap id (Just x) = Just (id x) = Just x = id (Just x)

-- 定律2：fmap (f . g) = fmap f . fmap g
fmap (f . g) Nothing = Nothing = fmap f (fmap g Nothing)
fmap (f . g) (Just x) = Just ((f . g) x) = Just (f (g x))
fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x))
```

## 3. 应用函子（Applicative）

### 理论背景

应用函子扩展了函子的概念，允许将包装在上下文中的函数应用到包装的值上。

### Haskell实现

```haskell
-- 应用函子类型类
class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
    
    -- 应用函子定律
    -- 1. pure id <*> v = v
    -- 2. pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
    -- 3. pure f <*> pure x = pure (f x)
    -- 4. u <*> pure y = pure ($ y) <*> u

-- Maybe应用函子实例
instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    _ <*> Nothing = Nothing
    Just f <*> Just x = Just (f x)

-- 列表应用函子实例
instance Applicative [] where
    pure x = [x]
    fs <*> xs = [f x | f <- fs, x <- xs]

-- 使用应用函子
maybeAdd :: Maybe (Int -> Int -> Int)
maybeAdd = pure (+)

result1 :: Maybe Int
result1 = maybeAdd <*> Just 3 <*> Just 4  -- Just 7

result2 :: Maybe Int
result2 = pure (+) <*> Just 5 <*> Just 6  -- Just 11

-- 列表应用
listAdd :: [Int -> Int -> Int]
listAdd = [(+), (*)]

listResult :: [Int]
listResult = listAdd <*> [1, 2] <*> [3, 4]  -- [4, 5, 5, 6, 3, 4, 6, 8]
```

### 形式化证明

**定理**：应用函子定律
对于Maybe应用函子，所有应用函子定律都成立。

**证明**：
```haskell
-- 定律1：pure id <*> v = v
pure id <*> Just x = Just id <*> Just x = Just (id x) = Just x

-- 定律2：结合律
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
-- 对于Maybe，这通过模式匹配可以验证

-- 定律3：同态性
pure f <*> pure x = Just f <*> Just x = Just (f x) = pure (f x)

-- 定律4：交换律
u <*> pure y = pure ($ y) <*> u
-- 对于Maybe，这通过模式匹配可以验证
```

## 4. 单子（Monad）

### 理论背景

单子是应用函子的进一步扩展，提供了顺序计算的能力。

### Haskell实现

```haskell
-- 单子类型类
class Applicative m => Monad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b
    
    -- 单子定律
    -- 1. return a >>= f = f a
    -- 2. m >>= return = m
    -- 3. (m >>= f) >>= g = m >>= (\x -> f x >>= g)

-- Maybe单子实例
instance Monad Maybe where
    return = Just
    Nothing >>= _ = Nothing
    Just x >>= f = f x

-- 列表单子实例
instance Monad [] where
    return x = [x]
    xs >>= f = concat (map f xs)

-- 使用单子
maybeChain :: Maybe Int
maybeChain = Just 5 >>= \x -> 
             Just 3 >>= \y -> 
             return (x + y)  -- Just 8

-- do记法
maybeChainDo :: Maybe Int
maybeChainDo = do
    x <- Just 5
    y <- Just 3
    return (x + y)  -- Just 8

-- 错误处理
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

calculation :: Maybe Double
calculation = do
    x <- Just 10
    y <- Just 2
    z <- safeDivide x y
    return (z * 3)  -- Just 15.0
```

### 形式化证明

**定理**：单子定律
对于Maybe单子，所有单子定律都成立。

**证明**：
```haskell
-- 定律1：左单位元
return a >>= f = Just a >>= f = f a

-- 定律2：右单位元
Just x >>= return = return x = Just x

-- 定律3：结合律
(Just x >>= f) >>= g = f x >>= g
Just x >>= (\x -> f x >>= g) = (\x -> f x >>= g) x = f x >>= g
```

## 5. 单子变换器

### 理论背景

单子变换器允许组合不同的单子，创建更复杂的计算上下文。

### Haskell实现

```haskell
-- 单子变换器类型类
class MonadTrans t where
    lift :: Monad m => m a -> t m a

-- ReaderT单子变换器
newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }

instance MonadTrans (ReaderT r) where
    lift m = ReaderT (\_ -> m)

instance Monad m => Monad (ReaderT r m) where
    return a = ReaderT (\_ -> return a)
    ReaderT f >>= g = ReaderT (\r -> f r >>= \a -> runReaderT (g a) r)

-- 使用ReaderT
type AppM = ReaderT String IO

greetUser :: AppM ()
greetUser = do
    name <- lift $ putStrLn "请输入您的名字：" >> getLine
    env <- ask
    lift $ putStrLn $ "Hello, " ++ name ++ " in " ++ env

-- 运行ReaderT
runApp :: AppM a -> String -> IO a
runApp app env = runReaderT app env
```

### 形式化证明

**定理**：单子变换器保持单子定律
如果m是单子，则t m也是单子。

**证明**：
```haskell
-- 对于ReaderT r m
-- 定律1：左单位元
return a >>= f = ReaderT (\_ -> return a) >>= f
= ReaderT (\r -> return a >>= \a -> runReaderT (f a) r)
= ReaderT (\r -> runReaderT (f a) r) = f a

-- 其他定律类似可证
```

## 6. 实际应用示例

### 解析器组合子

```haskell
-- 解析器类型
newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }

-- 基本解析器
char :: Char -> Parser Char
char c = Parser $ \s -> case s of
    (x:xs) | x == c -> Just (c, xs)
    _ -> Nothing

-- 解析器单子实例
instance Monad Parser where
    return a = Parser $ \s -> Just (a, s)
    Parser p >>= f = Parser $ \s -> case p s of
        Just (a, s') -> runParser (f a) s'
        Nothing -> Nothing

-- 解析器应用函子实例
instance Applicative Parser where
    pure = return
    Parser pf <*> Parser px = Parser $ \s -> case pf s of
        Just (f, s') -> case px s' of
            Just (x, s'') -> Just (f x, s'')
            Nothing -> Nothing
        Nothing -> Nothing

-- 组合解析器
digit :: Parser Int
digit = Parser $ \s -> case s of
    (x:xs) | x `elem` "0123456789" -> Just (read [x], xs)
    _ -> Nothing

number :: Parser Int
number = do
    digits <- many1 digit
    return (read digits)

-- 辅助函数
many1 :: Parser a -> Parser [a]
many1 p = do
    x <- p
    xs <- many p
    return (x:xs)

many :: Parser a -> Parser [a]
many p = many1 p <|> return []

(<|>) :: Parser a -> Parser a -> Parser a
Parser p1 <|> Parser p2 = Parser $ \s -> p1 s <|> p2 s
```

### 形式化验证

**定理**：解析器组合子的正确性
如果p1和p2是正确的解析器，则p1 <|> p2也是正确的解析器。

**证明**：
```haskell
-- 解析器正确性定义：
-- 对于输入s，如果p1 s = Just (a, s')，则s'是s的后缀
-- 如果p2 s = Just (b, s'')，则s''是s的后缀

-- 对于p1 <|> p2：
-- 如果p1 s成功，返回p1的结果
-- 如果p1 s失败，尝试p2 s
-- 因此结果仍然是输入的后缀
```

## 总结

类型类和单子系统展示了Haskell的高级特性：
1. **类型类**：特设多态性和接口抽象
2. **函子**：可映射的类型构造器
3. **应用函子**：上下文中的函数应用
4. **单子**：顺序计算和副作用管理
5. **单子变换器**：单子组合
6. **形式化证明**：数学严谨性

这些特性使得Haskell能够优雅地处理复杂的计算和抽象。

## 相关链接

- [类型系统理论](../../03-Theory/01-Programming-Language-Theory/03-Type-System-Theory/)
- [语义理论](../../03-Theory/01-Programming-Language-Theory/02-Semantics-Theory/)
- [形式化方法](../../03-Theory/04-Formal-Methods/)
- [算法实现](../02-Algorithms/) 