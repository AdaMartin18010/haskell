# 函数式编程基础 - Haskell示例

## 1. 纯函数与副作用

### 理论背景

在函数式编程中，纯函数是核心概念。纯函数具有以下特性：

- 相同输入总是产生相同输出
- 没有副作用
- 引用透明性

### Haskell实现

```haskell
-- 纯函数示例
add :: Num a => a -> a -> a
add x y = x + y

-- 非纯函数示例（在IO单子中）
getUserInput :: IO String
getUserInput = do
    putStrLn "请输入您的名字："
    getLine

-- 函数组合
compose :: (b -> c) -> (a -> b) -> a -> c
compose f g x = f (g x)

-- 使用函数组合
addOne :: Num a => a -> a
addOne = (+1)

multiplyTwo :: Num a => a -> a
multiplyTwo = (*2)

-- 组合函数：先加1，再乘2
addOneThenMultiplyTwo :: Num a => a -> a
addOneThenMultiplyTwo = multiplyTwo . addOne
```

### 形式化证明

**定理**：函数组合满足结合律

```latex
(f . g) . h = f . (g . h)
```

**证明**：

```haskell
-- 左结合
((f . g) . h) x = (f . g) (h x) = f (g (h x))

-- 右结合  
(f . (g . h)) x = f ((g . h) x) = f (g (h x))

-- 因此 (f . g) . h = f . (g . h)
```

## 2. 高阶函数

### 理论背景

高阶函数是接受函数作为参数或返回函数的函数。

### Haskell实现

```haskell
-- map函数：将函数应用到列表的每个元素
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs

-- filter函数：根据谓词过滤列表
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs

-- foldr函数：右折叠
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ z [] = z
foldr f z (x:xs) = f x (foldr f z xs)

-- 使用高阶函数
numbers = [1, 2, 3, 4, 5]
squared = map (^2) numbers  -- [1, 4, 9, 16, 25]
evens = filter even numbers -- [2, 4]
sum = foldr (+) 0 numbers   -- 15
```

### 形式化证明

**定理**：map和filter的分配律

```
map f . filter p = filter p . map f
```

**证明**：

```haskell
-- 对于列表[x1, x2, ..., xn]
-- 左式：先过滤再映射
map f (filter p [x1, x2, ..., xn])
= map f [xi | xi <- [x1, x2, ..., xn], p xi]
= [f xi | xi <- [x1, x2, ..., xn], p xi]

-- 右式：先映射再过滤
filter p (map f [x1, x2, ..., xn])
= filter p [f x1, f x2, ..., f xn]
= [f xi | xi <- [x1, x2, ..., xn], p xi]

-- 因此等式成立
```

## 3. 模式匹配

### 理论背景

模式匹配是函数式编程中的核心特性，允许根据数据结构的形式进行分支处理。

### Haskell实现

```haskell
-- 列表模式匹配
listLength :: [a] -> Int
listLength [] = 0
listLength (_:xs) = 1 + listLength xs

-- 元组模式匹配
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)

-- 自定义数据类型模式匹配
data Tree a = Empty | Node a (Tree a) (Tree a)

treeSize :: Tree a -> Int
treeSize Empty = 0
treeSize (Node _ left right) = 1 + treeSize left + treeSize right

-- 守卫表达式
absolute :: Num a => a -> a
absolute x
    | x >= 0 = x
    | otherwise = -x
```

### 形式化证明

**定理**：模式匹配的完备性
对于任何数据类型T，如果所有构造函数都被模式匹配覆盖，则函数是完备的。

**证明**：

```haskell
-- 对于数据类型Tree a
data Tree a = Empty | Node a (Tree a) (Tree a)

-- 完备的模式匹配
treeSize :: Tree a -> Int
treeSize Empty = 0                    -- 覆盖Empty构造函数
treeSize (Node _ left right) = ...    -- 覆盖Node构造函数

-- 因此函数是完备的
```

## 4. 惰性求值

### 理论背景

Haskell使用惰性求值，表达式只在需要时才被计算。

### Haskell实现

```haskell
-- 无限列表
infiniteList :: [Integer]
infiniteList = [1..]

-- 取前n个元素
takeN :: Int -> [a] -> [a]
takeN 0 _ = []
takeN _ [] = []
takeN n (x:xs) = x : takeN (n-1) xs

-- 斐波那契数列
fibonacci :: [Integer]
fibonacci = 0 : 1 : zipWith (+) fibonacci (tail fibonacci)

-- 使用惰性求值
firstTenFibs = take 10 fibonacci  -- 只计算前10个斐波那契数
```

### 形式化证明

**定理**：惰性求值的正确性
对于无限列表，take n操作总是终止。

**证明**：

```haskell
-- 归纳法证明
-- 基础情况：n = 0
take 0 xs = []  -- 立即返回空列表

-- 归纳步骤：假设take (n-1) xs终止
take n (x:xs) = x : take (n-1) xs
-- 由于take (n-1) xs终止，因此take n (x:xs)也终止
```

## 5. 类型系统

### 理论背景

Haskell的类型系统基于Hindley-Milner类型系统，提供强大的类型安全保证。

### Haskell实现

```haskell
-- 基本类型
type Name = String
type Age = Int

-- 类型别名
type Point = (Double, Double)

-- 自定义数据类型
data Person = Person Name Age

-- 类型类
class Show a where
    show :: a -> String

-- 实例定义
instance Show Person where
    show (Person name age) = name ++ " (" ++ show age ++ "岁)"

-- 多态函数
identity :: a -> a
identity x = x

-- 类型约束
maximum :: Ord a => [a] -> a
maximum [] = error "空列表没有最大值"
maximum [x] = x
maximum (x:xs) = max x (maximum xs)
```

### 形式化证明

**定理**：类型安全
如果表达式e有类型τ，则e不会产生类型错误。

**证明**：

```haskell
-- 类型推导规则
-- 变量规则：x:τ ∈ Γ
--           --------
--           Γ ⊢ x:τ

-- 应用规则：Γ ⊢ e1:τ1→τ2  Γ ⊢ e2:τ1
--           ------------------------
--           Γ ⊢ e1 e2:τ2

-- 抽象规则：Γ,x:τ1 ⊢ e:τ2
--           --------------
--           Γ ⊢ λx.e:τ1→τ2
```

## 6. 实际应用示例

### 计算器实现

```haskell
-- 表达式数据类型
data Expr = Lit Int
          | Add Expr Expr
          | Mul Expr Expr
          | Sub Expr Expr

-- 求值函数
eval :: Expr -> Int
eval (Lit n) = n
eval (Add e1 e2) = eval e1 + eval e2
eval (Mul e1 e2) = eval e1 * eval e2
eval (Sub e1 e2) = eval e1 - eval e2

-- 示例
example = Add (Mul (Lit 2) (Lit 3)) (Sub (Lit 10) (Lit 4))
result = eval example  -- 2*3 + (10-4) = 6 + 6 = 12
```

### 形式化验证

**定理**：eval函数的正确性
对于任何表达式e，eval e返回正确的数值结果。

**证明**：

```haskell
-- 结构归纳法
-- 基础情况：e = Lit n
eval (Lit n) = n  -- 直接返回字面量值

-- 归纳步骤：假设eval e1和eval e2正确
eval (Add e1 e2) = eval e1 + eval e2  -- 加法运算
eval (Mul e1 e2) = eval e1 * eval e2  -- 乘法运算
eval (Sub e1 e2) = eval e1 - eval e2  -- 减法运算
```

## 总结

函数式编程基础展示了Haskell的核心特性：

1. **纯函数**：无副作用，引用透明
2. **高阶函数**：函数作为一等公民
3. **模式匹配**：优雅的数据结构处理
4. **惰性求值**：按需计算
5. **类型系统**：编译时类型安全
6. **形式化证明**：数学严谨性

这些特性使得Haskell成为形式化方法和理论计算机科学的理想语言。

## 相关链接

- [类型系统理论](../../03-Theory/01-Programming-Language-Theory/03-Type-System-Theory/)
- [语义理论](../../03-Theory/01-Programming-Language-Theory/02-Semantics-Theory/)
- [算法实现](../02-Algorithms/)
- [数据结构](../03-Data-Structures/)
