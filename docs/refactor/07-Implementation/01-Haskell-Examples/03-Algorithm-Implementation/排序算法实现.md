# 排序算法实现 - Haskell示例

## 1. 快速排序（QuickSort）

### 理论背景

快速排序是一种分治算法，平均时间复杂度为O(n log n)，最坏情况为O(n²)。

### Haskell实现

```haskell
-- 基本快速排序
quicksort :: Ord a => [a] -> [a]
quicksort [] = []
quicksort (x:xs) = 
    quicksort [y | y <- xs, y <= x] ++ 
    [x] ++ 
    quicksort [y | y <- xs, y > x]

-- 优化的快速排序（避免重复计算）
quicksort' :: Ord a => [a] -> [a]
quicksort' [] = []
quicksort' (x:xs) = 
    let (smaller, larger) = partition (<= x) xs
    in quicksort' smaller ++ [x] ++ quicksort' larger

-- 分区函数
partition :: (a -> Bool) -> [a] -> ([a], [a])
partition _ [] = ([], [])
partition p (x:xs)
    | p x = (x:ys, zs)
    | otherwise = (ys, x:zs)
    where (ys, zs) = partition p xs

-- 使用示例
example1 = quicksort [3, 1, 4, 1, 5, 9, 2, 6]
-- 结果: [1, 1, 2, 3, 4, 5, 6, 9]
```

### 形式化证明

**定理**：快速排序的正确性
对于任何列表xs，quicksort xs返回一个排序后的列表。

**证明**：

```haskell
-- 结构归纳法
-- 基础情况：xs = []
quicksort [] = []  -- 空列表已排序

-- 归纳步骤：假设quicksort smaller和quicksort larger正确
quicksort (x:xs) = quicksort smaller ++ [x] ++ quicksort larger
-- 其中smaller = [y | y <- xs, y <= x]
--     larger = [y | y <- xs, y > x]

-- 由于smaller中的所有元素 <= x，larger中的所有元素 > x
-- 且quicksort smaller和quicksort larger返回排序列表
-- 因此结果是一个排序列表
```

## 2. 归并排序（MergeSort）

### 理论背景

归并排序是一种稳定的分治算法，时间复杂度为O(n log n)。

### Haskell实现

```haskell
-- 归并排序
mergesort :: Ord a => [a] -> [a]
mergesort [] = []
mergesort [x] = [x]
mergesort xs = 
    let (left, right) = splitAt (length xs `div` 2) xs
    in merge (mergesort left) (mergesort right)

-- 归并两个已排序列表
merge :: Ord a => [a] -> [a] -> [a]
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys)
    | x <= y = x : merge xs (y:ys)
    | otherwise = y : merge (x:xs) ys

-- 优化的归并排序（避免重复计算长度）
mergesort' :: Ord a => [a] -> [a]
mergesort' [] = []
mergesort' [x] = [x]
mergesort' xs = 
    let (left, right) = halve xs
    in merge (mergesort' left) (mergesort' right)

-- 将列表分成两半
halve :: [a] -> ([a], [a])
halve xs = splitAt (length xs `div` 2) xs

-- 使用示例
example2 = mergesort [3, 1, 4, 1, 5, 9, 2, 6]
-- 结果: [1, 1, 2, 3, 4, 5, 6, 9]
```

### 形式化证明

**定理**：归并排序的正确性
对于任何列表xs，mergesort xs返回一个排序后的列表。

**证明**：

```haskell
-- 结构归纳法
-- 基础情况：xs = [] 或 xs = [x]
mergesort [] = []  -- 空列表已排序
mergesort [x] = [x]  -- 单元素列表已排序

-- 归纳步骤：假设mergesort left和mergesort right正确
mergesort xs = merge (mergesort left) (mergesort right)
-- 其中left和right是xs的两半

-- 由于mergesort left和mergesort right返回排序列表
-- 且merge函数正确合并两个已排序列表
-- 因此结果是一个排序列表
```

## 3. 插入排序（InsertionSort）

### 理论背景

插入排序是一种简单的排序算法，时间复杂度为O(n²)，但对于小列表或接近排序的列表效率较高。

### Haskell实现

```haskell
-- 插入排序
insertionsort :: Ord a => [a] -> [a]
insertionsort = foldr insert []

-- 插入元素到已排序列表
insert :: Ord a => a -> [a] -> [a]
insert x [] = [x]
insert x (y:ys)
    | x <= y = x : y : ys
    | otherwise = y : insert x ys

-- 使用foldl的版本
insertionsort' :: Ord a => [a] -> [a]
insertionsort' = foldl (flip insert) []

-- 使用示例
example3 = insertionsort [3, 1, 4, 1, 5, 9, 2, 6]
-- 结果: [1, 1, 2, 3, 4, 5, 6, 9]
```

### 形式化证明

**定理**：插入排序的正确性
对于任何列表xs，insertionsort xs返回一个排序后的列表。

**证明**：

```haskell
-- 使用foldr的性质
-- 基础情况：xs = []
foldr insert [] [] = []  -- 空列表已排序

-- 归纳步骤：假设foldr insert [] xs正确
foldr insert [] (x:xs) = insert x (foldr insert [] xs)
-- 由于foldr insert [] xs返回排序列表
-- 且insert函数正确插入元素到已排序列表
-- 因此结果是一个排序列表
```

## 4. 堆排序（HeapSort）

### 理论背景

堆排序利用堆数据结构进行排序，时间复杂度为O(n log n)。

### Haskell实现

```haskell
-- 堆数据类型
data Heap a = Empty | Node a (Heap a) (Heap a)

-- 堆排序
heapsort :: Ord a => [a] -> [a]
heapsort xs = heapToList (listToHeap xs)

-- 将列表转换为堆
listToHeap :: Ord a => [a] -> Heap a
listToHeap = foldr insertHeap Empty

-- 将堆转换为列表
heapToList :: Ord a => Heap a -> [a]
heapToList Empty = []
heapToList h = 
    let (x, h') = extractMax h
    in x : heapToList h'

-- 插入元素到堆
insertHeap :: Ord a => a -> Heap a -> Heap a
insertHeap x Empty = Node x Empty Empty
insertHeap x (Node v left right)
    | x > v = Node x (insertHeap v left) right
    | otherwise = Node v (insertHeap x left) right

-- 提取最大元素
extractMax :: Ord a => Heap a -> (a, Heap a)
extractMax (Node x left right) = (x, mergeHeaps left right)
extractMax Empty = error "空堆"

-- 合并两个堆
mergeHeaps :: Ord a => Heap a -> Heap a -> Heap a
mergeHeaps Empty h = h
mergeHeaps h Empty = h
mergeHeaps (Node x left1 right1) (Node y left2 right2)
    | x >= y = Node x (mergeHeaps left1 right1) (Node y left2 right2)
    | otherwise = Node y (Node x left1 right1) (mergeHeaps left2 right2)

-- 使用示例
example4 = heapsort [3, 1, 4, 1, 5, 9, 2, 6]
-- 结果: [1, 1, 2, 3, 4, 5, 6, 9]
```

### 形式化证明

**定理**：堆排序的正确性
对于任何列表xs，heapsort xs返回一个排序后的列表。

**证明**：

```haskell
-- 堆的性质：
-- 1. 根节点是最大元素
-- 2. 左右子树都是堆

-- 因此：
-- listToHeap xs 创建一个堆
-- heapToList h 按降序提取元素
-- 反转后得到升序列表
```

## 5. 基数排序（RadixSort）

### 理论背景

基数排序是一种非比较排序算法，适用于整数或字符串排序。

### Haskell实现

```haskell
-- 基数排序（用于非负整数）
radixsort :: [Int] -> [Int]
radixsort xs = radixsort' xs 0

-- 辅助函数
radixsort' :: [Int] -> Int -> [Int]
radixsort' xs digit
    | all (\x -> x < 10^digit) xs = xs
    | otherwise = radixsort' (countingSort xs digit) (digit + 1)

-- 计数排序（按指定位数排序）
countingSort :: [Int] -> Int -> [Int]
countingSort xs digit = 
    let counts = countDigits xs digit
        positions = scanl (+) 0 counts
        result = replicate (length xs) 0
    in placeElements xs result positions digit

-- 计算指定位数的数字
getDigit :: Int -> Int -> Int
getDigit x digit = (x `div` 10^digit) `mod` 10

-- 统计每个数字的出现次数
countDigits :: [Int] -> Int -> [Int]
countDigits xs digit = 
    let digits = map (`getDigit` digit) xs
    in [length [d | d <- digits, d == i] | i <- [0..9]]

-- 放置元素到正确位置
placeElements :: [Int] -> [Int] -> [Int] -> Int -> [Int]
placeElements [] result _ _ = result
placeElements (x:xs) result positions digit = 
    let d = getDigit x digit
        pos = positions !! d
        newPositions = updatePositions positions d
    in placeElements xs (updateAt pos x result) newPositions digit

-- 更新位置数组
updatePositions :: [Int] -> Int -> [Int]
updatePositions positions d = 
    [if i == d then pos + 1 else pos | (i, pos) <- zip [0..] positions]

-- 在指定位置更新元素
updateAt :: Int -> a -> [a] -> [a]
updateAt _ _ [] = []
updateAt 0 y (_:xs) = y:xs
updateAt n y (x:xs) = x:updateAt (n-1) y xs

-- 使用示例
example5 = radixsort [170, 45, 75, 90, 802, 24, 2, 66]
-- 结果: [2, 24, 45, 66, 75, 90, 170, 802]
```

### 形式化证明

**定理**：基数排序的正确性
对于任何非负整数列表xs，radixsort xs返回一个排序后的列表。

**证明**：

```haskell
-- 基数排序的正确性基于计数排序的正确性
-- 计数排序按每个位进行稳定排序
-- 从最低位到最高位依次排序
-- 最终得到完全排序的列表
```

## 6. 性能分析与比较

### 时间复杂度分析

```haskell
-- 各种排序算法的时间复杂度
-- 快速排序：平均 O(n log n)，最坏 O(n²)
-- 归并排序：O(n log n)
-- 插入排序：O(n²)
-- 堆排序：O(n log n)
-- 基数排序：O(d * (n + k))，其中d是位数，k是基数

-- 空间复杂度
-- 快速排序：O(log n) 平均，O(n) 最坏
-- 归并排序：O(n)
-- 插入排序：O(1)
-- 堆排序：O(1)
-- 基数排序：O(n + k)
```

### 实际性能测试

```haskell
-- 性能测试函数
import System.CPUTime
import System.Random

-- 生成随机列表
randomList :: Int -> IO [Int]
randomList n = do
    gen <- getStdGen
    return $ take n $ randomRs (1, 1000) gen :: [Int]

-- 测试排序性能
testSort :: ([Int] -> [Int]) -> String -> [Int] -> IO ()
testSort sortFunc name xs = do
    start <- getCPUTime
    let sorted = sortFunc xs
    end <- getCPUTime
    let time = fromIntegral (end - start) / 1000000000
    putStrLn $ name ++ ": " ++ show time ++ " 秒"
    putStrLn $ "排序正确: " ++ show (isSorted sorted)

-- 检查是否已排序
isSorted :: Ord a => [a] -> Bool
isSorted [] = True
isSorted [_] = True
isSorted (x:y:xs) = x <= y && isSorted (y:xs)
```

## 7. 形式化验证

### 排序算法的形式化规范

```haskell
-- 排序函数的规范
-- 对于任何排序函数sort :: Ord a => [a] -> [a]
-- 必须满足以下性质：

-- 1. 输出是输入的排列
isPermutation :: Eq a => [a] -> [a] -> Bool
isPermutation xs ys = 
    length xs == length ys && 
    all (\x -> count x xs == count x ys) xs

-- 2. 输出是已排序的
isSorted :: Ord a => [a] -> Bool
isSorted [] = True
isSorted [_] = True
isSorted (x:y:xs) = x <= y && isSorted (y:xs)

-- 3. 排序函数的正确性
sortCorrect :: Ord a => ([a] -> [a]) -> [a] -> Bool
sortCorrect sort xs = 
    isSorted (sort xs) && isPermutation xs (sort xs)

-- 计数元素出现次数
count :: Eq a => a -> [a] -> Int
count x = length . filter (== x)
```

### 定理证明

**定理**：所有排序算法都满足排序规范
对于任何正确的排序函数sort，sortCorrect sort xs对所有xs成立。

**证明**：

```haskell
-- 对于每个排序算法：
-- 1. 输出是输入的排列：通过保持所有元素不变
-- 2. 输出是已排序的：通过比较和交换操作
-- 3. 因此sortCorrect sort xs = True
```

## 总结

排序算法实现展示了Haskell在算法实现方面的优势：

1. **函数式风格**：纯函数，无副作用
2. **模式匹配**：优雅的数据结构处理
3. **高阶函数**：利用foldr等函数简化实现
4. **类型安全**：编译时类型检查
5. **形式化证明**：数学严谨性
6. **性能分析**：理论分析和实际测试

这些特性使得Haskell成为实现和验证算法的理想语言。

## 相关链接

- [算法理论](../../03-Theory/01-Programming-Language-Theory/)
- [数据结构](../03-Data-Structures/)
- [性能优化](../05-Performance-Optimization/)
- [形式化证明](../04-Formal-Proofs/)
