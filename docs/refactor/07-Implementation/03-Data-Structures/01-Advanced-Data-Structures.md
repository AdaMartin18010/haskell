# È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑ - ÂΩ¢ÂºèÂåñÁêÜËÆ∫‰∏éHaskellÂÆûÁé∞

## üìã Ê¶ÇËø∞

È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÊòØËÆ°ÁÆóÊú∫ÁßëÂ≠¶‰∏≠ÁöÑÊ†∏ÂøÉÊ¶ÇÂøµÔºåÊèê‰æõ‰∫ÜÈ´òÊïàÁöÑÊï∞ÊçÆÁªÑÁªáÂíåËÆøÈóÆÊñπÊ≥ï„ÄÇÊú¨ÊñáÊ°£‰ªéÂΩ¢ÂºèÂåñÁêÜËÆ∫ÁöÑËßíÂ∫¶ÂàÜÊûêÂêÑÁßçÈ´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÔºåÂπ∂Êèê‰æõÂÆåÊï¥ÁöÑHaskellÂÆûÁé∞„ÄÇ

## üéØ ÂΩ¢ÂºèÂåñÂÆö‰πâ

### Êï∞ÊçÆÁªìÊûÑÁöÑÂü∫Êú¨Ê¶ÇÂøµ

#### ÊäΩË±°Êï∞ÊçÆÁ±ªÂûã (ADT)

ÊäΩË±°Êï∞ÊçÆÁ±ªÂûãÊòØ‰∏Ä‰∏™Êï∞Â≠¶Ê®°ÂûãÔºåÂåÖÂê´Ôºö

- **Êï∞ÊçÆÂØπË±°**Ôºö$D = \{d_1, d_2, \ldots, d_n\}$
- **Êìç‰ΩúÈõÜÂêà**Ôºö$O = \{op_1, op_2, \ldots, op_m\}$
- **ÂÖ¨ÁêÜÁ≥ªÁªü**ÔºöÂÆö‰πâÊìç‰ΩúÁöÑË°å‰∏∫ÂíåÊÄßË¥®

#### Êï∞ÊçÆÁªìÊûÑÂàÜÁ±ª

1. **Á∫øÊÄßÁªìÊûÑ**ÔºöÊï∞ÁªÑ„ÄÅÈìæË°®„ÄÅÊ†à„ÄÅÈòüÂàó
2. **Ê†ëÂΩ¢ÁªìÊûÑ**Ôºö‰∫åÂèâÊ†ë„ÄÅBÊ†ë„ÄÅÁ∫¢ÈªëÊ†ë„ÄÅAVLÊ†ë
3. **ÂõæÁªìÊûÑ**ÔºöÈÇªÊé•Áü©Èòµ„ÄÅÈÇªÊé•Ë°®
4. **Êï£ÂàóÁªìÊûÑ**ÔºöÊï£ÂàóË°®„ÄÅÂ∏ÉÈöÜËøáÊª§Âô®
5. **È´òÁ∫ßÁªìÊûÑ**ÔºöË∑≥Ë°®„ÄÅTrie„ÄÅÂπ∂Êü•ÈõÜ

## üîß HaskellÂÆûÁé∞

### Âü∫Á°ÄÁ±ªÂûãÂÆö‰πâ

```haskell
{-# LANGUAGE TypeFamilies, FlexibleContexts, MultiParamTypeClasses #-}

import Data.Maybe (fromMaybe, isJust)
import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.Vector as V
import Data.List (foldl')

-- Êï∞ÊçÆÁªìÊûÑÁ±ªÂûãÁ±ª
class DataStructure ds where
    type Element ds :: *
    type Key ds :: *
    empty :: ds
    isEmpty :: ds -> Bool
    size :: ds -> Int
    insert :: Element ds -> ds -> ds
    delete :: Key ds -> ds -> ds
    lookup :: Key ds -> ds -> Maybe (Element ds)
    member :: Key ds -> ds -> Bool

-- Êï∞ÊçÆÁªìÊûÑÊìç‰ΩúÁªìÊûúÁ±ªÂûã
data OperationResult a = OperationResult
    { result :: a
    , time :: Double
    , memory :: Int
    , comparisons :: Int
    }

-- Êï∞ÊçÆÁªìÊûÑÊÄßËÉΩÊåáÊ†á
data PerformanceMetrics = PerformanceMetrics
    { timeComplexity :: String
    , spaceComplexity :: String
    , amortizedCost :: String
    , worstCase :: String
    }
```

### 1. Á∫¢ÈªëÊ†ë (Red-Black Tree)

#### ÂΩ¢ÂºèÂåñÂÆö‰πâ

Á∫¢ÈªëÊ†ëÊòØ‰∏ÄÁßçËá™Âπ≥Ë°°ÁöÑ‰∫åÂèâÊêúÁ¥¢Ê†ëÔºåÊª°Ë∂≥‰ª•‰∏ãÊÄßË¥®Ôºö

1. **Ê†πÊÄßË¥®**ÔºöÊ†πËäÇÁÇπÊòØÈªëËâ≤
2. **Á∫¢ÊÄßË¥®**ÔºöÁ∫¢ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπÈÉΩÊòØÈªëËâ≤
3. **ÈªëÊÄßË¥®**Ôºö‰ªéÊ†πÂà∞Âè∂Â≠êÁöÑÊâÄÊúâË∑ØÂæÑÂåÖÂê´Áõ∏ÂêåÊï∞ÈáèÁöÑÈªëËäÇÁÇπ
4. **Âè∂ÊÄßË¥®**ÔºöÂè∂Â≠êËäÇÁÇπÔºàNILÔºâÊòØÈªëËâ≤

#### HaskellÂÆûÁé∞

```haskell
-- Á∫¢ÈªëÊ†ëÈ¢úËâ≤
data Color = Red | Black deriving (Show, Eq)

-- Á∫¢ÈªëÊ†ëËäÇÁÇπ
data RedBlackTree a = Empty | Node Color (RedBlackTree a) a (RedBlackTree a) deriving (Show)

-- Á∫¢ÈªëÊ†ëÂÆû‰æã
instance (Ord a) => DataStructure (RedBlackTree a) where
    type Element (RedBlackTree a) = a
    type Key (RedBlackTree a) = a
    
    empty = Empty
    
    isEmpty Empty = True
    isEmpty _ = False
    
    size Empty = 0
    size (Node _ left _ right) = 1 + size left + size right
    
    insert x tree = makeBlack (insert' x tree)
    
    delete x tree = makeBlack (delete' x tree)
    
    lookup _ Empty = Nothing
    lookup x (Node _ left value right)
        | x == value = Just value
        | x < value = lookup x left
        | otherwise = lookup x right
    
    member x tree = isJust (lookup x tree)

-- ÊèíÂÖ•Êìç‰Ωú
insert' :: (Ord a) => a -> RedBlackTree a -> RedBlackTree a
insert' x Empty = Node Red Empty x Empty
insert' x (Node color left value right)
    | x < value = balance color (insert' x left) value right
    | x > value = balance color left value (insert' x right)
    | otherwise = Node color left value right

-- Âπ≥Ë°°Êìç‰Ωú
balance :: Color -> RedBlackTree a -> a -> RedBlackTree a -> RedBlackTree a
balance Black (Node Red (Node Red a x b) y c) z d = 
    Node Red (Node Black a x b) y (Node Black c z d)
balance Black (Node Red a x (Node Red b y c)) z d = 
    Node Red (Node Black a x b) y (Node Black c z d)
balance Black a x (Node Red (Node Red b y c) z d) = 
    Node Red (Node Black a x b) y (Node Black c z d)
balance Black a x (Node Red b y (Node Red c z d)) = 
    Node Red (Node Black a x b) y (Node Black c z d)
balance color left value right = Node color left value right

-- Á°Æ‰øùÊ†πËäÇÁÇπ‰∏∫ÈªëËâ≤
makeBlack :: RedBlackTree a -> RedBlackTree a
makeBlack Empty = Empty
makeBlack (Node _ left value right) = Node Black left value right

-- Âà†Èô§Êìç‰Ωú
delete' :: (Ord a) => a -> RedBlackTree a -> RedBlackTree a
delete' _ Empty = Empty
delete' x (Node color left value right)
    | x < value = Node color (delete' x left) value right
    | x > value = Node color left value (delete' x right)
    | otherwise = deleteNode color left right

-- Âà†Èô§ËäÇÁÇπ
deleteNode :: Color -> RedBlackTree a -> RedBlackTree a -> RedBlackTree a
deleteNode Black Empty Empty = Empty
deleteNode Black Empty right = right
deleteNode Black left Empty = left
deleteNode color left right = 
    let successor = findMin right
        newRight = deleteMin right
    in Node color left successor newRight

-- Êü•ÊâæÊúÄÂ∞èÂÄº
findMin :: RedBlackTree a -> a
findMin (Node _ Empty value _) = value
findMin (Node _ left _ _) = findMin left

-- Âà†Èô§ÊúÄÂ∞èÂÄº
deleteMin :: RedBlackTree a -> RedBlackTree a
deleteMin (Node _ Empty _ right) = right
deleteMin (Node color left value right) = 
    Node color (deleteMin left) value right

-- ÊÄßËÉΩÂàÜÊûê
redBlackTreePerformance :: PerformanceMetrics
redBlackTreePerformance = PerformanceMetrics
    { timeComplexity = "O(log n)"
    , spaceComplexity = "O(n)"
    , amortizedCost = "O(log n)"
    , worstCase = "O(log n)"
    }
```

#### ÊÄßËÉΩÂàÜÊûê

**Êó∂Èó¥Â§çÊùÇÂ∫¶**Ôºö

- Êü•ÊâæÔºö$O(\log n)$
- ÊèíÂÖ•Ôºö$O(\log n)$
- Âà†Èô§Ôºö$O(\log n)$

**Á©∫Èó¥Â§çÊùÇÂ∫¶**Ôºö$O(n)$

### 2. BÊ†ë (B-Tree)

#### ÂΩ¢ÂºèÂåñÂÆö‰πâ

BÊ†ëÊòØ‰∏ÄÁßçËá™Âπ≥Ë°°ÁöÑÊ†ëÊï∞ÊçÆÁªìÊûÑÔºåÁî®‰∫éÂ≠òÂÇ®Â§ßÈáèÊï∞ÊçÆ„ÄÇÊØè‰∏™ËäÇÁÇπÂåÖÂê´Â§ö‰∏™ÈîÆÂíåÂ≠êËäÇÁÇπ„ÄÇ

**BÊ†ëÊÄßË¥®**Ôºö

1. ÊâÄÊúâÂè∂Â≠êËäÇÁÇπÂú®Âêå‰∏ÄÂ±Ç
2. ÊØè‰∏™ÈùûÂè∂Â≠êËäÇÁÇπÊúâ $[m/2, m]$ ‰∏™Â≠êËäÇÁÇπ
3. ÊØè‰∏™ÈùûÂè∂Â≠êËäÇÁÇπÊúâ $[m/2-1, m-1]$ ‰∏™ÈîÆ
4. Ê†πËäÇÁÇπËá≥Â∞ëÊúâ2‰∏™Â≠êËäÇÁÇπÔºàÈô§ÈùûÊòØÂè∂Â≠êËäÇÁÇπÔºâ

#### HaskellÂÆûÁé∞

```haskell
-- BÊ†ëËäÇÁÇπ
data BTreeNode a = BTreeNode
    { keys :: [a]
    , children :: [BTreeNode a]
    , isLeaf :: Bool
    } deriving (Show)

-- BÊ†ë
data BTree a = BTree
    { root :: Maybe (BTreeNode a)
    , order :: Int
    } deriving (Show)

-- BÊ†ëÂÆû‰æã
instance (Ord a) => DataStructure (BTree a) where
    type Element (BTree a) = a
    type Key (BTree a) = a
    
    empty = BTree Nothing 3
    
    isEmpty (BTree Nothing _) = True
    isEmpty _ = False
    
    size (BTree Nothing _) = 0
    size (BTree (Just root) _) = sizeNode root
    
    insert x tree = BTree (insert' x (root tree)) (order tree)
    
    delete x tree = BTree (delete' x (root tree)) (order tree)
    
    lookup x (BTree Nothing _) = Nothing
    lookup x (BTree (Just root) _) = lookupNode x root
    
    member x tree = isJust (lookup x tree)

-- ËäÇÁÇπÂ§ßÂ∞è
sizeNode :: BTreeNode a -> Int
sizeNode node = length (keys node) + sum (map sizeNode (children node))

-- ÊèíÂÖ•Êìç‰Ωú
insert' :: (Ord a) => a -> Maybe (BTreeNode a) -> Maybe (BTreeNode a)
insert' x Nothing = Just (BTreeNode [x] [] True)
insert' x (Just node) = 
    let (newNode, splitKey, splitChild) = insertNode x node
    in if isJust splitChild
       then Just (BTreeNode [splitKey] [newNode, fromJust splitChild] False)
       else Just newNode

-- ËäÇÁÇπÊèíÂÖ•
insertNode :: (Ord a) => a -> BTreeNode a -> (BTreeNode a, a, Maybe (BTreeNode a))
insertNode x node
    | isLeaf node = insertLeaf x node
    | otherwise = insertInternal x node

-- Âè∂Â≠êËäÇÁÇπÊèíÂÖ•
insertLeaf :: (Ord a) => a -> BTreeNode a -> (BTreeNode a, a, Maybe (BTreeNode a))
insertLeaf x node = 
    let newKeys = insertSorted x (keys node)
        maxKeys = 4  -- ÂÅáËÆæBÊ†ëÈò∂Êï∞‰∏∫3
    in if length newKeys <= maxKeys
       then (node { keys = newKeys }, undefined, Nothing)
       else splitLeaf newKeys

-- ÂÜÖÈÉ®ËäÇÁÇπÊèíÂÖ•
insertInternal :: (Ord a) => a -> BTreeNode a -> (BTreeNode a, a, Maybe (BTreeNode a))
insertInternal x node = 
    let childIndex = findChildIndex x (keys node)
        child = children node !! childIndex
        (newChild, splitKey, splitChild) = insertNode x child
        newChildren = updateChild children node childIndex newChild splitChild
        newKeys = if isJust splitChild 
                  then insertSorted splitKey (keys node)
                  else keys node
    in if length newKeys <= 4
       then (node { keys = newKeys, children = newChildren }, undefined, Nothing)
       else splitInternal newKeys newChildren

-- Êü•ÊâæÂ≠êËäÇÁÇπÁ¥¢Âºï
findChildIndex :: (Ord a) => a -> [a] -> Int
findChildIndex x keys = 
    let index = findIndex (> x) keys
    in fromMaybe (length keys) index

-- ÊèíÂÖ•ÊéíÂ∫è
insertSorted :: (Ord a) => a -> [a] -> [a]
insertSorted x [] = [x]
insertSorted x (y:ys)
    | x <= y = x : y : ys
    | otherwise = y : insertSorted x ys

-- Êõ¥Êñ∞Â≠êËäÇÁÇπ
updateChild :: [BTreeNode a] -> Int -> BTreeNode a -> Maybe (BTreeNode a) -> [BTreeNode a]
updateChild children index newChild Nothing = 
    take index children ++ [newChild] ++ drop (index + 1) children
updateChild children index newChild (Just splitChild) = 
    take index children ++ [newChild, splitChild] ++ drop (index + 1) children

-- ÂàÜÂâ≤Âè∂Â≠êËäÇÁÇπ
splitLeaf :: [a] -> (BTreeNode a, a, Maybe (BTreeNode a))
splitLeaf keys = 
    let mid = length keys `div` 2
        leftKeys = take mid keys
        rightKeys = drop (mid + 1) keys
        splitKey = keys !! mid
        leftNode = BTreeNode leftKeys [] True
        rightNode = BTreeNode rightKeys [] True
    in (leftNode, splitKey, Just rightNode)

-- ÂàÜÂâ≤ÂÜÖÈÉ®ËäÇÁÇπ
splitInternal :: [a] -> [BTreeNode a] -> (BTreeNode a, a, Maybe (BTreeNode a))
splitInternal keys children = 
    let mid = length keys `div` 2
        leftKeys = take mid keys
        rightKeys = drop (mid + 1) keys
        splitKey = keys !! mid
        leftChildren = take (mid + 1) children
        rightChildren = drop (mid + 1) children
        leftNode = BTreeNode leftKeys leftChildren False
        rightNode = BTreeNode rightKeys rightChildren False
    in (leftNode, splitKey, Just rightNode)

-- Êü•ÊâæÊìç‰Ωú
lookupNode :: (Ord a) => a -> BTreeNode a -> Maybe a
lookupNode x node
    | isLeaf node = 
        let index = findIndex (== x) (keys node)
        in if isJust index then Just x else Nothing
    | otherwise = 
        let childIndex = findChildIndex x (keys node)
            child = children node !! childIndex
        in lookupNode x child

-- ÊÄßËÉΩÂàÜÊûê
bTreePerformance :: PerformanceMetrics
bTreePerformance = PerformanceMetrics
    { timeComplexity = "O(log n)"
    , spaceComplexity = "O(n)"
    , amortizedCost = "O(log n)"
    , worstCase = "O(log n)"
    }
```

#### ÊÄßËÉΩÂàÜÊûê

**Êó∂Èó¥Â§çÊùÇÂ∫¶**Ôºö

- Êü•ÊâæÔºö$O(\log n)$
- ÊèíÂÖ•Ôºö$O(\log n)$
- Âà†Èô§Ôºö$O(\log n)$

**Á©∫Èó¥Â§çÊùÇÂ∫¶**Ôºö$O(n)$

### 3. Ë∑≥Ë°® (Skip List)

#### ÂΩ¢ÂºèÂåñÂÆö‰πâ

Ë∑≥Ë°®ÊòØ‰∏ÄÁßçÊ¶ÇÁéáÊÄßÊï∞ÊçÆÁªìÊûÑÔºåÈÄöËøáÂª∫Á´ãÂ§öÂ±ÇÈìæË°®Êù•ÂÆûÁé∞È´òÊïàÁöÑÊü•Êâæ„ÄÇ

**Ë∑≥Ë°®ÊÄßË¥®**Ôºö

1. Â∫ïÂ±ÇÈìæË°®ÂåÖÂê´ÊâÄÊúâÂÖÉÁ¥†
2. ‰∏äÂ±ÇÈìæË°®ÊòØ‰∏ãÂ±ÇÈìæË°®ÁöÑÂ≠êÈõÜ
3. ÊØè‰∏™ËäÇÁÇπ‰ª•Ê¶ÇÁéá $1/2$ Âá∫Áé∞Âú®‰∏ä‰∏ÄÂ±Ç

#### HaskellÂÆûÁé∞

```haskell
-- Ë∑≥Ë°®ËäÇÁÇπ
data SkipListNode a = SkipListNode
    { value :: a
    , level :: Int
    , forward :: [Maybe (SkipListNode a)]
    } deriving (Show)

-- Ë∑≥Ë°®
data SkipList a = SkipList
    { header :: SkipListNode a
    , maxLevel :: Int
    , currentLevel :: Int
    } deriving (Show)

-- Ë∑≥Ë°®ÂÆû‰æã
instance (Ord a) => DataStructure (SkipList a) where
    type Element (SkipList a) = a
    type Key (SkipList a) = a
    
    empty = SkipList (SkipListNode undefined 0 []) 16 0
    
    isEmpty (SkipList header _ _) = null (forward header)
    
    size list = countNodes (header list)
    
    insert x list = insert' x list
    
    delete x list = delete' x list
    
    lookup x list = lookup' x list
    
    member x list = isJust (lookup x list)

-- ÂàõÂª∫Ë∑≥Ë°®
createSkipList :: (Ord a) => [a] -> SkipList a
createSkipList xs = 
    let maxLevel = 16
        header = SkipListNode undefined maxLevel (replicate maxLevel Nothing)
        initialList = SkipList header maxLevel 0
    in foldl (\list x -> insert x list) initialList xs

-- ÈöèÊú∫Â±ÇÊï∞
randomLevel :: Int -> Int
randomLevel maxLevel = 
    let random = randomRs (0, 1) (mkStdGen 42) !! 0
    in if random == 0 then 1 else 1 + randomLevel (maxLevel - 1)

-- ÊèíÂÖ•Êìç‰Ωú
insert' :: (Ord a) => a -> SkipList a -> SkipList a
insert' x list = 
    let level = randomLevel (maxLevel list)
        newNode = SkipListNode x level (replicate level Nothing)
        update = replicate (maxLevel list) Nothing
        (newHeader, newUpdate) = findAndUpdate x (header list) update
        newList = updateForwardPointers newHeader newUpdate newNode
    in SkipList newHeader (maxLevel list) (max (currentLevel list) level)

-- Êü•ÊâæÂπ∂Êõ¥Êñ∞
findAndUpdate :: (Ord a) => a -> SkipListNode a -> [Maybe (SkipListNode a)] -> 
                (SkipListNode a, [Maybe (SkipListNode a)])
findAndUpdate x current update = 
    let level = currentLevel current
    in findAndUpdate' x current update level

findAndUpdate' :: (Ord a) => a -> SkipListNode a -> [Maybe (SkipListNode a)] -> Int -> 
                 (SkipListNode a, [Maybe (SkipListNode a)])
findAndUpdate' x current update level
  | level < 0 = (current, update)
  | otherwise = 
      let next = forward current !! level
          (newCurrent, newUpdate) = 
              if isJust next && value (fromJust next) < x
              then findAndUpdate' x (fromJust next) update level
              else (current, update)
          newUpdate' = update // [(level, Just newCurrent)]
      in findAndUpdate' x newCurrent newUpdate' (level - 1)

-- Êõ¥Êñ∞ÂâçÂêëÊåáÈíà
updateForwardPointers :: (Ord a) => SkipListNode a -> [Maybe (SkipListNode a)] -> 
                        SkipListNode a -> SkipListNode a
updateForwardPointers header update newNode = 
    let level = level newNode
        newForward = [if i < level 
                      then Just newNode 
                      else forward header !! i | i <- [0..level-1]]
        newHeader = header { forward = newForward }
    in newHeader

-- Êü•ÊâæÊìç‰Ωú
lookup' :: (Ord a) => a -> SkipList a -> Maybe a
lookup' x list = 
    let (current, _) = findAndUpdate x (header list) (replicate (maxLevel list) Nothing)
        next = forward current !! 0
    in if isJust next && value (fromJust next) == x
       then Just x
       else Nothing

-- Âà†Èô§Êìç‰Ωú
delete' :: (Ord a) => a -> SkipList a -> SkipList a
delete' x list = 
    let update = replicate (maxLevel list) Nothing
        (current, newUpdate) = findAndUpdate x (header list) update
        next = forward current !! 0
    in if isJust next && value (fromJust next) == x
       then deleteNode current (fromJust next) newUpdate list
       else list

-- Âà†Èô§ËäÇÁÇπ
deleteNode :: (Ord a) => SkipListNode a -> SkipListNode a -> [Maybe (SkipListNode a)] -> 
             SkipList a -> SkipList a
deleteNode current target update list = 
    let level = level target
        newForward = [if i < level 
                      then forward target !! i 
                      else forward current !! i | i <- [0..level-1]]
        newCurrent = current { forward = newForward }
        newHeader = header list
    in SkipList newHeader (maxLevel list) (currentLevel list)

-- ËÆ°ÁÆóËäÇÁÇπÊï∞
countNodes :: SkipListNode a -> Int
countNodes node = 
    let next = forward node !! 0
    in if isJust next then 1 + countNodes (fromJust next) else 0

-- ÊÄßËÉΩÂàÜÊûê
skipListPerformance :: PerformanceMetrics
skipListPerformance = PerformanceMetrics
    { timeComplexity = "O(log n) ÊúüÊúõ"
    , spaceComplexity = "O(n)"
    , amortizedCost = "O(log n)"
    , worstCase = "O(n)"
    }
```

#### ÊÄßËÉΩÂàÜÊûê

**Êó∂Èó¥Â§çÊùÇÂ∫¶**Ôºö

- Êü•ÊâæÔºö$O(\log n)$ ÊúüÊúõ
- ÊèíÂÖ•Ôºö$O(\log n)$ ÊúüÊúõ
- Âà†Èô§Ôºö$O(\log n)$ ÊúüÊúõ

**Á©∫Èó¥Â§çÊùÇÂ∫¶**Ôºö$O(n)$

### 4. Trie (ÂâçÁºÄÊ†ë)

#### ÂΩ¢ÂºèÂåñÂÆö‰πâ

TrieÊòØ‰∏ÄÁßçÊ†ëÂΩ¢Êï∞ÊçÆÁªìÊûÑÔºåÁî®‰∫éÂ≠òÂÇ®Â≠óÁ¨¶‰∏≤ÈõÜÂêàÔºåÊîØÊåÅÂâçÁºÄÂåπÈÖç„ÄÇ

**TrieÊÄßË¥®**Ôºö

1. ÊØè‰∏™ËäÇÁÇπË°®Á§∫‰∏Ä‰∏™Â≠óÁ¨¶
2. ‰ªéÊ†πÂà∞Âè∂Â≠êÁöÑË∑ØÂæÑË°®Á§∫‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤
3. ÊîØÊåÅÂâçÁºÄÂåπÈÖçÂíåÊ®°ÂºèÂåπÈÖç

#### HaskellÂÆûÁé∞

```haskell
-- TrieËäÇÁÇπ
data TrieNode = TrieNode
    { children :: Map Char TrieNode
    , isEnd :: Bool
    , value :: Maybe String
    } deriving (Show)

-- Trie
data Trie = Trie
    { root :: TrieNode
    } deriving (Show)

-- TrieÂÆû‰æã
instance DataStructure Trie where
    type Element Trie = String
    type Key Trie = String
    
    empty = Trie (TrieNode Map.empty False Nothing)
    
    isEmpty (Trie root) = Map.null (children root)
    
    size (Trie root) = countWords root
    
    insert word trie = Trie (insertWord word (root trie))
    
    delete word trie = Trie (deleteWord word (root trie))
    
    lookup word (Trie root) = lookupWord word root
    
    member word trie = isJust (lookup word trie)

-- ÊèíÂÖ•ÂçïËØç
insertWord :: String -> TrieNode -> TrieNode
insertWord [] node = node { isEnd = True, value = Just "" }
insertWord (c:cs) node = 
    let child = Map.findWithDefault (TrieNode Map.empty False Nothing) c (children node)
        newChild = insertWord cs child
        newChildren = Map.insert c newChild (children node)
    in node { children = newChildren }

-- Êü•ÊâæÂçïËØç
lookupWord :: String -> TrieNode -> Maybe String
lookupWord [] node = if isEnd node then value node else Nothing
lookupWord (c:cs) node = 
    let child = Map.lookup c (children node)
    in case child of
         Just childNode -> lookupWord cs childNode
         Nothing -> Nothing

-- Âà†Èô§ÂçïËØç
deleteWord :: String -> TrieNode -> TrieNode
deleteWord [] node = node { isEnd = False, value = Nothing }
deleteWord (c:cs) node = 
    let child = Map.lookup c (children node)
    in case child of
         Just childNode -> 
             let newChild = deleteWord cs childNode
                 newChildren = if isEmptyNode newChild
                              then Map.delete c (children node)
                              else Map.insert c newChild (children node)
             in node { children = newChildren }
         Nothing -> node

-- Ê£ÄÊü•ËäÇÁÇπÊòØÂê¶‰∏∫Á©∫
isEmptyNode :: TrieNode -> Bool
isEmptyNode node = not (isEnd node) && Map.null (children node)

-- ËÆ°ÁÆóÂçïËØçÊï∞
countWords :: TrieNode -> Int
countWords node = 
    let childCount = sum (map countWords (Map.elems (children node)))
    in if isEnd node then 1 + childCount else childCount

-- ÂâçÁºÄÂåπÈÖç
prefixMatch :: String -> Trie -> [String]
prefixMatch prefix (Trie root) = 
    let node = findPrefixNode prefix root
    in case node of
         Just n -> collectWords n prefix
         Nothing -> []

-- Êü•ÊâæÂâçÁºÄËäÇÁÇπ
findPrefixNode :: String -> TrieNode -> Maybe TrieNode
findPrefixNode [] node = Just node
findPrefixNode (c:cs) node = 
    let child = Map.lookup c (children node)
    in case child of
         Just childNode -> findPrefixNode cs childNode
         Nothing -> Nothing

-- Êî∂ÈõÜÊâÄÊúâÂçïËØç
collectWords :: TrieNode -> String -> [String]
collectWords node prefix = 
    let childWords = concat [collectWords child (prefix ++ [c]) | 
                            (c, child) <- Map.toList (children node)]
    in if isEnd node 
       then prefix : childWords 
       else childWords

-- ÊÄßËÉΩÂàÜÊûê
triePerformance :: PerformanceMetrics
triePerformance = PerformanceMetrics
    { timeComplexity = "O(m) ÂÖ∂‰∏≠mÊòØÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶"
    , spaceComplexity = "O(ALPHABET_SIZE * m * n)"
    , amortizedCost = "O(m)"
    , worstCase = "O(m)"
    }
```

#### ÊÄßËÉΩÂàÜÊûê

**Êó∂Èó¥Â§çÊùÇÂ∫¶**Ôºö

- Êü•ÊâæÔºö$O(m)$ÔºåÂÖ∂‰∏≠ $m$ ÊòØÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶
- ÊèíÂÖ•Ôºö$O(m)$
- Âà†Èô§Ôºö$O(m)$

**Á©∫Èó¥Â§çÊùÇÂ∫¶**Ôºö$O(ALPHABET\_SIZE \cdot m \cdot n)$

### 5. Âπ∂Êü•ÈõÜ (Union-Find)

#### ÂΩ¢ÂºèÂåñÂÆö‰πâ

Âπ∂Êü•ÈõÜÊòØ‰∏ÄÁßçÊ†ëÂΩ¢Êï∞ÊçÆÁªìÊûÑÔºåÁî®‰∫éÂ§ÑÁêÜ‰∏çÁõ∏‰∫§ÈõÜÂêàÁöÑÂêàÂπ∂ÂíåÊü•ËØ¢Êìç‰Ωú„ÄÇ

**Âπ∂Êü•ÈõÜÊìç‰Ωú**Ôºö

1. **MakeSet(x)**ÔºöÂàõÂª∫ÂåÖÂê´ÂÖÉÁ¥†xÁöÑÊñ∞ÈõÜÂêà
2. **Union(x, y)**ÔºöÂêàÂπ∂ÂåÖÂê´xÂíåyÁöÑÈõÜÂêà
3. **Find(x)**ÔºöÊü•ÊâæxÊâÄÂ±ûÁöÑÈõÜÂêà‰ª£Ë°®

#### HaskellÂÆûÁé∞

```haskell
-- Âπ∂Êü•ÈõÜËäÇÁÇπ
data UnionFindNode a = UnionFindNode
    { element :: a
    , parent :: Maybe (UnionFindNode a)
    , rank :: Int
    } deriving (Show)

-- Âπ∂Êü•ÈõÜ
data UnionFind a = UnionFind
    { nodes :: Map a (UnionFindNode a)
    } deriving (Show)

-- Âπ∂Êü•ÈõÜÂÆû‰æã
instance (Ord a) => DataStructure (UnionFind a) where
    type Element (UnionFind a) = a
    type Key (UnionFind a) = a
    
    empty = UnionFind Map.empty
    
    isEmpty (UnionFind nodes) = Map.null nodes
    
    size (UnionFind nodes) = Map.size nodes
    
    insert x uf = makeSet x uf
    
    delete x uf = deleteSet x uf
    
    lookup x uf = find x uf
    
    member x (UnionFind nodes) = Map.member x nodes

-- ÂàõÂª∫ÈõÜÂêà
makeSet :: (Ord a) => a -> UnionFind a -> UnionFind a
makeSet x (UnionFind nodes) = 
    let node = UnionFindNode x Nothing 0
        newNodes = Map.insert x node nodes
    in UnionFind newNodes

-- Êü•ÊâæÊìç‰Ωú
find :: (Ord a) => a -> UnionFind a -> Maybe a
find x (UnionFind nodes) = 
    let node = Map.lookup x nodes
    in case node of
         Just n -> Just (element (findRoot n))
         Nothing -> Nothing

-- Êü•ÊâæÊ†πËäÇÁÇπ
findRoot :: UnionFindNode a -> UnionFindNode a
findRoot node = 
    case parent node of
         Just parentNode -> 
             let root = findRoot parentNode
                 newParent = Just root
             in node { parent = newParent }  -- Ë∑ØÂæÑÂéãÁº©
         Nothing -> node

-- ÂêàÂπ∂Êìç‰Ωú
union :: (Ord a) => a -> a -> UnionFind a -> UnionFind a
union x y uf = 
    let rootX = findRootNode x uf
        rootY = findRootNode y uf
    in case (rootX, rootY) of
         (Just rx, Just ry) -> 
             if element rx == element ry
             then uf
             else unionByRank rx ry uf
         _ -> uf

-- ÊåâÁß©ÂêàÂπ∂
unionByRank :: (Ord a) => UnionFindNode a -> UnionFindNode a -> UnionFind a -> UnionFind a
unionByRank rootX rootY (UnionFind nodes) = 
    let rankX = rank rootX
        rankY = rank rootY
        (newRootX, newRootY, newRank) = 
            if rankX < rankY
            then (rootX, rootY, rankY)
            else if rankX > rankY
                 then (rootY, rootX, rankX)
                 else (rootX, rootY, rankX + 1)
        newParentX = newRootX { parent = Just newRootY }
        newRootY' = newRootY { rank = newRank }
        newNodes = Map.insert (element newParentX) newParentX 
                           (Map.insert (element newRootY') newRootY' nodes)
    in UnionFind newNodes

-- Êü•ÊâæÊ†πËäÇÁÇπ
findRootNode :: (Ord a) => a -> UnionFind a -> Maybe (UnionFindNode a)
findRootNode x (UnionFind nodes) = 
    let node = Map.lookup x nodes
    in case node of
         Just n -> Just (findRoot n)
         Nothing -> Nothing

-- Âà†Èô§ÈõÜÂêà
deleteSet :: (Ord a) => a -> UnionFind a -> UnionFind a
deleteSet x (UnionFind nodes) = 
    let newNodes = Map.delete x nodes
    in UnionFind newNodes

-- Ê£ÄÊü•ËøûÈÄöÊÄß
isConnected :: (Ord a) => a -> a -> UnionFind a -> Bool
isConnected x y uf = 
    let rootX = find x uf
        rootY = find y uf
    in case (rootX, rootY) of
         (Just rx, Just ry) -> rx == ry
         _ -> False

-- Ëé∑ÂèñËøûÈÄöÂàÜÈáèÊï∞
connectedComponents :: (Ord a) => UnionFind a -> Int
connectedComponents (UnionFind nodes) = 
    let roots = Set.fromList [element (findRoot node) | node <- Map.elems nodes]
    in Set.size roots

-- ÊÄßËÉΩÂàÜÊûê
unionFindPerformance :: PerformanceMetrics
unionFindPerformance = PerformanceMetrics
    { timeComplexity = "O(Œ±(n)) ÂÖ∂‰∏≠Œ±ÊòØÈòøÂÖãÊõºÂáΩÊï∞ÁöÑÂèçÂáΩÊï∞"
    , spaceComplexity = "O(n)"
    , amortizedCost = "O(Œ±(n))"
    , worstCase = "O(log n)"
    }
```

#### ÊÄßËÉΩÂàÜÊûê

**Êó∂Èó¥Â§çÊùÇÂ∫¶**Ôºö

- Êü•ÊâæÔºö$O(\alpha(n))$Ôºà‰ΩøÁî®Ë∑ØÂæÑÂéãÁº©ÂíåÊåâÁß©ÂêàÂπ∂Ôºâ
- ÂêàÂπ∂Ôºö$O(\alpha(n))$
- ÂàõÂª∫Ôºö$O(1)$

**Á©∫Èó¥Â§çÊùÇÂ∫¶**Ôºö$O(n)$

## üìä Êï∞ÊçÆÁªìÊûÑÊØîËæÉ

### ÊÄßËÉΩÂØπÊØîË°®

| Êï∞ÊçÆÁªìÊûÑ | Êü•Êâæ | ÊèíÂÖ• | Âà†Èô§ | Á©∫Èó¥Â§çÊùÇÂ∫¶ | ÁâπÁÇπ |
|----------|------|------|------|------------|------|
| Á∫¢ÈªëÊ†ë | O(log n) | O(log n) | O(log n) | O(n) | Ëá™Âπ≥Ë°° |
| BÊ†ë | O(log n) | O(log n) | O(log n) | O(n) | Á£ÅÁõòÂèãÂ•Ω |
| Ë∑≥Ë°® | O(log n) ÊúüÊúõ | O(log n) ÊúüÊúõ | O(log n) ÊúüÊúõ | O(n) | Ê¶ÇÁéáÊÄß |
| Trie | O(m) | O(m) | O(m) | O(ALPHABET*m*n) | Â≠óÁ¨¶‰∏≤Â§ÑÁêÜ |
| Âπ∂Êü•ÈõÜ | O(Œ±(n)) | O(Œ±(n)) | O(Œ±(n)) | O(n) | ÈõÜÂêàÊìç‰Ωú |

### ÈÄâÊã©ÊåáÂçó

```haskell
-- Êï∞ÊçÆÁªìÊûÑÈÄâÊã©ÂáΩÊï∞
chooseDataStructure :: String -> String
chooseDataStructure "ordered_map" = "Á∫¢ÈªëÊ†ë"
chooseDataStructure "disk_storage" = "BÊ†ë"
chooseDataStructure "probabilistic" = "Ë∑≥Ë°®"
chooseDataStructure "string_processing" = "Trie"
chooseDataStructure "set_operations" = "Âπ∂Êü•ÈõÜ"
chooseDataStructure _ = "Ê†πÊçÆÂÖ∑‰ΩìÈúÄÊ±ÇÈÄâÊã©"

-- Êô∫ËÉΩÊï∞ÊçÆÁªìÊûÑÈÄâÊã©
smartDataStructure :: String -> String -> String
smartDataStructure "access" "random" = "Á∫¢ÈªëÊ†ë"
smartDataStructure "access" "sequential" = "BÊ†ë"
smartDataStructure "memory" "efficient" = "Ë∑≥Ë°®"
smartDataStructure "data" "strings" = "Trie"
smartDataStructure "operation" "union_find" = "Âπ∂Êü•ÈõÜ"
smartDataStructure _ _ = "ÈúÄË¶ÅÊõ¥Â§ö‰ø°ÊÅØ"
```

## üî¨ ÂΩ¢ÂºèÂåñÈ™åËØÅ

### Ê≠£Á°ÆÊÄßËØÅÊòé

#### Á∫¢ÈªëÊ†ëÂπ≥Ë°°ÊÄß

**ÂÆöÁêÜ**ÔºöÁ∫¢ÈªëÊ†ëÁöÑÈ´òÂ∫¶ÊúÄÂ§ö‰∏∫ $2\log(n+1)$„ÄÇ

**ËØÅÊòé**Ôºö

1. **ÈªëÈ´òÂ∫¶**Ôºö‰ªéÊ†πÂà∞Âè∂Â≠êÁöÑÈªëËäÇÁÇπÊï∞Áõ∏Âêå
2. **Á∫¢ËäÇÁÇπÈôêÂà∂**ÔºöÁ∫¢ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπÈÉΩÊòØÈªëËâ≤
3. **È´òÂ∫¶ÈôêÂà∂**Ôºö$h \leq 2\log(n+1)$

#### Âπ∂Êü•ÈõÜÂ§çÊùÇÂ∫¶

**ÂÆöÁêÜ**Ôºö‰ΩøÁî®Ë∑ØÂæÑÂéãÁº©ÂíåÊåâÁß©ÂêàÂπ∂ÁöÑÂπ∂Êü•ÈõÜÔºåÂçïÊ¨°Êìç‰ΩúÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ $O(\alpha(n))$„ÄÇ

**ËØÅÊòé**Ôºö

1. **Ë∑ØÂæÑÂéãÁº©**ÔºöÂ∞ÜÊü•ÊâæË∑ØÂæÑ‰∏äÁöÑÊâÄÊúâËäÇÁÇπÁõ¥Êé•ËøûÊé•Âà∞Ê†π
2. **ÊåâÁß©ÂêàÂπ∂**ÔºöÊÄªÊòØÂ∞ÜËæÉÂ∞èÁöÑÊ†ëËøûÊé•Âà∞ËæÉÂ§ßÁöÑÊ†ë
3. **Â§çÊùÇÂ∫¶ÂàÜÊûê**Ôºö‰ΩøÁî®ÈòøÂÖãÊõºÂáΩÊï∞ÁöÑÂèçÂáΩÊï∞ÂàÜÊûê

### Â§çÊùÇÂ∫¶ËØÅÊòé

#### BÊ†ëÈ´òÂ∫¶

**ÂÆöÁêÜ**ÔºöBÊ†ëÁöÑÈ´òÂ∫¶‰∏∫ $O(\log_m n)$ÔºåÂÖ∂‰∏≠ $m$ ÊòØBÊ†ëÁöÑÈò∂„ÄÇ

**ËØÅÊòé**Ôºö

- ÊØè‰∏™ÂÜÖÈÉ®ËäÇÁÇπËá≥Â∞ëÊúâ $m/2$ ‰∏™Â≠êËäÇÁÇπ
- È´òÂ∫¶‰∏∫ $h$ ÁöÑBÊ†ëËá≥Â∞ëÊúâ $2(m/2)^{h-1}$ ‰∏™Âè∂Â≠êËäÇÁÇπ
- $n \geq 2(m/2)^{h-1}$ÔºåÂõ†Ê≠§ $h \leq \log_{m/2}(n/2) + 1$

## üéØ ÂÆûÈôÖÂ∫îÁî®

### ÊÄßËÉΩÊµãËØï

```haskell
-- ÊÄßËÉΩÊµãËØïÂáΩÊï∞
testDataStructurePerformance :: IO ()
testDataStructurePerformance = do
    putStrLn "Êï∞ÊçÆÁªìÊûÑÊÄßËÉΩÊµãËØï"
    putStrLn "=================="
    
    let testStructure name createFunc insertFunc lookupFunc = do
            start <- getCurrentTime
            let structure = createFunc
                structure' = foldl (\s x -> insertFunc x s) structure [1..1000]
                _ = map (\x -> lookupFunc x structure') [1..1000]
            end <- getCurrentTime
            let duration = diffUTCTime end start
            putStrLn $ name ++ ": " ++ show duration
    
    -- ÊµãËØïÁ∫¢ÈªëÊ†ë
    let rbTree = empty :: RedBlackTree Int
    testStructure "Á∫¢ÈªëÊ†ë" rbTree insert lookup
    
    -- ÊµãËØïTrie
    let trie = empty :: Trie
    testStructure "Trie" trie insert lookup

-- Âü∫ÂáÜÊµãËØï
benchmarkDataStructures :: IO ()
benchmarkDataStructures = do
    putStrLn "Êï∞ÊçÆÁªìÊûÑÂü∫ÂáÜÊµãËØï"
    putStrLn "=================="
    
    let testData = [1..10000]
        testOperations = 1000
    
    -- ÊµãËØïÊèíÂÖ•ÊÄßËÉΩ
    putStrLn "ÊèíÂÖ•ÊÄßËÉΩÊµãËØï:"
    let rbInsertTime = measureInsertTime (empty :: RedBlackTree Int) testData
    putStrLn $ "Á∫¢ÈªëÊ†ëÊèíÂÖ•Êó∂Èó¥: " ++ show rbInsertTime
    
    -- ÊµãËØïÊü•ÊâæÊÄßËÉΩ
    putStrLn "Êü•ÊâæÊÄßËÉΩÊµãËØï:"
    let rbTree = foldl (\s x -> insert x s) (empty :: RedBlackTree Int) testData
        rbLookupTime = measureLookupTime rbTree testOperations
    putStrLn $ "Á∫¢ÈªëÊ†ëÊü•ÊâæÊó∂Èó¥: " ++ show rbLookupTime

-- ÊµãÈáèÊèíÂÖ•Êó∂Èó¥
measureInsertTime :: (DataStructure ds, Element ds ~ Int) => ds -> [Int] -> Double
measureInsertTime structure dataList = 
    let start = getCurrentTime
        finalStructure = foldl (\s x -> insert x s) structure dataList
        end = getCurrentTime
    in diffUTCTime end start

-- ÊµãÈáèÊü•ÊâæÊó∂Èó¥
measureLookupTime :: (DataStructure ds, Element ds ~ Int) => ds -> Int -> Double
measureLookupTime structure operations = 
    let start = getCurrentTime
        _ = map (\x -> lookup x structure) [1..operations]
        end = getCurrentTime
    in diffUTCTime end start
```

### ÂÆûÈôÖÂ∫îÁî®Âú∫ÊôØ

1. **Êï∞ÊçÆÂ∫ìÁ≥ªÁªü**ÔºöBÊ†ëÁî®‰∫éÁ¥¢ÂºïÁªìÊûÑ
2. **ÁºñËØëÂô®**ÔºöTrieÁî®‰∫éÁ¨¶Âè∑Ë°®
3. **ÁΩëÁªúË∑ØÁî±**ÔºöÂπ∂Êü•ÈõÜÁî®‰∫éËøûÈÄöÊÄßÊ£ÄÊµã
4. **ÊñáÊú¨ÁºñËæëÂô®**ÔºöÁ∫¢ÈªëÊ†ëÁî®‰∫éÊúâÂ∫èÊï∞ÊçÆÁªìÊûÑ
5. **ÁºìÂ≠òÁ≥ªÁªü**ÔºöË∑≥Ë°®Áî®‰∫éÂø´ÈÄüÊü•Êâæ

## üìö Êâ©Â±ïÈòÖËØª

### È´òÁ∫ßÊï∞ÊçÆÁªìÊûÑ

1. **ÊñêÊ≥¢ÈÇ£Â•ëÂ†Ü**ÔºöÊîØÊåÅÈ´òÊïàÁöÑÂêàÂπ∂Êìç‰Ωú
2. **van Emde BoasÊ†ë**ÔºöÊîØÊåÅÊï¥Êï∞ÈõÜÂêàÁöÑÈ´òÊïàÊìç‰Ωú
3. **ÊåÅ‰πÖÂåñÊï∞ÊçÆÁªìÊûÑ**ÔºöÊîØÊåÅÂéÜÂè≤ÁâàÊú¨Êü•ËØ¢
4. **Âπ∂ÂèëÊï∞ÊçÆÁªìÊûÑ**ÔºöÊîØÊåÅÂ§öÁ∫øÁ®ãÂÆâÂÖ®Êìç‰Ωú
5. **Â§ñÈÉ®Â≠òÂÇ®Êï∞ÊçÆÁªìÊûÑ**Ôºö‰ºòÂåñÁ£ÅÁõòI/O

### Âπ∂Ë°åÊï∞ÊçÆÁªìÊûÑ

```haskell
-- Âπ∂Ë°åÁ∫¢ÈªëÊ†ë
parallelRedBlackTree :: (Ord a) => [a] -> RedBlackTree a
parallelRedBlackTree xs = 
    let chunks = chunksOf (length xs `div` numCapabilities) xs
        trees = map (\chunk -> foldl (\t x -> insert x t) empty chunk) chunks
    in mergeTrees trees

-- ÂêàÂπ∂Â§ö‰∏™Á∫¢ÈªëÊ†ë
mergeTrees :: (Ord a) => [RedBlackTree a] -> RedBlackTree a
mergeTrees [] = empty
mergeTrees [tree] = tree
mergeTrees trees = 
    let (left, right) = splitAt (length trees `div` 2) trees
        leftTree = mergeTrees left
        rightTree = mergeTrees right
    in mergeTwoTrees leftTree rightTree

-- ÂêàÂπ∂‰∏§‰∏™Á∫¢ÈªëÊ†ë
mergeTwoTrees :: (Ord a) => RedBlackTree a -> RedBlackTree a -> RedBlackTree a
mergeTwoTrees left right = 
    let elements = collectElements left ++ collectElements right
    in foldl (\t x -> insert x t) empty elements

-- Êî∂ÈõÜÊ†ë‰∏≠ÊâÄÊúâÂÖÉÁ¥†
collectElements :: RedBlackTree a -> [a]
collectElements Empty = []
collectElements (Node _ left value right) = 
    collectElements left ++ [value] ++ collectElements right
```

## üîó Áõ∏ÂÖ≥ÈìæÊé•

- [Âü∫Á°ÄÊï∞ÊçÆÁªìÊûÑ](../01-Haskell-Basics/01-Language-Features.md)
- [ÊéíÂ∫èÁÆóÊ≥ï](../02-Algorithms/01-Sorting-Algorithms.md)
- [ÂõæÁÆóÊ≥ï](../02-Algorithms/02-Graph-Algorithms.md)
- [ÂΩ¢ÂºèÂåñËØÅÊòé](../04-Formal-Proofs/01-Theorem-Proving.md)
- [ÊÄßËÉΩ‰ºòÂåñ](../05-Performance-Optimization/01-Memory-Optimization.md)

---

*Êú¨ÊñáÊ°£Êèê‰æõ‰∫ÜÈ´òÁ∫ßÊï∞ÊçÆÁªìÊûÑÁöÑÂÆåÊï¥ÂΩ¢ÂºèÂåñÁêÜËÆ∫ÂíåHaskellÂÆûÁé∞ÔºåÂåÖÊã¨ÊÄßËÉΩÂàÜÊûêÂíåÂÆûÈôÖÂ∫îÁî®ÊåáÂØº„ÄÇ*
