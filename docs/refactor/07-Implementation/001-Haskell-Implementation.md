# 001-HaskellÂÆûÁé∞

## üìö Ê¶ÇËø∞

Êú¨ÊñáÊ°£Êèê‰æõHaskellÁºñÁ®ãËØ≠Ë®ÄÁöÑÂÆåÊï¥ÂÆûÁé∞ÊåáÂçóÔºåÂåÖÊã¨Ê†∏ÂøÉÊ¶ÇÂøµ„ÄÅÈ´òÁ∫ßÁâπÊÄß„ÄÅÊúÄ‰Ω≥ÂÆûË∑µÂíåÂÆûÈôÖÂ∫îÁî®Ê°à‰æã„ÄÇ

## üéØ Ê†∏ÂøÉÁõÆÊ†á

1. **ËØ≠Ë®ÄÁâπÊÄß**: Ê∑±ÂÖ•ÁêÜËß£HaskellÁöÑÊ†∏ÂøÉÁâπÊÄß
2. **ÂáΩÊï∞ÂºèÁºñÁ®ã**: ÊéåÊè°Á∫ØÂáΩÊï∞ÂºèÁºñÁ®ãËåÉÂºè
3. **Á±ªÂûãÁ≥ªÁªü**: Âà©Áî®Âº∫Â§ßÁöÑÁ±ªÂûãÁ≥ªÁªü
4. **ÂÆûÈôÖÂ∫îÁî®**: ÊûÑÂª∫ÂÆûÁî®ÁöÑHaskellÁ®ãÂ∫è

## üèóÔ∏è Ê†∏ÂøÉÊ¶ÇÂøµ

### 1. Âü∫Êú¨ËØ≠Ê≥ï

```haskell
-- Ê®°ÂùóÂ£∞Êòé
module Main where

-- ÂØºÂÖ•Ê®°Âùó
import Data.List (sort, nub)
import Data.Maybe (fromJust, isJust)
import Control.Monad (when, unless)
import System.IO (putStrLn, getLine)

-- Á±ªÂûãÂ£∞Êòé
type Name = String
type Age = Int
type Person = (Name, Age)

-- Êï∞ÊçÆÂ£∞Êòé
data Color = Red | Green | Blue | Yellow
    deriving (Show, Eq, Ord)

-- ËÆ∞ÂΩïËØ≠Ê≥ï
data PersonRecord = PersonRecord {
    name :: String,
    age :: Int,
    email :: String
} deriving (Show, Eq)

-- ÂáΩÊï∞ÂÆö‰πâ
add :: Int -> Int -> Int
add x y = x + y

-- Ê®°ÂºèÂåπÈÖç
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)

-- ÂÆàÂç´Ë°®ËææÂºè
absolute :: Int -> Int
absolute x
    | x < 0 = -x
    | otherwise = x

-- whereÂ≠êÂè•
calculateArea :: Double -> Double -> Double
calculateArea width height = area
    where
        area = width * height
        perimeter = 2 * (width + height)

-- letË°®ËææÂºè
calculateVolume :: Double -> Double -> Double -> Double
calculateVolume length width height = 
    let area = length * width
        volume = area * height
    in volume
```

### 2. È´òÈò∂ÂáΩÊï∞

```haskell
-- ÂáΩÊï∞‰Ωú‰∏∫ÂèÇÊï∞
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)

-- ÂáΩÊï∞‰Ωú‰∏∫ËøîÂõûÂÄº
makeAdder :: Int -> (Int -> Int)
makeAdder x = \y -> x + y

-- mapÂáΩÊï∞
doubleList :: [Int] -> [Int]
doubleList xs = map (*2) xs

-- filterÂáΩÊï∞
filterEven :: [Int] -> [Int]
filterEven xs = filter even xs

-- foldrÂáΩÊï∞
sumList :: [Int] -> Int
sumList xs = foldr (+) 0 xs

-- ÂáΩÊï∞ÁªÑÂêà
compose :: (b -> c) -> (a -> b) -> (a -> c)
compose f g = \x -> f (g x)

-- ÁÆ°ÈÅìÊìç‰ΩúÁ¨¶
(|>) :: a -> (a -> b) -> b
x |> f = f x

-- Ëá™ÂÆö‰πâÈ´òÈò∂ÂáΩÊï∞
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
```

### 3. Á±ªÂûãÁ≥ªÁªü

```haskell
-- Á±ªÂûãÁ±ª
class Show a where
    show :: a -> String

-- ÂÆû‰æãÂ£∞Êòé
instance Show Color where
    show Red = "Red"
    show Green = "Green"
    show Blue = "Blue"
    show Yellow = "Yellow"

-- Â§öÂèÇÊï∞Á±ªÂûãÁ±ª
class Eq a => Ord a where
    compare :: a -> a -> Ordering
    (<) :: a -> a -> Bool
    (<=) :: a -> a -> Bool
    (>) :: a -> a -> Bool
    (>=) :: a -> a -> Bool
    max :: a -> a -> a
    min :: a -> a -> a

-- ÈªòËÆ§ÂÆûÁé∞
instance Ord Color where
    compare Red Red = EQ
    compare Red _ = LT
    compare Green Red = GT
    compare Green Green = EQ
    compare Green _ = LT
    compare Blue Red = GT
    compare Blue Green = GT
    compare Blue Blue = EQ
    compare Blue _ = LT
    compare Yellow _ = GT

-- Ê≥õÂûãÁ±ªÂûã
data Maybe a = Nothing | Just a
    deriving (Show, Eq, Ord)

-- Á±ªÂûãÂà´Âêç
type String = [Char]
type IntList = [Int]
type IntMap = [(Int, Int)]

-- Êñ∞Á±ªÂûã
newtype Age = Age Int
    deriving (Show, Eq, Ord, Num)

-- Á±ªÂûãÊóè
type family ElementType (f :: * -> *) :: *
type instance ElementType [] = a
type instance ElementType Maybe = a
```

### 4. ÂçïÂ≠ê

```haskell
-- MaybeÂçïÂ≠ê
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

-- ‰ΩøÁî®Maybe
calculateResult :: Double -> Double -> Double -> Maybe Double
calculateResult x y z = do
    temp <- safeDivide x y
    safeDivide temp z

-- EitherÂçïÂ≠ê
safeSqrt :: Double -> Either String Double
safeSqrt x
    | x < 0 = Left "Cannot take square root of negative number"
    | otherwise = Right (sqrt x)

-- ÂàóË°®ÂçïÂ≠ê
pairs :: [Int] -> [Int] -> [(Int, Int)]
pairs xs ys = do
    x <- xs
    y <- ys
    return (x, y)

-- IOÂçïÂ≠ê
main :: IO ()
main = do
    putStrLn "Enter your name:"
    name <- getLine
    putStrLn ("Hello, " ++ name ++ "!")

-- Ëá™ÂÆö‰πâÂçïÂ≠ê
data State s a = State { runState :: s -> (a, s) }

instance Functor (State s) where
    fmap f (State g) = State $ \s -> 
        let (a, s') = g s in (f a, s')

instance Applicative (State s) where
    pure a = State $ \s -> (a, s)
    (State f) <*> (State g) = State $ \s ->
        let (h, s') = f s
            (a, s'') = g s'
        in (h a, s'')

instance Monad (State s) where
    return = pure
    (State f) >>= g = State $ \s ->
        let (a, s') = f s
            State h = g a
        in h s'

-- StateÂçïÂ≠êÊìç‰Ωú
get :: State s s
get = State $ \s -> (s, s)

put :: s -> State s ()
put s = State $ \_ -> ((), s)

modify :: (s -> s) -> State s ()
modify f = State $ \s -> ((), f s)
```

### 5. È´òÁ∫ßÁâπÊÄß

```haskell
-- ÊÉ∞ÊÄßÊ±ÇÂÄº
infiniteList :: [Int]
infiniteList = [1..]

-- ÂèñÂâç10‰∏™ÂÖÉÁ¥†
firstTen :: [Int]
firstTen = take 10 infiniteList

-- Êó†ÈôêÈÄíÂΩí
fibonacci :: [Integer]
fibonacci = 0 : 1 : zipWith (+) fibonacci (tail fibonacci)

-- Á±ªÂûãÊóè
class Collection c where
    type Element c
    empty :: c
    insert :: Element c -> c -> c
    member :: Element c -> c -> Bool

instance Collection [a] where
    type Element [a] = a
    empty = []
    insert = (:)
    member = elem

-- GADT (Âπø‰πâ‰ª£Êï∞Êï∞ÊçÆÁ±ªÂûã)
data Expr a where
    LitInt :: Int -> Expr Int
    LitBool :: Bool -> Expr Bool
    Add :: Expr Int -> Expr Int -> Expr Int
    And :: Expr Bool -> Expr Bool -> Expr Bool
    If :: Expr Bool -> Expr a -> Expr a -> Expr a

-- Á±ªÂûãÂÆâÂÖ®ÁöÑÊ±ÇÂÄº
eval :: Expr a -> a
eval (LitInt n) = n
eval (LitBool b) = b
eval (Add e1 e2) = eval e1 + eval e2
eval (And e1 e2) = eval e1 && eval e2
eval (If cond thenExpr elseExpr) = 
    if eval cond then eval thenExpr else eval elseExpr

-- Â≠òÂú®Á±ªÂûã
data SomeExpr = forall a. Show a => SomeExpr (Expr a)

-- Á±ªÂûãÂÆâÂÖ®ÁöÑÂ∫èÂàóÂåñ
showExpr :: SomeExpr -> String
showExpr (SomeExpr expr) = show (eval expr)
```

## üî¨ ÂÆûÈôÖÂ∫îÁî®

### 1. ÂáΩÊï∞ÂºèÊï∞ÊçÆÁªìÊûÑ

```haskell
-- ‰∏çÂèØÂèòÂàóË°®
data List a = Nil | Cons a (List a)
    deriving (Show, Eq)

-- ÂàóË°®Êìç‰Ωú
length' :: List a -> Int
length' Nil = 0
length' (Cons _ xs) = 1 + length' xs

append :: List a -> List a -> List a
append Nil ys = ys
append (Cons x xs) ys = Cons x (append xs ys)

reverse' :: List a -> List a
reverse' Nil = Nil
reverse' (Cons x xs) = append (reverse' xs) (Cons x Nil)

-- ‰∫åÂèâÊ†ë
data Tree a = Empty | Node a (Tree a) (Tree a)
    deriving (Show, Eq)

-- Ê†ëÊìç‰Ωú
insertTree :: Ord a => a -> Tree a -> Tree a
insertTree x Empty = Node x Empty Empty
insertTree x (Node y left right)
    | x < y = Node y (insertTree x left) right
    | x > y = Node y left (insertTree x right)
    | otherwise = Node y left right

searchTree :: Ord a => a -> Tree a -> Bool
searchTree _ Empty = False
searchTree x (Node y left right)
    | x == y = True
    | x < y = searchTree x left
    | otherwise = searchTree x right

-- Âπ≥Ë°°Ê†ë
data AVLTree a = AVLEmpty | AVLNode a (AVLTree a) (AVLTree a) Int
    deriving (Show, Eq)

height :: AVLTree a -> Int
height AVLEmpty = 0
height (AVLNode _ _ _ h) = h

balance :: AVLTree a -> AVLTree a
balance AVLEmpty = AVLEmpty
balance (AVLNode x left right _) = 
    let leftHeight = height left
        rightHeight = height right
        balanceFactor = leftHeight - rightHeight
    in if balanceFactor > 1
       then rotateRight (AVLNode x left right 0)
       else if balanceFactor < -1
            then rotateLeft (AVLNode x left right 0)
            else AVLNode x left right (max leftHeight rightHeight + 1)

rotateLeft :: AVLTree a -> AVLTree a
rotateLeft (AVLNode x left (AVLNode y middle right _) _) = 
    AVLNode y (AVLNode x left middle 0) right 0
rotateLeft tree = tree

rotateRight :: AVLTree a -> AVLTree a
rotateRight (AVLNode x (AVLNode y left middle _) right _) = 
    AVLNode y left (AVLNode x middle right 0) 0
rotateRight tree = tree
```

### 2. Ëß£ÊûêÂô®ÁªÑÂêàÂ≠ê

```haskell
-- Ëß£ÊûêÂô®Á±ªÂûã
newtype Parser a = Parser { 
    runParser :: String -> Maybe (a, String) 
}

-- Âü∫Êú¨Ëß£ÊûêÂô®
char :: Char -> Parser Char
char c = Parser $ \s -> 
    case s of
        (x:xs) | x == c -> Just (c, xs)
        _ -> Nothing

string :: String -> Parser String
string [] = Parser $ \s -> Just ([], s)
string (c:cs) = Parser $ \s -> 
    case runParser (char c) s of
        Just (_, rest) -> 
            case runParser (string cs) rest of
                Just (str, rest') -> Just (c:str, rest')
                Nothing -> Nothing
        Nothing -> Nothing

-- Ëß£ÊûêÂô®ÁªÑÂêàÂ≠ê
(<|>) :: Parser a -> Parser a -> Parser a
p1 <|> p2 = Parser $ \s -> 
    case runParser p1 s of
        Just result -> Just result
        Nothing -> runParser p2 s

many :: Parser a -> Parser [a]
many p = many1 p <|> return []

many1 :: Parser a -> Parser [a]
many1 p = do
    x <- p
    xs <- many p
    return (x:xs)

-- ÂçïÂ≠êÂÆû‰æã
instance Functor Parser where
    fmap f (Parser p) = Parser $ \s -> 
        case p s of
            Just (a, rest) -> Just (f a, rest)
            Nothing -> Nothing

instance Applicative Parser where
    pure a = Parser $ \s -> Just (a, s)
    (Parser f) <*> (Parser p) = Parser $ \s -> 
        case f s of
            Just (g, rest) -> 
                case p rest of
                    Just (a, rest') -> Just (g a, rest')
                    Nothing -> Nothing
            Nothing -> Nothing

instance Monad Parser where
    return = pure
    (Parser p) >>= f = Parser $ \s -> 
        case p s of
            Just (a, rest) -> runParser (f a) rest
            Nothing -> Nothing

-- Êï∞Â≠óËß£ÊûêÂô®
digit :: Parser Char
digit = Parser $ \s -> 
    case s of
        (c:cs) | isDigit c -> Just (c, cs)
        _ -> Nothing

number :: Parser Int
number = do
    digits <- many1 digit
    return (read digits)

-- Ë°®ËææÂºèËß£ÊûêÂô®
data Expr' = Lit Int | Add Expr' Expr' | Mul Expr' Expr'
    deriving (Show)

expr :: Parser Expr'
expr = term `chainl1` addOp

term :: Parser Expr'
term = factor `chainl1` mulOp

factor :: Parser Expr'
factor = number >>= \n -> return (Lit n)
     <|> do
         char '('
         e <- expr
         char ')'
         return e

addOp :: Parser (Expr' -> Expr' -> Expr')
addOp = char '+' >> return Add
     <|> char '-' >> return (\x y -> Add x (Mul (Lit (-1)) y))

mulOp :: Parser (Expr' -> Expr' -> Expr')
mulOp = char '*' >> return Mul

chainl1 :: Parser a -> Parser (a -> a -> a) -> Parser a
chainl1 p op = do
    x <- p
    rest x
  where
    rest x = do
        f <- op
        y <- p
        rest (f x y)
     <|> return x
```

### 3. Âπ∂ÂèëÁºñÁ®ã

```haskell
-- ËΩØ‰ª∂‰∫ãÂä°ÂÜÖÂ≠ò (STM)
import Control.Concurrent.STM

-- Èì∂Ë°åË¥¶Êà∑
data Account = Account {
    balance :: TVar Int,
    name :: String
}

-- ÂàõÂª∫Ë¥¶Êà∑
newAccount :: String -> Int -> STM Account
newAccount name initialBalance = do
    bal <- newTVar initialBalance
    return Account { balance = bal, name = name }

-- Â≠òÊ¨æ
deposit :: Account -> Int -> STM ()
deposit account amount = do
    bal <- readTVar (balance account)
    writeTVar (balance account) (bal + amount)

-- ÂèñÊ¨æ
withdraw :: Account -> Int -> STM Bool
withdraw account amount = do
    bal <- readTVar (balance account)
    if bal >= amount
        then do
            writeTVar (balance account) (bal - amount)
            return True
        else return False

-- ËΩ¨Ë¥¶
transfer :: Account -> Account -> Int -> STM Bool
transfer from to amount = do
    success <- withdraw from amount
    if success
        then do
            deposit to amount
            return True
        else return False

-- ÂéüÂ≠êÊìç‰Ωú
atomicTransfer :: Account -> Account -> Int -> IO Bool
atomicTransfer from to amount = atomically $ transfer from to amount

-- Âπ∂ÂèëÁ§∫‰æã
concurrentExample :: IO ()
concurrentExample = do
    account1 <- atomically $ newAccount "Alice" 1000
    account2 <- atomically $ newAccount "Bob" 500
    
    -- ÂêØÂä®Â§ö‰∏™Âπ∂ÂèëËΩ¨Ë¥¶
    forkIO $ do
        result <- atomicTransfer account1 account2 100
        putStrLn $ "Transfer 1: " ++ show result
    
    forkIO $ do
        result <- atomicTransfer account2 account1 50
        putStrLn $ "Transfer 2: " ++ show result
    
    -- Á≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥
    threadDelay 1000000
    
    -- Ê£ÄÊü•ÊúÄÁªà‰ΩôÈ¢ù
    bal1 <- atomically $ readTVar (balance account1)
    bal2 <- atomically $ readTVar (balance account2)
    
    putStrLn $ "Final balances: Alice=" ++ show bal1 ++ ", Bob=" ++ show bal2
```

## üìä ÊúÄ‰Ω≥ÂÆûË∑µ

### 1. ÈîôËØØÂ§ÑÁêÜ

```haskell
-- ‰ΩøÁî®EitherËøõË°åÈîôËØØÂ§ÑÁêÜ
safeDivide :: Double -> Double -> Either String Double
safeDivide _ 0 = Left "Division by zero"
safeDivide x y = Right (x / y)

-- ÈîôËØØÂ§ÑÁêÜÁªÑÂêà
calculateResult :: Double -> Double -> Double -> Either String Double
calculateResult x y z = do
    temp <- safeDivide x y
    safeDivide temp z

-- Ëá™ÂÆö‰πâÈîôËØØÁ±ªÂûã
data CalculationError = 
    DivisionByZero | 
    NegativeNumber | 
    Overflow
    deriving (Show, Eq)

-- Â∏¶ÈîôËØØÁ±ªÂûãÁöÑËÆ°ÁÆó
safeSqrt :: Double -> Either CalculationError Double
safeSqrt x
    | x < 0 = Left NegativeNumber
    | x > 1e6 = Left Overflow
    | otherwise = Right (sqrt x)
```

### 2. ÊÄßËÉΩ‰ºòÂåñ

```haskell
-- ‰∏•Ê†ºÊ±ÇÂÄº
{-# LANGUAGE BangPatterns #-}

-- ‰∏•Ê†ºÁ¥ØÂä†
strictSum :: [Int] -> Int
strictSum xs = go 0 xs
  where
    go !acc [] = acc
    go !acc (x:xs) = go (acc + x) xs

-- ‰ΩøÁî®seqÂº∫Âà∂Ê±ÇÂÄº
forceEval :: a -> a
forceEval x = x `seq` x

-- ÂÜÖÂ≠ò‰ºòÂåñ
data StrictList a = SNil | SCons !a !(StrictList a)
    deriving (Show)

-- ‰∏•Ê†ºÂàóË°®Êìç‰Ωú
strictMap :: (a -> b) -> StrictList a -> StrictList b
strictMap _ SNil = SNil
strictMap f (SCons x xs) = SCons (f x) (strictMap f xs)
```

### 3. ÊµãËØï

```haskell
-- ‰ΩøÁî®QuickCheckËøõË°åÂ±ûÊÄßÊµãËØï
import Test.QuickCheck

-- ÊµãËØïÂ±ûÊÄß
prop_reverse :: [Int] -> Bool
prop_reverse xs = reverse (reverse xs) == xs

prop_sort :: [Int] -> Bool
prop_sort xs = isSorted (sort xs)
  where
    isSorted [] = True
    isSorted [x] = True
    isSorted (x:y:ys) = x <= y && isSorted (y:ys)

-- Ëá™ÂÆö‰πâÁîüÊàêÂô®
data Tree a = Leaf | Node a (Tree a) (Tree a)
    deriving (Show, Eq)

instance Arbitrary a => Arbitrary (Tree a) where
    arbitrary = sized genTree
      where
        genTree 0 = return Leaf
        genTree n = frequency [
            (1, return Leaf),
            (3, do
                x <- arbitrary
                left <- genTree (n `div` 2)
                right <- genTree (n `div` 2)
                return (Node x left right))
        ]

-- ÊµãËØïÊ†ëÁöÑÊÄßË¥®
prop_treeSize :: Tree Int -> Bool
prop_treeSize Leaf = True
prop_treeSize (Node _ left right) = 
    treeSize (Node 0 left right) == 1 + treeSize left + treeSize right
  where
    treeSize Leaf = 0
    treeSize (Node _ left right) = 1 + treeSize left + treeSize right
```

## üéØ ÁêÜËÆ∫ÊÄªÁªì

### 1. HaskellÁâπÊÄßÂÆåÊï¥ÊÄß

- ‚úÖ **Á∫ØÂáΩÊï∞Âºè**: Êó†ÂâØ‰ΩúÁî®„ÄÅÂºïÁî®ÈÄèÊòé
- ‚úÖ **ÊÉ∞ÊÄßÊ±ÇÂÄº**: ÊåâÈúÄËÆ°ÁÆó„ÄÅÊó†ÈôêÊï∞ÊçÆÁªìÊûÑ
- ‚úÖ **Âº∫Á±ªÂûãÁ≥ªÁªü**: ÈùôÊÄÅÁ±ªÂûãÊ£ÄÊü•„ÄÅÁ±ªÂûãÊé®ÂØº
- ‚úÖ **È´òÈò∂ÂáΩÊï∞**: ÂáΩÊï∞‰Ωú‰∏∫‰∏ÄÁ≠âÂÖ¨Ê∞ë

### 2. ÂÆûÈôÖÂ∫îÁî®ËÉΩÂäõ

- ‚úÖ **Êï∞ÊçÆÁªìÊûÑ**: ‰∏çÂèØÂèò„ÄÅÂáΩÊï∞ÂºèÊï∞ÊçÆÁªìÊûÑ
- ‚úÖ **Ëß£ÊûêÂô®**: Ëß£ÊûêÂô®ÁªÑÂêàÂ≠êÊäÄÊúØ
- ‚úÖ **Âπ∂ÂèëÁºñÁ®ã**: STM„ÄÅËΩØ‰ª∂‰∫ãÂä°ÂÜÖÂ≠ò
- ‚úÖ **ÈîôËØØÂ§ÑÁêÜ**: Either„ÄÅMaybeÁ±ªÂûã

### 3. Â∑•Á®ãÂÆûË∑µ

- ‚úÖ **ÊÄßËÉΩ‰ºòÂåñ**: ‰∏•Ê†ºÊ±ÇÂÄº„ÄÅÂÜÖÂ≠òÁÆ°ÁêÜ
- ‚úÖ **ÊµãËØï**: Â±ûÊÄßÊµãËØï„ÄÅQuickCheck
- ‚úÖ **ÊúÄ‰Ω≥ÂÆûË∑µ**: ÈîôËØØÂ§ÑÁêÜ„ÄÅ‰ª£Á†ÅÁªÑÁªá

## üîó Áõ∏ÂÖ≥ÈìæÊé•

- [002-Rust-Implementation.md](./002-Rust-Implementation.md) - RustÂÆûÁé∞
- [003-Lean-Implementation.md](./003-Lean-Implementation.md) - LeanÂÆûÁé∞
- [001-Programming-Language-Theory.md](../03-Theory/001-Programming-Language-Theory.md) - ÁºñÁ®ãËØ≠Ë®ÄÁêÜËÆ∫

---

**Êñá‰ª∂Áä∂ÊÄÅ**: ‚úÖ ÂÆåÊàê  
**ÊúÄÂêéÊõ¥Êñ∞**: 2024Âπ¥12Êúà  
**ÁêÜËÆ∫Ê∑±Â∫¶**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**‰ª£Á†ÅË¥®Èáè**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
