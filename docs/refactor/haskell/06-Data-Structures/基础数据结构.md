# 基础数据结构

## 概述

基础数据结构是函数式编程中的核心概念，它们提供了组织和管理数据的基本方式。本文档从数学基础到Haskell实现，全面介绍基础数据结构。

## 数学基础

### 代数数据类型

**定义**: 代数数据类型是类型系统的代数结构。

$$\text{ADT} = \text{Sum} + \text{Product} + \text{Exponential}$$

其中：
- **Sum类型**: $A + B$ - 联合类型
- **Product类型**: $A \times B$ - 积类型  
- **Exponential类型**: $A^B$ - 函数类型

### 类型同构

两个类型 $A$ 和 $B$ 同构，记作 $A \cong B$，如果存在双射：

$$f: A \to B \text{ 和 } g: B \to A$$

满足：
$$g \circ f = \text{id}_A \text{ 和 } f \circ g = \text{id}_B$$

### 函子性质

数据结构作为函子满足：

$$F(\text{id}) = \text{id} \text{ 和 } F(g \circ f) = F(g) \circ F(f)$$

## Haskell实现

### 列表 (List)

```haskell
-- 列表类型定义
data List a = Nil | Cons a (List a)

-- 列表函子实例
instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x xs) = Cons (f x) (fmap f xs)

-- 列表单子实例
instance Monad List where
    return x = Cons x Nil
    Nil >>= _ = Nil
    Cons x xs >>= f = append (f x) (xs >>= f)

-- 列表操作
append :: List a -> List a -> List a
append Nil ys = ys
append (Cons x xs) ys = Cons x (append xs ys)

length :: List a -> Int
length Nil = 0
length (Cons _ xs) = 1 + length xs

head :: List a -> Maybe a
head Nil = Nothing
head (Cons x _) = Just x

tail :: List a -> Maybe (List a)
tail Nil = Nothing
tail (Cons _ xs) = Just xs

-- 列表推导
listComprehension :: List Int -> List Int
listComprehension xs = 
    [x * 2 | x <- xs, x > 0]

-- 等价于
listComprehension' :: List Int -> List Int
listComprehension' xs = 
    xs >>= \x -> 
        if x > 0 
            then return (x * 2) 
            else Nil
```

### 树 (Tree)

```haskell
-- 二叉树定义
data Tree a = Leaf a | Node (Tree a) a (Tree a)

-- 树函子实例
instance Functor Tree where
    fmap f (Leaf x) = Leaf (f x)
    fmap f (Node l x r) = Node (fmap f l) (f x) (fmap f r)

-- 树操作
size :: Tree a -> Int
size (Leaf _) = 1
size (Node l _ r) = 1 + size l + size r

height :: Tree a -> Int
height (Leaf _) = 0
height (Node l _ r) = 1 + max (height l) (height r)

-- 树遍历
inorder :: Tree a -> [a]
inorder (Leaf x) = [x]
inorder (Node l x r) = inorder l ++ [x] ++ inorder r

preorder :: Tree a -> [a]
preorder (Leaf x) = [x]
preorder (Node l x r) = [x] ++ preorder l ++ preorder r

postorder :: Tree a -> [a]
postorder (Leaf x) = [x]
postorder (Node l x r) = postorder l ++ postorder r ++ [x]

-- 平衡二叉树
data AVLTree a = Empty | AVLNode (AVLTree a) a (AVLTree a) Int

balance :: AVLTree a -> AVLTree a
balance Empty = Empty
balance (AVLNode l x r h) = 
    let balanceFactor = height l - height r
    in if abs balanceFactor <= 1
           then AVLNode l x r h
           else if balanceFactor > 1
                    then rotateRight (AVLNode l x r h)
                    else rotateLeft (AVLNode l x r h)

rotateLeft :: AVLTree a -> AVLTree a
rotateLeft (AVLNode l x (AVLNode rl y rr _) _) = 
    AVLNode (AVLNode l x rl 0) y rr 0
rotateLeft t = t

rotateRight :: AVLTree a -> AVLTree a
rotateRight (AVLNode (AVLNode ll y lr _) x r _) = 
    AVLNode ll y (AVLNode lr x r 0) 0
rotateRight t = t
```

### 堆 (Heap)

```haskell
-- 最小堆定义
data MinHeap a = EmptyHeap | Heap a (MinHeap a) (MinHeap a)

-- 堆操作
insert :: Ord a => a -> MinHeap a -> MinHeap a
insert x EmptyHeap = Heap x EmptyHeap EmptyHeap
insert x (Heap y l r) = 
    if x <= y
        then Heap x (insert y r) l
        else Heap y (insert x r) l

deleteMin :: Ord a => MinHeap a -> Maybe (a, MinHeap a)
deleteMin EmptyHeap = Nothing
deleteMin (Heap x l r) = Just (x, merge l r)

merge :: Ord a => MinHeap a -> MinHeap a -> MinHeap a
merge EmptyHeap h = h
merge h EmptyHeap = h
merge (Heap x l1 r1) (Heap y l2 r2) = 
    if x <= y
        then Heap x (merge r1 (Heap y l2 r2)) l1
        else Heap y (merge (Heap x l1 r1) r2) l2

-- 堆排序
heapSort :: Ord a => [a] -> [a]
heapSort xs = heapSort' (buildHeap xs)
  where
    buildHeap = foldr insert EmptyHeap
    heapSort' EmptyHeap = []
    heapSort' h = 
        case deleteMin h of
            Just (x, h') -> x : heapSort' h'
            Nothing -> []
```

### 栈 (Stack)

```haskell
-- 栈定义
newtype Stack a = Stack [a]

-- 栈操作
empty :: Stack a
empty = Stack []

isEmpty :: Stack a -> Bool
isEmpty (Stack []) = True
isEmpty _ = False

push :: a -> Stack a -> Stack a
push x (Stack xs) = Stack (x:xs)

pop :: Stack a -> Maybe (a, Stack a)
pop (Stack []) = Nothing
pop (Stack (x:xs)) = Just (x, Stack xs)

top :: Stack a -> Maybe a
top (Stack []) = Nothing
top (Stack (x:_)) = Just x

-- 栈函子实例
instance Functor Stack where
    fmap f (Stack xs) = Stack (fmap f xs)

-- 栈应用示例
evaluateRPN :: String -> Maybe Double
evaluateRPN = evaluate . words
  where
    evaluate [] = top (Stack [])
    evaluate (x:xs) = 
        case reads x of
            [(n, "")] -> evaluate xs >>= \s -> evaluate (xs ++ [show n])
            _ -> case x of
                "+" -> binaryOp (+) xs
                "-" -> binaryOp (-) xs
                "*" -> binaryOp (*) xs
                "/" -> binaryOp (/) xs
                _ -> Nothing
    
    binaryOp op xs = 
        case (pop (Stack xs), pop (Stack xs)) of
            (Just (a, s1), Just (b, s2)) -> 
                evaluate (show (b `op` a) : xs)
            _ -> Nothing
```

### 队列 (Queue)

```haskell
-- 队列定义
data Queue a = Queue [a] [a]

-- 队列操作
emptyQueue :: Queue a
emptyQueue = Queue [] []

isEmptyQueue :: Queue a -> Bool
isEmptyQueue (Queue [] []) = True
isEmptyQueue _ = False

enqueue :: a -> Queue a -> Queue a
enqueue x (Queue front back) = Queue front (x:back)

dequeue :: Queue a -> Maybe (a, Queue a)
dequeue (Queue [] []) = Nothing
dequeue (Queue [] back) = dequeue (Queue (reverse back) [])
dequeue (Queue (x:front) back) = Just (x, Queue front back)

front :: Queue a -> Maybe a
front q = fmap fst (dequeue q)

-- 队列函子实例
instance Functor Queue where
    fmap f (Queue front back) = Queue (fmap f front) (fmap f back)

-- 队列应用示例
breadthFirstSearch :: Tree a -> [a]
breadthFirstSearch = bfs emptyQueue
  where
    bfs q t = 
        if isEmptyQueue q
            then []
            else case dequeue q of
                Just (x, q') -> x : bfs q' t
                Nothing -> []
    
    enqueueTree (Leaf x) q = enqueue x q
    enqueueTree (Node l x r) q = 
        enqueue x (enqueueTree r (enqueueTree l q))
```

### 集合 (Set)

```haskell
-- 集合定义
data Set a = EmptySet | SetNode a (Set a) (Set a)

-- 集合操作
emptySet :: Set a
emptySet = EmptySet

isEmptySet :: Set a -> Bool
isEmptySet EmptySet = True
isEmptySet _ = False

insert :: Ord a => a -> Set a -> Set a
insert x EmptySet = SetNode x EmptySet EmptySet
insert x (SetNode y l r) = 
    case compare x y of
        LT -> SetNode y (insert x l) r
        EQ -> SetNode y l r
        GT -> SetNode y l (insert x r)

member :: Ord a => a -> Set a -> Bool
member _ EmptySet = False
member x (SetNode y l r) = 
    case compare x y of
        LT -> member x l
        EQ -> True
        GT -> member x r

delete :: Ord a => a -> Set a -> Set a
delete _ EmptySet = EmptySet
delete x (SetNode y l r) = 
    case compare x y of
        LT -> SetNode y (delete x l) r
        EQ -> merge l r
        GT -> SetNode y l (delete x r)

merge :: Set a -> Set a -> Set a
merge EmptySet s = s
merge s EmptySet = s
merge (SetNode x l r) s = 
    SetNode x l (merge r s)

-- 集合运算
union :: Ord a => Set a -> Set a -> Set a
union EmptySet s = s
union s EmptySet = s
union (SetNode x l r) s = 
    insert x (union l (union r s))

intersection :: Ord a => Set a -> Set a -> Set a
intersection EmptySet _ = EmptySet
intersection _ EmptySet = EmptySet
intersection (SetNode x l r) s = 
    if member x s
        then insert x (intersection l (intersection r s))
        else intersection l (intersection r s)

difference :: Ord a => Set a -> Set a -> Set a
difference EmptySet _ = EmptySet
difference s EmptySet = s
difference (SetNode x l r) s = 
    if member x s
        then difference l (difference r s)
        else insert x (difference l (difference r s))
```

### 映射 (Map)

```haskell
-- 映射定义
data Map k v = EmptyMap | MapNode k v (Map k v) (Map k v)

-- 映射操作
emptyMap :: Map k v
emptyMap = EmptyMap

isEmptyMap :: Map k v -> Bool
isEmptyMap EmptyMap = True
isEmptyMap _ = False

insert :: Ord k => k -> v -> Map k v -> Map k v
insert k v EmptyMap = MapNode k v EmptyMap EmptyMap
insert k v (MapNode k' v' l r) = 
    case compare k k' of
        LT -> MapNode k' v' (insert k v l) r
        EQ -> MapNode k v l r
        GT -> MapNode k' v' l (insert k v r)

lookup :: Ord k => k -> Map k v -> Maybe v
lookup _ EmptyMap = Nothing
lookup k (MapNode k' v' l r) = 
    case compare k k' of
        LT -> lookup k l
        EQ -> Just v'
        GT -> lookup k r

delete :: Ord k => k -> Map k v -> Map k v
delete _ EmptyMap = EmptyMap
delete k (MapNode k' v' l r) = 
    case compare k k' of
        LT -> MapNode k' v' (delete k l) r
        EQ -> mergeMap l r
        GT -> MapNode k' v' l (delete k r)

mergeMap :: Map k v -> Map k v -> Map k v
mergeMap EmptyMap m = m
mergeMap m EmptyMap = m
mergeMap (MapNode k v l r) m = 
    MapNode k v l (mergeMap r m)

-- 映射函子实例
instance Functor (Map k) where
    fmap _ EmptyMap = EmptyMap
    fmap f (MapNode k v l r) = MapNode k (f v) (fmap f l) (fmap f r)

-- 映射应用示例
wordCount :: String -> Map String Int
wordCount = foldr increment emptyMap . words
  where
    increment word = insert word (maybe 1 (+1) (lookup word))
```

## 高级数据结构

### 持久化数据结构

```haskell
-- 持久化列表
data PersistentList a = Nil | Cons a (PersistentList a)

-- 持久化操作
cons :: a -> PersistentList a -> PersistentList a
cons x xs = Cons x xs

head :: PersistentList a -> Maybe a
head Nil = Nothing
head (Cons x _) = Just x

tail :: PersistentList a -> Maybe (PersistentList a)
tail Nil = Nothing
tail (Cons _ xs) = Just xs

-- 持久化栈
data PersistentStack a = EmptyStack | StackNode a (PersistentStack a)

push :: a -> PersistentStack a -> PersistentStack a
push x s = StackNode x s

pop :: PersistentStack a -> Maybe (a, PersistentStack a)
pop EmptyStack = Nothing
pop (StackNode x s) = Just (x, s)

-- 持久化队列
data PersistentQueue a = Queue [a] [a]

enqueue :: a -> PersistentQueue a -> PersistentQueue a
enqueue x (Queue front back) = Queue front (x:back)

dequeue :: PersistentQueue a -> Maybe (a, PersistentQueue a)
dequeue (Queue [] []) = Nothing
dequeue (Queue [] back) = dequeue (Queue (reverse back) [])
dequeue (Queue (x:front) back) = Just (x, Queue front back)
```

### 函数式数据结构

```haskell
-- 不可变数组
newtype ImmutableArray a = ImmutableArray [a]

-- 不可变数组操作
fromList :: [a] -> ImmutableArray a
fromList = ImmutableArray

toList :: ImmutableArray a -> [a]
toList (ImmutableArray xs) = xs

update :: Int -> a -> ImmutableArray a -> ImmutableArray a
update i x (ImmutableArray xs) = 
    ImmutableArray (updateList i x xs)
  where
    updateList 0 x (_:xs) = x:xs
    updateList i x (y:ys) = y:updateList (i-1) x ys
    updateList _ _ [] = []

-- 不可变数组函子实例
instance Functor ImmutableArray where
    fmap f (ImmutableArray xs) = ImmutableArray (fmap f xs)

-- 函数式哈希表
data HashTable k v = HashTable (Map Int [(k, v)])

hash :: (Hashable k) => k -> Int
hash = fromIntegral . hashWithSalt 0

insert :: (Hashable k, Ord k) => k -> v -> HashTable k v -> HashTable k v
insert k v (HashTable m) = 
    let h = hash k
        bucket = Map.findWithDefault [] h m
        newBucket = (k, v) : filter ((/= k) . fst) bucket
    in HashTable (Map.insert h newBucket m)

lookup :: (Hashable k, Ord k) => k -> HashTable k v -> Maybe v
lookup k (HashTable m) = 
    let h = hash k
        bucket = Map.findWithDefault [] h m
    in lookup k bucket
  where
    lookup _ [] = Nothing
    lookup k ((k', v):xs) = 
        if k == k' then Just v else lookup k xs
```

## 性能优化

### 数据结构优化

```haskell
-- 优化的列表操作
optimizedAppend :: [a] -> [a] -> [a]
optimizedAppend [] ys = ys
optimizedAppend (x:xs) ys = x : optimizedAppend xs ys

-- 差异列表
newtype DList a = DList { runDList :: [a] -> [a] }

instance Monoid (DList a) where
    mempty = DList id
    DList f `mappend` DList g = DList (f . g)

fromDList :: DList a -> [a]
fromDList (DList f) = f []

toDList :: [a] -> DList a
toDList xs = DList (xs ++)

-- 优化的树操作
balancedInsert :: Ord a => a -> Tree a -> Tree a
balancedInsert x t = balance (insertUnbalanced x t)
  where
    insertUnbalanced x (Leaf y) = 
        if x <= y 
            then Node (Leaf x) y (Leaf y)
            else Node (Leaf y) y (Leaf x)
    insertUnbalanced x (Node l y r) = 
        if x <= y
            then Node (insertUnbalanced x l) y r
            else Node l y (insertUnbalanced x r)
```

### 内存优化

```haskell
-- 共享数据结构
data SharedList a = SharedList [a] (SharedList a)

-- 共享操作
share :: [a] -> SharedList a
share xs = SharedList xs (share xs)

-- 延迟数据结构
data LazyList a = LazyList a (LazyList a)

-- 延迟操作
lazyMap :: (a -> b) -> LazyList a -> LazyList b
lazyMap f (LazyList x xs) = LazyList (f x) (lazyMap f xs)

-- 缓存数据结构
data CachedList a = CachedList [a] (Map Int a)

-- 缓存操作
cachedLookup :: Int -> CachedList a -> Maybe a
cachedLookup i (CachedList xs cache) = 
    Map.lookup i cache <|> 
    (if i >= 0 && i < length xs 
        then Just (xs !! i) 
        else Nothing)
```

## 总结

基础数据结构是函数式编程的核心，它们提供了组织和管理数据的基本方式。通过严格的数学定义和Haskell的类型系统，这些数据结构确保了程序的正确性和可组合性。

### 关键要点

1. **数学基础**: 数据结构基于代数数据类型和类型同构
2. **类型安全**: Haskell的类型系统确保数据结构使用的正确性
3. **不可变性**: 函数式数据结构是不可变的，支持持久化
4. **实际应用**: 在算法实现、数据处理、系统设计等领域有广泛应用

### 进一步学习

- 高级数据结构
- 算法复杂度分析
- 数据结构优化
- 函数式编程模式
