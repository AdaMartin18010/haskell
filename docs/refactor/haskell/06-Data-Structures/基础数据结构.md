# 基础数据结构

## 概述

基础数据结构是Haskell编程的基石，它们提供了存储和组织数据的基本方式。这些数据结构基于数学理论，特别是集合论和代数结构，为函数式编程提供了高效、安全的数据操作。

## 数学基础

### 集合论基础

在集合论中，数据结构可以形式化为：

$$\text{DataStructure} = (A, \mathcal{O}, \mathcal{R})$$

其中：
- $A$ 是数据元素的集合
- $\mathcal{O}$ 是操作集合
- $\mathcal{R}$ 是关系集合

### 代数结构

数据结构满足特定的代数定律：

$$\text{AlgebraicLaws}: \mathcal{O} \times A \to A$$

## 基本数据结构

### 1. 列表 (List)

#### 数学定义

列表是递归定义的数据结构：

$$\text{List}(A) = \text{Nil} + A \times \text{List}(A)$$

#### Haskell实现

```haskell
-- 列表数据类型
data List a = Nil | Cons a (List a) deriving Show

-- 列表操作
empty :: List a
empty = Nil

isEmpty :: List a -> Bool
isEmpty Nil = True
isEmpty _ = False

head :: List a -> Maybe a
head Nil = Nothing
head (Cons x _) = Just x

tail :: List a -> Maybe (List a)
tail Nil = Nothing
tail (Cons _ xs) = Just xs

-- 列表构造
singleton :: a -> List a
singleton x = Cons x Nil

-- 列表连接
append :: List a -> List a -> List a
append Nil ys = ys
append (Cons x xs) ys = Cons x (append xs ys)

-- 数学表示：
-- $\text{append}(\text{Nil}, ys) = ys$
-- $\text{append}(\text{Cons}(x, xs), ys) = \text{Cons}(x, \text{append}(xs, ys))$

-- 列表长度
length :: List a -> Int
length Nil = 0
length (Cons _ xs) = 1 + length xs

-- 列表映射
map :: (a -> b) -> List a -> List b
map _ Nil = Nil
map f (Cons x xs) = Cons (f x) (map f xs)

-- 数学表示：
-- $\text{map}(f, \text{Nil}) = \text{Nil}$
-- $\text{map}(f, \text{Cons}(x, xs)) = \text{Cons}(f(x), \text{map}(f, xs))$

-- 列表过滤
filter :: (a -> Bool) -> List a -> List a
filter _ Nil = Nil
filter p (Cons x xs) = 
    if p x 
        then Cons x (filter p xs)
        else filter p xs

-- 数学表示：
-- $\text{filter}(p, \text{Nil}) = \text{Nil}$
-- $\text{filter}(p, \text{Cons}(x, xs)) = \text{if } p(x) \text{ then } \text{Cons}(x, \text{filter}(p, xs)) \text{ else } \text{filter}(p, xs)$
```

#### 列表应用

```haskell
-- 列表处理示例
processList :: List Int -> List String
processList = map show . filter (>0)

-- 列表反转
reverse :: List a -> List a
reverse = reverseHelper Nil
  where
    reverseHelper acc Nil = acc
    reverseHelper acc (Cons x xs) = reverseHelper (Cons x acc) xs

-- 数学表示：
-- $\text{reverse}(xs) = \text{reverseHelper}(\text{Nil}, xs)$
-- $\text{reverseHelper}(acc, \text{Nil}) = acc$
-- $\text{reverseHelper}(acc, \text{Cons}(x, xs)) = \text{reverseHelper}(\text{Cons}(x, acc), xs)$
```

### 2. 元组 (Tuple)

#### 数学定义

元组是笛卡尔积的表示：

$$\text{Tuple}(A, B) = A \times B$$

#### Haskell实现

```haskell
-- 元组操作
fst :: (a, b) -> a
fst (x, _) = x

snd :: (a, b) -> b
snd (_, y) = y

-- 元组构造
pair :: a -> b -> (a, b)
pair x y = (x, y)

-- 元组映射
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapFst f (x, y) = (f x, y)

mapSnd :: (b -> c) -> (a, b) -> (a, c)
mapSnd f (x, y) = (x, f y)

-- 数学表示：
-- $\text{mapFst}(f, (x, y)) = (f(x), y)$
-- $\text{mapSnd}(f, (x, y)) = (x, f(y))$

-- 元组交换
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)

-- 数学表示：
-- $\text{swap}((x, y)) = (y, x)$
```

### 3. Maybe类型

#### 数学定义

Maybe类型表示可选值：

$$\text{Maybe}(A) = \text{Nothing} + \text{Just}(A)$$

#### Haskell实现

```haskell
-- Maybe类型定义
data Maybe a = Nothing | Just a deriving Show

-- Maybe操作
isJust :: Maybe a -> Bool
isJust Nothing = False
isJust (Just _) = True

isNothing :: Maybe a -> Bool
isNothing = not . isJust

fromJust :: Maybe a -> a
fromJust (Just x) = x
fromJust Nothing = error "fromJust: Nothing"

fromMaybe :: a -> Maybe a -> a
fromMaybe _ (Just x) = x
fromMaybe d Nothing = d

-- 数学表示：
-- $\text{fromMaybe}(d, \text{Just}(x)) = x$
-- $\text{fromMaybe}(d, \text{Nothing}) = d$

-- Maybe映射
maybe :: b -> (a -> b) -> Maybe a -> b
maybe _ f (Just x) = f x
maybe d _ Nothing = d

-- 数学表示：
-- $\text{maybe}(d, f, \text{Just}(x)) = f(x)$
-- $\text{maybe}(d, f, \text{Nothing}) = d$
```

### 4. Either类型

#### 数学定义

Either类型表示联合类型：

$$\text{Either}(A, B) = \text{Left}(A) + \text{Right}(B)$$

#### Haskell实现

```haskell
-- Either类型定义
data Either a b = Left a | Right b deriving Show

-- Either操作
isLeft :: Either a b -> Bool
isLeft (Left _) = True
isLeft (Right _) = False

isRight :: Either a b -> Bool
isRight = not . isLeft

fromLeft :: a -> Either a b -> a
fromLeft _ (Left x) = x
fromLeft d (Right _) = d

fromRight :: b -> Either a b -> b
fromRight _ (Right x) = x
fromRight d (Left _) = d

-- 数学表示：
-- $\text{fromLeft}(d, \text{Left}(x)) = x$
-- $\text{fromLeft}(d, \text{Right}(_)) = d$

-- Either映射
either :: (a -> c) -> (b -> c) -> Either a b -> c
either f _ (Left x) = f x
either _ g (Right y) = g y

-- 数学表示：
-- $\text{either}(f, g, \text{Left}(x)) = f(x)$
-- $\text{either}(f, g, \text{Right}(y)) = g(y)$
```

## 高级基础结构

### 1. 栈 (Stack)

#### 数学定义

栈是后进先出(LIFO)的数据结构：

$$\text{Stack}(A) = \text{Empty} + A \times \text{Stack}(A)$$

#### Haskell实现

```haskell
-- 栈数据类型
newtype Stack a = Stack [a] deriving Show

-- 栈操作
emptyStack :: Stack a
emptyStack = Stack []

isEmptyStack :: Stack a -> Bool
isEmptyStack (Stack xs) = null xs

push :: a -> Stack a -> Stack a
push x (Stack xs) = Stack (x:xs)

pop :: Stack a -> Maybe (a, Stack a)
pop (Stack []) = Nothing
pop (Stack (x:xs)) = Just (x, Stack xs)

peek :: Stack a -> Maybe a
peek (Stack []) = Nothing
peek (Stack (x:_)) = Just x

-- 数学表示：
-- $\text{push}(x, \text{Stack}(xs)) = \text{Stack}(x:xs)$
-- $\text{pop}(\text{Stack}([])) = \text{Nothing}$
-- $\text{pop}(\text{Stack}(x:xs)) = \text{Just}((x, \text{Stack}(xs)))$

-- 栈大小
size :: Stack a -> Int
size (Stack xs) = length xs

-- 栈转换
toList :: Stack a -> [a]
toList (Stack xs) = xs

fromList :: [a] -> Stack a
fromList = Stack
```

### 2. 队列 (Queue)

#### 数学定义

队列是先进先出(FIFO)的数据结构：

$$\text{Queue}(A) = \text{Empty} + A \times \text{Queue}(A)$$

#### Haskell实现

```haskell
-- 队列数据类型
data Queue a = Queue [a] [a] deriving Show

-- 队列操作
emptyQueue :: Queue a
emptyQueue = Queue [] []

isEmptyQueue :: Queue a -> Bool
isEmptyQueue (Queue [] []) = True
isEmptyQueue _ = False

enqueue :: a -> Queue a -> Queue a
enqueue x (Queue front back) = Queue front (x:back)

dequeue :: Queue a -> Maybe (a, Queue a)
dequeue (Queue [] []) = Nothing
dequeue (Queue [] back) = dequeue (Queue (reverse back) [])
dequeue (Queue (x:front) back) = Just (x, Queue front back)

peekQueue :: Queue a -> Maybe a
peekQueue (Queue [] []) = Nothing
peekQueue (Queue [] back) = peekQueue (Queue (reverse back) [])
peekQueue (Queue (x:_) _) = Just x

-- 数学表示：
-- $\text{enqueue}(x, \text{Queue}(front, back)) = \text{Queue}(front, x:back)$
-- $\text{dequeue}(\text{Queue}([], [])) = \text{Nothing}$
-- $\text{dequeue}(\text{Queue}(x:front, back)) = \text{Just}((x, \text{Queue}(front, back)))$

-- 队列大小
queueSize :: Queue a -> Int
queueSize (Queue front back) = length front + length back
```

### 3. 集合 (Set)

#### 数学定义

集合是无序、无重复元素的数据结构：

$$\text{Set}(A) = \mathcal{P}(A)$$

#### Haskell实现

```haskell
-- 集合数据类型
newtype Set a = Set [a] deriving Show

-- 集合操作
emptySet :: Set a
emptySet = Set []

isEmptySet :: Set a -> Bool
isEmptySet (Set xs) = null xs

insert :: Eq a => a -> Set a -> Set a
insert x (Set xs) = 
    if x `elem` xs 
        then Set xs 
        else Set (x:xs)

delete :: Eq a => a -> Set a -> Set a
delete x (Set xs) = Set (filter (/= x) xs)

member :: Eq a => a -> Set a -> Bool
member x (Set xs) = x `elem` xs

-- 数学表示：
-- $\text{insert}(x, \text{Set}(xs)) = \text{if } x \in xs \text{ then } \text{Set}(xs) \text{ else } \text{Set}(x:xs)$
-- $\text{member}(x, \text{Set}(xs)) = x \in xs$

-- 集合运算
union :: Eq a => Set a -> Set a -> Set a
union (Set xs) (Set ys) = Set (xs ++ filter (`notElem` xs) ys)

intersection :: Eq a => Set a -> Set a -> Set a
intersection (Set xs) (Set ys) = Set (filter (`elem` ys) xs)

difference :: Eq a => Set a -> Set a -> Set a
difference (Set xs) (Set ys) = Set (filter (`notElem` ys) xs)

-- 数学表示：
-- $\text{union}(A, B) = A \cup B$
-- $\text{intersection}(A, B) = A \cap B$
-- $\text{difference}(A, B) = A \setminus B$

-- 集合大小
setSize :: Set a -> Int
setSize (Set xs) = length xs
```

## 数据结构定律

### 1. 列表定律

```haskell
-- 列表定律验证
listLaw1 :: [a] -> Bool
listLaw1 xs = xs ++ [] == xs  -- 右单位元

listLaw2 :: [a] -> [a] -> [a] -> Bool
listLaw2 xs ys zs = (xs ++ ys) ++ zs == xs ++ (ys ++ zs)  -- 结合律

-- 数学表示：
-- $xs \oplus [] = xs$ (右单位元)
-- $(xs \oplus ys) \oplus zs = xs \oplus (ys \oplus zs)$ (结合律)
```

### 2. 栈定律

```haskell
-- 栈定律验证
stackLaw1 :: Stack a -> Bool
stackLaw1 s = 
    case pop s of
        Nothing -> True
        Just (_, s') -> push (fromJust (peek s)) s' == s

-- 数学表示：
-- $\text{pop}(\text{push}(x, s)) = \text{Just}((x, s))$
```

### 3. 队列定律

```haskell
-- 队列定律验证
queueLaw1 :: Queue a -> Bool
queueLaw1 q = 
    case dequeue q of
        Nothing -> True
        Just (_, q') -> enqueue (fromJust (peekQueue q)) q' == q

-- 数学表示：
-- $\text{dequeue}(\text{enqueue}(x, q)) = \text{Just}((x, q))$
```

## 性能分析

### 1. 时间复杂度

```haskell
-- 时间复杂度分析
-- 列表操作：
--   head: O(1)
--   tail: O(1)
--   append: O(n)
--   length: O(n)
--   map: O(n)
--   filter: O(n)

-- 栈操作：
--   push: O(1)
--   pop: O(1)
--   peek: O(1)

-- 队列操作：
--   enqueue: O(1) 平均
--   dequeue: O(1) 平均
--   peek: O(1) 平均

-- 集合操作：
--   insert: O(n)
--   delete: O(n)
--   member: O(n)
--   union: O(n*m)
--   intersection: O(n*m)
```

### 2. 空间复杂度

```haskell
-- 空间复杂度分析
-- 列表：O(n)
-- 栈：O(n)
-- 队列：O(n)
-- 集合：O(n)
```

## 最佳实践

### 1. 选择合适的结构

```haskell
-- 顺序访问：使用列表
sequentialAccess :: [a] -> [a]
sequentialAccess = map process

-- 后进先出：使用栈
lifoAccess :: Stack a -> Stack a
lifoAccess = push newElement

-- 先进先出：使用队列
fifoAccess :: Queue a -> Queue a
fifoAccess = enqueue newElement

-- 唯一性：使用集合
uniqueElements :: [a] -> Set a
uniqueElements = foldr insert emptySet
```

### 2. 避免低效操作

```haskell
-- 好的做法：使用模式匹配
efficientHead :: [a] -> Maybe a
efficientHead [] = Nothing
efficientHead (x:_) = Just x

-- 避免：使用索引
inefficientHead :: [a] -> Maybe a
inefficientHead xs = if null xs then Nothing else Just (xs !! 0)
```

### 3. 利用惰性求值

```haskell
-- 惰性列表处理
lazyProcessing :: [Int] -> [Int]
lazyProcessing = map (*2) . filter (>0) . take 10

-- 只处理前10个正数
-- 数学表示：
-- $\text{lazyProcessing} = \text{map}((*2)) \circ \text{filter}(>0) \circ \text{take}(10)$
```

## 总结

基础数据结构提供了：

1. **类型安全**：编译时保证数据操作的正确性
2. **数学基础**：基于集合论和代数结构的严格理论
3. **高效操作**：提供最优化的数据访问和修改
4. **组合性**：数据结构可以组合和嵌套
5. **实际应用**：为各种算法和程序提供基础

理解和正确使用基础数据结构是掌握Haskell编程的关键。

---

**相关链接**：
- [高级数据结构](高级数据结构.md)
- [持久化数据结构](持久化数据结构.md)
- [算法](../07-Algorithms/排序算法.md) 