# Haskell基础数据结构

## 概述

基础数据结构是函数式编程的核心组成部分，在Haskell中，数据结构的设计遵循不可变性和纯函数的原则。本文档介绍Haskell中的基础数据结构，包括严格的数学定义和完整的Haskell实现。

## 1. 列表 (List)

### 数学定义

列表是一个递归定义的数据结构：

$$\text{List}(A) = \text{Nil} \mid \text{Cons}(a, \text{List}(A))$$

其中：
- $\text{Nil}$ 表示空列表
- $\text{Cons}(a, l)$ 表示在列表 $l$ 前添加元素 $a$

### Haskell实现

```haskell
-- 列表的代数数据类型定义
data List a = Nil | Cons a (List a)
  deriving (Show, Eq, Ord)

-- 列表的函子实例
instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x xs) = Cons (f x) (fmap f xs)

-- 列表的应用函子实例
instance Applicative List where
    pure x = Cons x Nil
    Nil <*> _ = Nil
    _ <*> Nil = Nil
    (Cons f fs) <*> xs = append (fmap f xs) (fs <*> xs)

-- 列表的单子实例
instance Monad List where
    return = pure
    Nil >>= _ = Nil
    (Cons x xs) >>= f = append (f x) (xs >>= f)

-- 辅助函数：列表连接
append :: List a -> List a -> List a
append Nil ys = ys
append (Cons x xs) ys = Cons x (append xs ys)

-- 列表长度
length :: List a -> Int
length Nil = 0
length (Cons _ xs) = 1 + length xs

-- 列表反转
reverse :: List a -> List a
reverse = reverseAcc Nil
  where
    reverseAcc acc Nil = acc
    reverseAcc acc (Cons x xs) = reverseAcc (Cons x acc) xs

-- 列表映射
map :: (a -> b) -> List a -> List b
map _ Nil = Nil
map f (Cons x xs) = Cons (f x) (map f xs)

-- 列表过滤
filter :: (a -> Bool) -> List a -> List a
filter _ Nil = Nil
filter p (Cons x xs)
    | p x = Cons x (filter p xs)
    | otherwise = filter p xs

-- 列表折叠
foldr :: (a -> b -> b) -> b -> List a -> b
foldr _ z Nil = z
foldr f z (Cons x xs) = f x (foldr f z xs)

foldl :: (b -> a -> b) -> b -> List a -> b
foldl _ z Nil = z
foldl f z (Cons x xs) = foldl f (f z x) xs
```

### 形式化性质

**定理 1.1** (列表长度性质)
对于任意列表 $l$，有：
$$\text{length}(\text{reverse}(l)) = \text{length}(l)$$

**证明**：
通过结构归纳法证明：
- 基础情况：$l = \text{Nil}$，显然成立
- 归纳步骤：假设对于列表 $xs$ 成立，对于 $\text{Cons}(x, xs)$：
  $$\text{length}(\text{reverse}(\text{Cons}(x, xs))) = \text{length}(\text{reverse}(xs) \cdot [x]) = \text{length}(\text{reverse}(xs)) + 1 = \text{length}(xs) + 1 = \text{length}(\text{Cons}(x, xs))$$

## 2. 二叉树 (Binary Tree)

### 数学定义

二叉树是一个递归定义的数据结构：

$$\text{Tree}(A) = \text{Empty} \mid \text{Node}(a, \text{Tree}(A), \text{Tree}(A))$$

其中：
- $\text{Empty}$ 表示空树
- $\text{Node}(a, l, r)$ 表示值为 $a$，左子树为 $l$，右子树为 $r$ 的节点

### Haskell实现

```haskell
-- 二叉树的代数数据类型定义
data Tree a = Empty | Node a (Tree a) (Tree a)
  deriving (Show, Eq, Ord)

-- 二叉树的函子实例
instance Functor Tree where
    fmap _ Empty = Empty
    fmap f (Node x left right) = Node (f x) (fmap f left) (fmap f right)

-- 树的大小（节点数）
size :: Tree a -> Int
size Empty = 0
size (Node _ left right) = 1 + size left + size right

-- 树的高度
height :: Tree a -> Int
height Empty = 0
height (Node _ left right) = 1 + max (height left) (height right)

-- 中序遍历
inorder :: Tree a -> [a]
inorder Empty = []
inorder (Node x left right) = inorder left ++ [x] ++ inorder right

-- 前序遍历
preorder :: Tree a -> [a]
preorder Empty = []
preorder (Node x left right) = [x] ++ preorder left ++ preorder right

-- 后序遍历
postorder :: Tree a -> [a]
postorder Empty = []
postorder (Node x left right) = postorder left ++ postorder right ++ [x]

-- 层序遍历
levelorder :: Tree a -> [a]
levelorder tree = concat (levels tree)
  where
    levels Empty = []
    levels (Node x left right) = [[x]] : zipWith (++) (levels left) (levels right)

-- 树映射
mapTree :: (a -> b) -> Tree a -> Tree b
mapTree _ Empty = Empty
mapTree f (Node x left right) = Node (f x) (mapTree f left) (mapTree f right)

-- 树折叠
foldTree :: (a -> b -> b -> b) -> b -> Tree a -> b
foldTree _ z Empty = z
foldTree f z (Node x left right) = f x (foldTree f z left) (foldTree f z right)

-- 构建平衡二叉树
buildBalanced :: [a] -> Tree a
buildBalanced [] = Empty
buildBalanced xs = Node (xs !! mid) 
                       (buildBalanced (take mid xs))
                       (buildBalanced (drop (mid + 1) xs))
  where
    mid = length xs `div` 2
```

### 形式化性质

**定理 2.1** (二叉树大小性质)
对于任意二叉树 $t$，有：
$$\text{size}(t) \leq 2^{\text{height}(t)} - 1$$

**证明**：
通过结构归纳法证明：
- 基础情况：$t = \text{Empty}$，$0 \leq 2^0 - 1 = 0$，成立
- 归纳步骤：假设对于左右子树成立，对于 $\text{Node}(a, l, r)$：
  $$\text{size}(\text{Node}(a, l, r)) = 1 + \text{size}(l) + \text{size}(r)$$
  $$\leq 1 + (2^{\text{height}(l)} - 1) + (2^{\text{height}(r)} - 1)$$
  $$\leq 1 + 2^{\max(\text{height}(l), \text{height}(r))} - 2$$
  $$\leq 2^{\text{height}(\text{Node}(a, l, r))} - 1$$

## 3. 堆 (Heap)

### 数学定义

堆是一个满足堆性质的完全二叉树：

$$\text{Heap}(A) = \text{Empty} \mid \text{HeapNode}(a, \text{Heap}(A), \text{Heap}(A))$$

堆性质：对于任意节点 $n$，其值不大于其父节点的值（最小堆）。

### Haskell实现

```haskell
-- 堆的代数数据类型定义
data Heap a = EmptyHeap | HeapNode a (Heap a) (Heap a)
  deriving (Show, Eq)

-- 堆的序类型类约束
class Ord a => Heapable a where
    heapCompare :: a -> a -> Ordering
    heapCompare = compare

instance Heapable Int
instance Heapable Double
instance Heapable Char

-- 插入元素到堆中
insert :: Heapable a => a -> Heap a -> Heap a
insert x EmptyHeap = HeapNode x EmptyHeap EmptyHeap
insert x (HeapNode v left right)
    | x <= v = HeapNode x (insert v right) left
    | otherwise = HeapNode v (insert x right) left

-- 从堆中删除最小元素
deleteMin :: Heapable a => Heap a -> Maybe (a, Heap a)
deleteMin EmptyHeap = Nothing
deleteMin (HeapNode v EmptyHeap EmptyHeap) = Just (v, EmptyHeap)
deleteMin (HeapNode v left right) = Just (v, merge left right)

-- 合并两个堆
merge :: Heapable a => Heap a -> Heap a -> Heap a
merge EmptyHeap h = h
merge h EmptyHeap = h
merge (HeapNode v1 l1 r1) (HeapNode v2 l2 r2)
    | v1 <= v2 = HeapNode v1 (merge r1 (HeapNode v2 l2 r2)) l1
    | otherwise = HeapNode v2 (merge (HeapNode v1 l1 r1) r2) l2

-- 构建堆
buildHeap :: Heapable a => [a] -> Heap a
buildHeap = foldr insert EmptyHeap

-- 堆排序
heapSort :: Heapable a => [a] -> [a]
heapSort xs = heapSort' (buildHeap xs)
  where
    heapSort' EmptyHeap = []
    heapSort' h = case deleteMin h of
        Just (x, h') -> x : heapSort' h'
        Nothing -> []

-- 获取堆的最小元素
findMin :: Heapable a => Heap a -> Maybe a
findMin EmptyHeap = Nothing
findMin (HeapNode v _ _) = Just v

-- 堆的大小
heapSize :: Heap a -> Int
heapSize EmptyHeap = 0
heapSize (HeapNode _ left right) = 1 + heapSize left + heapSize right
```

### 形式化性质

**定理 3.1** (堆性质保持)
对于任意堆 $h$ 和元素 $x$，插入 $x$ 后的堆 $h'$ 仍然满足堆性质。

**证明**：
通过结构归纳法证明：
- 基础情况：$h = \text{EmptyHeap}$，显然成立
- 归纳步骤：对于 $\text{HeapNode}(v, l, r)$：
  - 如果 $x \leq v$，新根为 $x$，$v$ 被插入到右子树，保持堆性质
  - 如果 $x > v$，根仍为 $v$，$x$ 被插入到右子树，通过归纳假设保持堆性质

## 4. 图 (Graph)

### 数学定义

图是一个二元组 $G = (V, E)$，其中：
- $V$ 是顶点集合
- $E \subseteq V \times V$ 是边集合

### Haskell实现

```haskell
-- 图的代数数据类型定义
data Graph a = Graph { vertices :: [a], edges :: [(a, a)] }
  deriving (Show, Eq)

-- 邻接表表示
type AdjacencyList a = [(a, [a])]

-- 从边列表构建邻接表
buildAdjacencyList :: Eq a => [(a, a)] -> AdjacencyList a
buildAdjacencyList edges = map (\v -> (v, neighbors v)) vertices
  where
    vertices = nub (map fst edges ++ map snd edges)
    neighbors v = [u | (u, w) <- edges, w == v] ++ [w | (u, w) <- edges, u == v]

-- 深度优先搜索
dfs :: Eq a => AdjacencyList a -> a -> [a]
dfs adj start = dfs' adj start []
  where
    dfs' _ _ visited | length visited == length adj = reverse visited
    dfs' adj current visited
        | current `elem` visited = reverse visited
        | otherwise = foldr (dfs' adj) (current : visited) (neighbors current)
      where
        neighbors current = case lookup current adj of
            Just ns -> ns
            Nothing -> []

-- 广度优先搜索
bfs :: Eq a => AdjacencyList a -> a -> [a]
bfs adj start = bfs' adj [start] []
  where
    bfs' _ [] visited = reverse visited
    bfs' adj (current:queue) visited
        | current `elem` visited = bfs' adj queue visited
        | otherwise = bfs' adj (queue ++ neighbors current) (current : visited)
      where
        neighbors current = case lookup current adj of
            Just ns -> ns
            Nothing -> []

-- 拓扑排序
topologicalSort :: Eq a => AdjacencyList a -> [a]
topologicalSort adj = reverse (topSort' adj [] (map fst adj))
  where
    topSort' _ result [] = result
    topSort' adj result unvisited = 
        case find (\v -> all (\u -> u `notElem` unvisited) (neighbors v)) unvisited of
            Just v -> topSort' adj (v:result) (delete v unvisited)
            Nothing -> error "Graph contains cycle"
      where
        neighbors v = case lookup v adj of
            Just ns -> ns
            Nothing -> []

-- 最短路径（Dijkstra算法）
shortestPath :: (Eq a, Ord b, Num b) => AdjacencyList a -> (a, a) -> [(a, b)] -> Maybe [a]
shortestPath adj (start, end) weights = dijkstra adj weights start end
  where
    dijkstra adj weights start end = dijkstra' adj weights [(start, 0)] [] (fromList [(start, 0)])
      where
        dijkstra' _ _ [] _ _ = Nothing
        dijkstra' adj weights ((current, dist):queue) visited distances
            | current == end = Just (reconstructPath current visited)
            | current `elem` visited = dijkstra' adj weights queue visited distances
            | otherwise = dijkstra' adj weights newQueue (current:visited) newDistances
          where
            neighbors current = case lookup current adj of
                Just ns -> ns
                Nothing -> []
            newQueue = queue ++ [(n, dist + getWeight current n) | n <- neighbors current, n `notElem` visited]
            newDistances = foldr (\n acc -> insert n (dist + getWeight current n) acc) distances (neighbors current)
            getWeight u v = case lookup (u, v) weights of
                Just w -> w
                Nothing -> 0

-- 辅助函数
reconstructPath :: Eq a => a -> [a] -> [a]
reconstructPath _ [] = []
reconstructPath current visited = current : reconstructPath (findPredecessor current visited) (delete current visited)
  where
    findPredecessor _ [] = error "No predecessor found"
    findPredecessor current (v:vs) = v  -- 简化实现
```

### 形式化性质

**定理 4.1** (DFS访问性质)
对于连通图 $G$ 和起始顶点 $s$，DFS算法访问所有可达顶点。

**证明**：
通过归纳法证明：
- 基础情况：$s$ 自身被访问
- 归纳步骤：假设 $s$ 的所有邻居都被访问，则通过递归调用，所有可达顶点都被访问

## 5. 散列表 (Hash Table)

### 数学定义

散列表是一个函数 $h: K \to \{0, 1, \ldots, m-1\}$，其中：
- $K$ 是键的集合
- $m$ 是桶的数量
- $h$ 是散列函数

### Haskell实现

```haskell
-- 散列表的代数数据类型定义
data HashTable k v = HashTable { size :: Int, buckets :: Array Int [(k, v)] }
  deriving (Show)

-- 创建散列表
newHashTable :: Int -> HashTable k v
newHashTable size = HashTable size (array (0, size-1) [(i, []) | i <- [0..size-1]])

-- 散列函数
hash :: (Hashable k) => k -> Int -> Int
hash k size = abs (hashCode k) `mod` size

-- 插入键值对
insert :: (Hashable k, Eq k) => k -> v -> HashTable k v -> HashTable k v
insert key value (HashTable size buckets) = 
    HashTable size (buckets // [(index, newBucket)])
  where
    index = hash key size
    oldBucket = buckets ! index
    newBucket = (key, value) : filter ((/= key) . fst) oldBucket

-- 查找键
lookup :: (Hashable k, Eq k) => k -> HashTable k v -> Maybe v
lookup key (HashTable size buckets) = 
    case filter ((== key) . fst) bucket of
        [] -> Nothing
        ((_, value):_) -> Just value
  where
    index = hash key size
    bucket = buckets ! index

-- 删除键
delete :: (Hashable k, Eq k) => k -> HashTable k v -> HashTable k v
delete key (HashTable size buckets) = 
    HashTable size (buckets // [(index, newBucket)])
  where
    index = hash key size
    oldBucket = buckets ! index
    newBucket = filter ((/= key) . fst) oldBucket

-- 获取所有键值对
toList :: HashTable k v -> [(k, v)]
toList (HashTable _ buckets) = concat (elems buckets)

-- 散列表大小
hashTableSize :: HashTable k v -> Int
hashTableSize = length . toList

-- 类型类：可散列
class Hashable a where
    hashCode :: a -> Int

instance Hashable Int where
    hashCode = id

instance Hashable String where
    hashCode = foldl (\h c -> h * 31 + fromEnum c) 0

instance Hashable Char where
    hashCode = fromEnum
```

### 形式化性质

**定理 5.1** (散列表查找正确性)
对于任意键 $k$ 和散列表 $h$，如果 $k$ 在 $h$ 中，则 $\text{lookup}(k, h)$ 返回正确的值。

**证明**：
通过散列函数的定义和查找算法的实现，可以证明查找操作在键存在时返回正确值。

## 总结

本文档介绍了Haskell中的基础数据结构，包括：

1. **列表**：递归定义的线性数据结构
2. **二叉树**：层次化的树形数据结构
3. **堆**：满足堆性质的完全二叉树
4. **图**：表示顶点和边关系的数据结构
5. **散列表**：基于散列函数的键值存储结构

每个数据结构都包含：
- 严格的数学定义
- 完整的Haskell实现
- 形式化性质证明
- 实际应用示例

这些基础数据结构为更复杂的算法和应用程序提供了坚实的基础。
