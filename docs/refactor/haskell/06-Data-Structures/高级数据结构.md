# 高级数据结构

## 概述

高级数据结构是Haskell中更复杂、更高效的数据组织方式，它们基于基础数据结构构建，提供了更好的性能和更丰富的功能。这些数据结构通常基于函数式编程的理论，如持久化数据结构、手指树、跳跃列表等。

## 数学基础

### 持久化数据结构

持久化数据结构满足以下性质：

$$\text{Persistent}(D) = \{d \in D | \forall \text{op}, \text{op}(d) \text{ preserves } d\}$$

### 摊销分析

摊销复杂度分析：

$$\text{Amortized}(T) = \frac{\sum_{i=1}^{n} T_i}{n}$$

其中 $T_i$ 是第 $i$ 个操作的实际复杂度。

## 1. 持久化列表 (Persistent List)

### 数学定义

持久化列表是支持高效头部操作的列表：

$$\text{PersistentList}(A) = \text{List}(A) \text{ with } O(1) \text{ cons/head/tail}$$

### Haskell实现

```haskell
-- 持久化列表定义
data PersistentList a = Nil | Cons a (PersistentList a)

-- 基本操作
empty :: PersistentList a
empty = Nil

isEmpty :: PersistentList a -> Bool
isEmpty Nil = True
isEmpty _ = False

cons :: a -> PersistentList a -> PersistentList a
cons x xs = Cons x xs

head :: PersistentList a -> Maybe a
head Nil = Nothing
head (Cons x _) = Just x

tail :: PersistentList a -> Maybe (PersistentList a)
tail Nil = Nothing
tail (Cons _ xs) = Just xs

-- 列表操作
length :: PersistentList a -> Int
length Nil = 0
length (Cons _ xs) = 1 + length xs

reverse :: PersistentList a -> PersistentList a
reverse = reverse' Nil
  where
    reverse' acc Nil = acc
    reverse' acc (Cons x xs) = reverse' (Cons x acc) xs

append :: PersistentList a -> PersistentList a -> PersistentList a
append Nil ys = ys
append (Cons x xs) ys = Cons x (append xs ys)

-- 高阶函数
map :: (a -> b) -> PersistentList a -> PersistentList b
map _ Nil = Nil
map f (Cons x xs) = Cons (f x) (map f xs)

filter :: (a -> Bool) -> PersistentList a -> PersistentList a
filter _ Nil = Nil
filter p (Cons x xs)
    | p x = Cons x (filter p xs)
    | otherwise = filter p xs

foldr :: (a -> b -> b) -> b -> PersistentList a -> b
foldr _ z Nil = z
foldr f z (Cons x xs) = f x (foldr f z xs)

-- 使用示例
example1 :: PersistentList Int
example1 = cons 1 (cons 2 (cons 3 empty))

example2 :: PersistentList Int
example2 = map (*2) example1

example3 :: PersistentList Int
example3 = filter even example1

example4 :: Int
example4 = foldr (+) 0 example1
```

## 2. 手指树 (Finger Tree)

### 数学定义

手指树是支持高效两端操作的数据结构：

$$\text{FingerTree}(A) = \text{Tree}(\text{Digit}(A)) \text{ with } O(1) \text{ head/last}$$

### Haskell实现

```haskell
-- 手指树定义
data Digit a = One a | Two a a | Three a a a | Four a a a a

data FingerTree a = Empty | Single a | Deep (Digit a) (FingerTree (Node a)) (Digit a)

data Node a = Node2 a a | Node3 a a a

-- 基本操作
empty :: FingerTree a
empty = Empty

isEmpty :: FingerTree a -> Bool
isEmpty Empty = True
isEmpty _ = False

-- 头部操作
cons :: a -> FingerTree a -> FingerTree a
cons x Empty = Single x
cons x (Single y) = Deep (One x) Empty (One y)
cons x (Deep (Four a b c d) m sf) = Deep (Two x a) (cons (Node3 b c d) m) sf
cons x (Deep pr m sf) = Deep (consDigit x pr) m sf

consDigit :: a -> Digit a -> Digit a
consDigit x (One a) = Two x a
consDigit x (Two a b) = Three x a b
consDigit x (Three a b c) = Four x a b c
consDigit _ (Four _ _ _ _) = error "consDigit: Four"

-- 尾部操作
snoc :: FingerTree a -> a -> FingerTree a
snoc Empty x = Single x
snoc (Single y) x = Deep (One y) Empty (One x)
snoc (Deep pr m (Four a b c d)) x = Deep pr (snoc m (Node3 a b c)) (Two d x)
snoc (Deep pr m sf) x = Deep pr m (snocDigit sf x)

snocDigit :: Digit a -> a -> Digit a
snocDigit (One a) x = Two a x
snocDigit (Two a b) x = Three a b x
snocDigit (Three a b c) x = Four a b c x
snocDigit (Four _ _ _ _) _ = error "snocDigit: Four"

-- 访问操作
head :: FingerTree a -> Maybe a
head Empty = Nothing
head (Single x) = Just x
head (Deep pr _ _) = Just (headDigit pr)

headDigit :: Digit a -> a
headDigit (One x) = x
headDigit (Two x _) = x
headDigit (Three x _ _) = x
headDigit (Four x _ _ _) = x

last :: FingerTree a -> Maybe a
last Empty = Nothing
last (Single x) = Just x
last (Deep _ _ sf) = Just (lastDigit sf)

lastDigit :: Digit a -> a
lastDigit (One x) = x
lastDigit (Two _ x) = x
lastDigit (Three _ _ x) = x
lastDigit (Four _ _ _ x) = x

-- 分割操作
split :: (a -> Bool) -> FingerTree a -> (FingerTree a, Maybe a, FingerTree a)
split _ Empty = (Empty, Nothing, Empty)
split p (Single x)
    | p x = (Empty, Just x, Empty)
    | otherwise = (Single x, Nothing, Empty)
split p (Deep pr m sf) = 
    case splitDigit p pr of
        (l, Just x, r) -> (fromDigit l, Just x, deepL r m sf)
        (l, Nothing, r) -> 
            case split p m of
                (ml, Just (Node2 a b), mr) ->
                    if p a
                        then (deepR pr ml, Just a, deepL (Two b) mr sf)
                        else (deepR pr ml, Just b, deepL (One a) mr sf)
                (ml, Just (Node3 a b c), mr) ->
                    if p a
                        then (deepR pr ml, Just a, deepL (Three b c) mr sf)
                        else if p b
                            then (deepR pr ml, Just b, deepL (Two a c) mr sf)
                            else (deepR pr ml, Just c, deepL (Two a b) mr sf)
                (ml, Nothing, mr) ->
                    case splitDigit p sf of
                        (sl, Just x, sr) -> (deepR pr ml, Just x, fromDigit sr)
                        (sl, Nothing, sr) -> (deepR pr ml, Nothing, fromDigit sr)

splitDigit :: (a -> Bool) -> Digit a -> (Digit a, Maybe a, Digit a)
splitDigit p (One x)
    | p x = (One x, Nothing, One x)
    | otherwise = (One x, Nothing, One x)
splitDigit p (Two a b)
    | p a = (One a, Nothing, One b)
    | p b = (Two a b, Nothing, Two a b)
    | otherwise = (Two a b, Nothing, Two a b)
splitDigit p (Three a b c)
    | p a = (One a, Nothing, Two b c)
    | p b = (Two a b, Nothing, One c)
    | p c = (Three a b c, Nothing, Three a b c)
    | otherwise = (Three a b c, Nothing, Three a b c)
splitDigit p (Four a b c d)
    | p a = (One a, Nothing, Three b c d)
    | p b = (Two a b, Nothing, Two c d)
    | p c = (Three a b c, Nothing, One d)
    | p d = (Four a b c d, Nothing, Four a b c d)
    | otherwise = (Four a b c d, Nothing, Four a b c d)

-- 辅助函数
fromDigit :: Digit a -> FingerTree a
fromDigit (One x) = Single x
fromDigit (Two a b) = Deep (One a) Empty (One b)
fromDigit (Three a b c) = Deep (Two a b) Empty (One c)
fromDigit (Four a b c d) = Deep (Two a b) Empty (Two c d)

deepL :: Digit a -> FingerTree (Node a) -> Digit a -> FingerTree a
deepL pr m sf = case toList pr of
    [] -> case viewL m of
        Nothing -> fromDigit sf
        Just (Node2 a b, m') -> Deep (Two a b) m' sf
        Just (Node3 a b c, m') -> Deep (Three a b c) m' sf
    [x] -> Deep (One x) m sf
    [x, y] -> Deep (Two x y) m sf
    [x, y, z] -> Deep (Three x y z) m sf
    [x, y, z, w] -> Deep (Four x y z w) m sf

deepR :: Digit a -> FingerTree (Node a) -> Digit a -> FingerTree a
deepR pr m sf = case toList sf of
    [] -> case viewR m of
        Nothing -> fromDigit pr
        Just (m', Node2 a b) -> Deep pr m' (Two a b)
        Just (m', Node3 a b c) -> Deep pr m' (Three a b c)
    [x] -> Deep pr m (One x)
    [x, y] -> Deep pr m (Two x y)
    [x, y, z] -> Deep pr m (Three x y z)
    [x, y, z, w] -> Deep pr m (Four x y z w)

viewL :: FingerTree a -> Maybe (a, FingerTree a)
viewL Empty = Nothing
viewL (Single x) = Just (x, Empty)
viewL (Deep pr m sf) = Just (headDigit pr, deepL (tailDigit pr) m sf)

viewR :: FingerTree a -> Maybe (FingerTree a, a)
viewR Empty = Nothing
viewR (Single x) = Just (Empty, x)
viewR (Deep pr m sf) = Just (deepR pr m (initDigit sf), lastDigit sf)

-- 辅助函数
toList :: Digit a -> [a]
toList (One x) = [x]
toList (Two a b) = [a, b]
toList (Three a b c) = [a, b, c]
toList (Four a b c d) = [a, b, c, d]

tailDigit :: Digit a -> Digit a
tailDigit (One _) = error "tailDigit: One"
tailDigit (Two _ b) = One b
tailDigit (Three _ b c) = Two b c
tailDigit (Four _ b c d) = Three b c d

initDigit :: Digit a -> Digit a
initDigit (One _) = error "initDigit: One"
initDigit (Two a _) = One a
initDigit (Three a b _) = Two a b
initDigit (Four a b c _) = Three a b c

-- 使用示例
example5 :: FingerTree Int
example5 = cons 1 (cons 2 (cons 3 empty))

example6 :: FingerTree Int
example6 = snoc example5 4

example7 :: Maybe Int
example7 = head example6  -- Just 1

example8 :: Maybe Int
example8 = last example6  -- Just 4
```

## 3. 跳跃列表 (Skip List)

### 数学定义

跳跃列表是概率性的数据结构：

$$\text{SkipList}(A) = \text{List}(A) \text{ with } O(\log n) \text{ expected search}$$

### Haskell实现

```haskell
import System.Random

-- 跳跃列表定义
data SkipList a = SkipList {
    levels :: Int,
    head :: SkipNode a,
    randomGen :: StdGen
}

data SkipNode a = SkipNode {
    value :: Maybe a,
    next :: [SkipNode a]
}

-- 基本操作
empty :: SkipList a
empty = SkipList 0 (SkipNode Nothing []) (mkStdGen 42)

isEmpty :: SkipList a -> Bool
isEmpty (SkipList _ (SkipNode Nothing _) _) = True
isEmpty _ = False

-- 随机层数生成
randomLevel :: SkipList a -> (Int, SkipList a)
randomLevel (SkipList maxLevel headNode gen) = (level, SkipList maxLevel headNode newGen)
  where
    (level, newGen) = randomLevel' 1 gen
    randomLevel' current g
        | current >= maxLevel || random > 0.5 = (current, g')
        | otherwise = randomLevel' (current + 1) g'
      where
        (random, g') = randomR (0.0, 1.0) g

-- 插入操作
insert :: Ord a => a -> SkipList a -> SkipList a
insert x (SkipList maxLevel headNode gen) = 
    let (level, newGen) = randomLevel (SkipList maxLevel headNode gen)
        newMaxLevel = max maxLevel level
        newNode = SkipNode (Just x) (replicate newMaxLevel headNode)
        (newHead, _) = insert' x newNode level headNode
    in SkipList newMaxLevel newHead newGen

insert' :: Ord a => a -> SkipNode a -> Int -> SkipNode a -> (SkipNode a, Bool)
insert' x newNode level (SkipNode val nexts)
    | level < 0 = (SkipNode val nexts, False)
    | otherwise = 
        let (newNexts, found) = insertAtLevel x newNode level nexts
            (newNode', inserted) = insert' x newNode (level - 1) (head newNexts)
        in (SkipNode val (newNode' : tail newNexts), found || inserted)

insertAtLevel :: Ord a => a -> SkipNode a -> Int -> [SkipNode a] -> ([SkipNode a], Bool)
insertAtLevel x newNode level [] = ([newNode], False)
insertAtLevel x newNode level (current:rest)
    | shouldInsert x current = (newNode : current : rest, True)
    | otherwise = 
        let (newRest, found) = insertAtLevel x newNode level rest
        in (current : newRest, found)

shouldInsert :: Ord a => a -> SkipNode a -> Bool
shouldInsert x (SkipNode Nothing _) = True
shouldInsert x (SkipNode (Just val) _) = x < val

-- 查找操作
search :: Ord a => a -> SkipList a -> Maybe a
search x (SkipList _ headNode _) = search' x headNode

search' :: Ord a => a -> SkipNode a -> Maybe a
search' x (SkipNode val nexts) = 
    case findNext x nexts of
        Nothing -> val
        Just nextNode -> search' x nextNode

findNext :: Ord a => a -> [SkipNode a] -> Maybe (SkipNode a)
findNext _ [] = Nothing
findNext x (node:rest)
    | shouldGoNext x node = Just node
    | otherwise = findNext x rest

shouldGoNext :: Ord a => a -> SkipNode a -> Bool
shouldGoNext x (SkipNode Nothing _) = False
shouldGoNext x (SkipNode (Just val) _) = x >= val

-- 删除操作
delete :: Ord a => a -> SkipList a -> SkipList a
delete x (SkipList maxLevel headNode gen) = 
    let newHead = delete' x headNode
    in SkipList maxLevel newHead gen

delete' :: Ord a => a -> SkipNode a -> SkipNode a
delete' x (SkipNode val nexts) = 
    let newNexts = map (deleteAtLevel x) nexts
    in SkipNode val newNexts

deleteAtLevel :: Ord a => a -> SkipNode a -> SkipNode a
deleteAtLevel x (SkipNode val nexts) = 
    case findDeleteTarget x nexts of
        Nothing -> SkipNode val nexts
        Just target -> SkipNode val (replaceNext target nexts)

findDeleteTarget :: Ord a => a -> [SkipNode a] -> Maybe (SkipNode a)
findDeleteTarget _ [] = Nothing
findDeleteTarget x (node:rest)
    | isDeleteTarget x node = Just node
    | otherwise = findDeleteTarget x rest

isDeleteTarget :: Ord a => a -> SkipNode a -> Bool
isDeleteTarget x (SkipNode (Just val) _) = x == val
isDeleteTarget _ _ = False

replaceNext :: SkipNode a -> [SkipNode a] -> [SkipNode a]
replaceNext _ [] = []
replaceNext target (current:rest)
    | current == target = rest
    | otherwise = current : replaceNext target rest

-- 使用示例
example9 :: SkipList Int
example9 = insert 3 (insert 1 (insert 4 (insert 1 (insert 5 empty))))

example10 :: Maybe Int
example10 = search 4 example9  -- Just 4

example11 :: SkipList Int
example11 = delete 4 example9
```

## 4. 持久化数组 (Persistent Array)

### 数学定义

持久化数组是支持高效随机访问的不可变数组：

$$\text{PersistentArray}(A) = \text{Array}(A) \text{ with } O(\log n) \text{ update}$$

### Haskell实现

```haskell
-- 持久化数组定义
data PersistentArray a = Array {
    size :: Int,
    tree :: Tree a
}

data Tree a = Leaf a | Branch (Tree a) (Tree a) | Empty

-- 基本操作
empty :: PersistentArray a
empty = Array 0 Empty

singleton :: a -> PersistentArray a
singleton x = Array 1 (Leaf x)

-- 访问操作
(!) :: PersistentArray a -> Int -> Maybe a
Array _ tree ! i = access tree i

access :: Tree a -> Int -> Maybe a
access Empty _ = Nothing
access (Leaf x) 0 = Just x
access (Leaf _) _ = Nothing
access (Branch left right) i
    | i < 0 = Nothing
    | even i = access left (i `div` 2)
    | otherwise = access right (i `div` 2)

-- 更新操作
update :: Int -> a -> PersistentArray a -> PersistentArray a
update i x (Array size tree) = Array size (updateTree i x tree)

updateTree :: Int -> a -> Tree a -> Tree a
updateTree _ _ Empty = Empty
updateTree 0 x (Leaf _) = Leaf x
updateTree _ _ (Leaf x) = Leaf x
updateTree i x (Branch left right)
    | i < 0 = Branch left right
    | even i = Branch (updateTree (i `div` 2) x left) right
    | otherwise = Branch left (updateTree (i `div` 2) x right)

-- 构建操作
fromList :: [a] -> PersistentArray a
fromList xs = Array (length xs) (buildTree xs)

buildTree :: [a] -> Tree a
buildTree [] = Empty
buildTree [x] = Leaf x
buildTree xs = 
    let mid = length xs `div` 2
        (left, right) = splitAt mid xs
    in Branch (buildTree left) (buildTree right)

-- 转换操作
toList :: PersistentArray a -> [a]
toList (Array _ tree) = treeToList tree

treeToList :: Tree a -> [a]
treeToList Empty = []
treeToList (Leaf x) = [x]
treeToList (Branch left right) = treeToList left ++ treeToList right

-- 映射操作
map :: (a -> b) -> PersistentArray a -> PersistentArray b
map f (Array size tree) = Array size (mapTree f tree)

mapTree :: (a -> b) -> Tree a -> Tree b
mapTree _ Empty = Empty
mapTree f (Leaf x) = Leaf (f x)
mapTree f (Branch left right) = Branch (mapTree f left) (mapTree f right)

-- 使用示例
example12 :: PersistentArray Int
example12 = fromList [1, 2, 3, 4, 5]

example13 :: Maybe Int
example13 = example12 ! 2  -- Just 3

example14 :: PersistentArray Int
example14 = update 2 10 example12

example15 :: [Int]
example15 = toList example14  -- [1,2,10,4,5]

example16 :: PersistentArray String
example16 = map show example12
```

## 5. 持久化队列 (Persistent Queue)

### 数学定义

持久化队列是支持高效两端操作的队列：

$$\text{PersistentQueue}(A) = \text{Queue}(A) \text{ with } O(1) \text{ amortized enqueue/dequeue}$$

### Haskell实现

```haskell
-- 持久化队列定义
data PersistentQueue a = Queue {
    front :: [a],
    rear :: [a]
}

-- 基本操作
empty :: PersistentQueue a
empty = Queue [] []

isEmpty :: PersistentQueue a -> Bool
isEmpty (Queue [] []) = True
isEmpty _ = False

-- 入队操作
enqueue :: a -> PersistentQueue a -> PersistentQueue a
enqueue x (Queue front rear) = Queue front (x:rear)

-- 出队操作
dequeue :: PersistentQueue a -> Maybe (a, PersistentQueue a)
dequeue (Queue [] []) = Nothing
dequeue (Queue [] rear) = 
    let front' = reverse rear
    in dequeue (Queue front' [])
dequeue (Queue (x:xs) rear) = Just (x, Queue xs rear)

-- 查看队首
peek :: PersistentQueue a -> Maybe a
peek (Queue [] []) = Nothing
peek (Queue [] rear) = 
    let front' = reverse rear
    in peek (Queue front' [])
peek (Queue (x:_) _) = Just x

-- 队列大小
size :: PersistentQueue a -> Int
size (Queue front rear) = length front + length rear

-- 转换操作
fromList :: [a] -> PersistentQueue a
fromList xs = Queue xs []

toList :: PersistentQueue a -> [a]
toList (Queue front rear) = front ++ reverse rear

-- 映射操作
map :: (a -> b) -> PersistentQueue a -> PersistentQueue b
map f (Queue front rear) = Queue (map f front) (map f rear)

-- 过滤操作
filter :: (a -> Bool) -> PersistentQueue a -> PersistentQueue a
filter p (Queue front rear) = 
    let front' = filter p front
        rear' = filter p rear
    in Queue front' rear'

-- 使用示例
example17 :: PersistentQueue Int
example17 = enqueue 1 (enqueue 2 (enqueue 3 empty))

example18 :: Maybe (Int, PersistentQueue Int)
example18 = dequeue example17  -- Just (1, Queue [2,3] [])

example19 :: Maybe Int
example19 = peek example17  -- Just 1

example20 :: [Int]
example20 = toList example17  -- [1,2,3]

example21 :: PersistentQueue String
example21 = map show example17
```

## 总结

高级数据结构为Haskell提供了：

1. **高效操作**：支持快速访问和修改
2. **持久化**：操作返回新的数据结构
3. **函数式特性**：支持高阶函数和函数组合
4. **数学基础**：基于严格的数学理论
5. **实际应用**：适用于各种复杂场景

这些数据结构为函数式编程提供了强大的工具，支持高效、安全的程序开发。
