# Haskell排序算法实现

## 概述

排序算法是计算机科学的基础算法之一。本章介绍各种排序算法在Haskell中的实现，包括形式化定义、复杂度分析和实际应用。

## 数学基础

### 排序问题定义

给定一个序列 $S = [s_1, s_2, \ldots, s_n]$ 和比较函数 $cmp: A \times A \rightarrow \{-1, 0, 1\}$，排序问题是找到一个排列 $\pi$ 使得：
$$\forall i < j: cmp(s_{\pi(i)}, s_{\pi(j)}) \leq 0$$

### 算法复杂度

- **时间复杂度**：算法执行所需的基本操作次数
- **空间复杂度**：算法执行所需的额外存储空间
- **稳定性**：相等元素的相对位置是否保持不变

## 基础排序算法

### 冒泡排序 (Bubble Sort)

**算法思想**：重复遍历序列，比较相邻元素并交换位置。

**复杂度**：
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$
- 稳定性：稳定

```haskell
-- 冒泡排序实现
bubbleSort :: Ord a => [a] -> [a]
bubbleSort [] = []
bubbleSort xs = bubbleSort' xs (length xs)
  where
    bubbleSort' xs 0 = xs
    bubbleSort' xs n = bubbleSort' (bubble xs) (n - 1)
    
    bubble [] = []
    bubble [x] = [x]
    bubble (x:y:xs)
      | x <= y    = x : bubble (y:xs)
      | otherwise = y : bubble (x:xs)

-- 优化版本：检测是否已排序
bubbleSortOptimized :: Ord a => [a] -> [a]
bubbleSortOptimized xs = bubbleSortOpt xs
  where
    bubbleSortOpt [] = []
    bubbleSortOpt xs = 
      case bubble xs of
        (xs', False) -> xs'  -- 没有交换，已排序
        (xs', True)  -> bubbleSortOpt xs'
    
    bubble [] = ([], False)
    bubble [x] = ([x], False)
    bubble (x:y:xs) =
      let (rest, swapped) = bubble (y:xs)
      in if x <= y
         then (x:rest, swapped)
         else (y:rest, True)

-- 测试
testBubbleSort :: Bool
testBubbleSort = 
    bubbleSort [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9] &&
    bubbleSortOptimized [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9]
```

### 选择排序 (Selection Sort)

**算法思想**：每次选择未排序部分的最小元素放到已排序部分的末尾。

**复杂度**：
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$
- 稳定性：不稳定

```haskell
-- 选择排序实现
selectionSort :: Ord a => [a] -> [a]
selectionSort [] = []
selectionSort xs = 
    let (min, rest) = findMin xs
    in min : selectionSort rest
  where
    findMin [x] = (x, [])
    findMin (x:xs) =
      let (min, rest) = findMin xs
      in if x <= min
         then (x, min:rest)
         else (min, x:rest)

-- 使用foldr的实现
selectionSort' :: Ord a => [a] -> [a]
selectionSort' = foldr insert []
  where
    insert x [] = [x]
    insert x (y:ys)
      | x <= y    = x:y:ys
      | otherwise = y:insert x ys

-- 测试
testSelectionSort :: Bool
testSelectionSort = 
    selectionSort [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9] &&
    selectionSort' [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9]
```

### 插入排序 (Insertion Sort)

**算法思想**：将每个元素插入到已排序序列的适当位置。

**复杂度**：
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$
- 稳定性：稳定

```haskell
-- 插入排序实现
insertionSort :: Ord a => [a] -> [a]
insertionSort = foldr insert []
  where
    insert x [] = [x]
    insert x (y:ys)
      | x <= y    = x:y:ys
      | otherwise = y:insert x ys

-- 使用foldl的实现
insertionSort' :: Ord a => [a] -> [a]
insertionSort' = foldl (flip insert) []
  where
    insert x [] = [x]
    insert x (y:ys)
      | x <= y    = x:y:ys
      | otherwise = y:insert x ys

-- 测试
testInsertionSort :: Bool
testInsertionSort = 
    insertionSort [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9] &&
    insertionSort' [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9]
```

## 高效排序算法

### 归并排序 (Merge Sort)

**算法思想**：分治法，将序列分成两半，分别排序后合并。

**复杂度**：
- 时间复杂度：$O(n \log n)$
- 空间复杂度：$O(n)$
- 稳定性：稳定

```haskell
-- 归并排序实现
mergeSort :: Ord a => [a] -> [a]
mergeSort [] = []
mergeSort [x] = [x]
mergeSort xs = 
    let (left, right) = splitAt (length xs `div` 2) xs
    in merge (mergeSort left) (mergeSort right)

-- 合并两个有序序列
merge :: Ord a => [a] -> [a] -> [a]
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys)
  | x <= y    = x : merge xs (y:ys)
  | otherwise = y : merge (x:xs) ys

-- 优化版本：避免重复计算长度
mergeSortOptimized :: Ord a => [a] -> [a]
mergeSortOptimized = mergeSortOpt
  where
    mergeSortOpt [] = []
    mergeSortOpt [x] = [x]
    mergeSortOpt xs = 
      let (left, right) = split xs
      in merge (mergeSortOpt left) (mergeSortOpt right)
    
    split [] = ([], [])
    split [x] = ([x], [])
    split (x:y:xs) = 
      let (left, right) = split xs
      in (x:left, y:right)

-- 测试
testMergeSort :: Bool
testMergeSort = 
    mergeSort [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9] &&
    mergeSortOptimized [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9]
```

### 快速排序 (Quick Sort)

**算法思想**：选择基准元素，将序列分成小于和大于基准的两部分，递归排序。

**复杂度**：
- 时间复杂度：平均 $O(n \log n)$，最坏 $O(n^2)$
- 空间复杂度：$O(\log n)$
- 稳定性：不稳定

```haskell
-- 快速排序实现
quickSort :: Ord a => [a] -> [a]
quickSort [] = []
quickSort (x:xs) = 
    quickSort (filter (<= x) xs) ++ [x] ++ quickSort (filter (> x) xs)

-- 优化版本：避免重复遍历
quickSortOptimized :: Ord a => [a] -> [a]
quickSortOptimized [] = []
quickSortOptimized (x:xs) = 
    let (left, right) = partition x xs
    in quickSortOptimized left ++ [x] ++ quickSortOptimized right

-- 分区函数
partition :: Ord a => a -> [a] -> ([a], [a])
partition _ [] = ([], [])
partition pivot (x:xs) =
    let (left, right) = partition pivot xs
    in if x <= pivot
       then (x:left, right)
       else (left, x:right)

-- 三路快速排序（处理重复元素）
quickSort3Way :: Ord a => [a] -> [a]
quickSort3Way [] = []
quickSort3Way (x:xs) = 
    let (lt, eq, gt) = partition3Way x xs
    in quickSort3Way lt ++ eq ++ quickSort3Way gt

partition3Way :: Ord a => a -> [a] -> ([a], [a], [a])
partition3Way _ [] = ([], [], [])
partition3Way pivot (x:xs) =
    let (lt, eq, gt) = partition3Way pivot xs
    in case compare x pivot of
         LT -> (x:lt, eq, gt)
         EQ -> (lt, x:eq, gt)
         GT -> (lt, eq, x:gt)

-- 测试
testQuickSort :: Bool
testQuickSort = 
    quickSort [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9] &&
    quickSortOptimized [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9] &&
    quickSort3Way [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9]
```

### 堆排序 (Heap Sort)

**算法思想**：构建最大堆，依次取出堆顶元素。

**复杂度**：
- 时间复杂度：$O(n \log n)$
- 空间复杂度：$O(1)$
- 稳定性：不稳定

```haskell
-- 堆排序实现
heapSort :: Ord a => [a] -> [a]
heapSort xs = heapSort' (buildHeap xs)
  where
    heapSort' [] = []
    heapSort' heap = 
      let (max, rest) = extractMax heap
      in max : heapSort' rest

-- 堆数据结构
data Heap a = Empty | Node a (Heap a) (Heap a) deriving Show

-- 构建最大堆
buildHeap :: Ord a => [a] -> Heap a
buildHeap = foldr insertHeap Empty

-- 插入元素到堆
insertHeap :: Ord a => a -> Heap a -> Heap a
insertHeap x Empty = Node x Empty Empty
insertHeap x (Node v left right) =
    if x > v
    then Node x (insertHeap v left) right
    else Node v (insertHeap x left) right

-- 提取最大值
extractMax :: Ord a => Heap a -> (a, Heap a)
extractMax Empty = error "Empty heap"
extractMax (Node v left right) = (v, mergeHeaps left right)

-- 合并两个堆
mergeHeaps :: Ord a => Heap a -> Heap a -> Heap a
mergeHeaps Empty h = h
mergeHeaps h Empty = h
mergeHeaps (Node v1 l1 r1) (Node v2 l2 r2) =
    if v1 > v2
    then Node v1 (mergeHeaps l1 r1) (Node v2 l2 r2)
    else Node v2 (mergeHeaps l2 r2) (Node v1 l1 r1)

-- 测试
testHeapSort :: Bool
testHeapSort = 
    heapSort [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9]
```

## 特殊排序算法

### 计数排序 (Counting Sort)

**算法思想**：统计每个元素出现的次数，按顺序输出。

**复杂度**：
- 时间复杂度：$O(n + k)$，其中 $k$ 是元素范围
- 空间复杂度：$O(k)$
- 稳定性：稳定

```haskell
-- 计数排序实现
countingSort :: (Ord a, Enum a, Bounded a) => [a] -> [a]
countingSort xs = 
    let counts = buildCounts xs
    in reconstruct xs counts

-- 构建计数数组
buildCounts :: (Enum a, Bounded a) => [a] -> [(a, Int)]
buildCounts xs = 
    let allValues = [minBound..maxBound]
        counts = map (\x -> (x, length (filter (== x) xs))) allValues
    in filter ((> 0) . snd) counts

-- 重构排序序列
reconstruct :: (Ord a, Enum a) => [a] -> [(a, Int)] -> [a]
reconstruct _ [] = []
reconstruct xs ((x, count):rest) = 
    replicate count x ++ reconstruct xs rest

-- 测试
testCountingSort :: Bool
testCountingSort = 
    countingSort [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9]
```

### 基数排序 (Radix Sort)

**算法思想**：按位排序，从最低位到最高位。

**复杂度**：
- 时间复杂度：$O(d(n + k))$，其中 $d$ 是位数，$k$ 是基数
- 空间复杂度：$O(n + k)$
- 稳定性：稳定

```haskell
-- 基数排序实现
radixSort :: [Int] -> [Int]
radixSort xs = radixSort' xs 1
  where
    radixSort' xs _ | all (< 10) xs = countingSort xs
    radixSort' xs digit = 
      let sorted = countingSortByDigit xs digit
      in radixSort' sorted (digit * 10)

-- 按指定位数排序
countingSortByDigit :: [Int] -> Int -> [Int]
countingSortByDigit xs digit = 
    let counts = buildDigitCounts xs digit
    in reconstructByDigit xs counts digit

-- 构建位数计数
buildDigitCounts :: [Int] -> Int -> [(Int, Int)]
buildDigitCounts xs digit = 
    let digits = map (\x -> (x `div` digit) `mod` 10) xs
        allDigits = [0..9]
        counts = map (\d -> (d, length (filter (== d) digits))) allDigits
    in filter ((> 0) . snd) counts

-- 按位数重构
reconstructByDigit :: [Int] -> [(Int, Int)] -> Int -> [Int]
reconstructByDigit _ [] _ = []
reconstructByDigit xs ((digit, count):rest) divisor = 
    let matching = filter (\x -> (x `div` divisor) `mod` 10 == digit) xs
    in matching ++ reconstructByDigit xs rest divisor

-- 测试
testRadixSort :: Bool
testRadixSort = 
    radixSort [3,1,4,1,5,9,2,6] == [1,1,2,3,4,5,6,9]
```

## 形式化证明

### 归并排序的正确性

**定理**：归并排序算法能够正确排序任意序列。

**证明**：
1. **基础情况**：空序列和单元素序列已排序
2. **归纳步骤**：假设对长度为 $n$ 的序列正确，证明对长度为 $2n$ 的序列也正确
3. **合并正确性**：两个有序序列的合并结果仍有序

### 快速排序的期望复杂度

**定理**：快速排序的期望时间复杂度为 $O(n \log n)$。

**证明**：
设 $T(n)$ 为排序长度为 $n$ 的序列的期望时间，则：
$$T(n) = n + \frac{1}{n} \sum_{i=1}^{n} (T(i-1) + T(n-i))$$

通过数学归纳法可以证明 $T(n) = O(n \log n)$。

## 实际应用

### 性能比较

```haskell
-- 性能测试框架
import System.CPUTime
import Control.Exception

timeSort :: ([Int] -> [Int]) -> [Int] -> IO Double
timeSort sortFunc xs = do
    start <- getCPUTime
    let result = sortFunc xs
    end <- getCPUTime
    return $ fromIntegral (end - start) / 1000000000

-- 生成测试数据
generateTestData :: Int -> [Int]
generateTestData n = take n $ cycle [1..100]

-- 性能测试
performanceTest :: IO ()
performanceTest = do
    let testData = generateTestData 1000
    putStrLn "Performance comparison (1000 elements):"
    
    time1 <- timeSort bubbleSort testData
    putStrLn $ "Bubble Sort: " ++ show time1 ++ " seconds"
    
    time2 <- timeSort insertionSort testData
    putStrLn $ "Insertion Sort: " ++ show time2 ++ " seconds"
    
    time3 <- timeSort mergeSort testData
    putStrLn $ "Merge Sort: " ++ show time3 ++ " seconds"
    
    time4 <- timeSort quickSort testData
    putStrLn $ "Quick Sort: " ++ show time4 ++ " seconds"
```

### 实际应用场景

```haskell
-- 数据库查询结果排序
data Record = Record 
    { id :: Int
    , name :: String
    , score :: Double
    } deriving (Show, Eq)

-- 按分数排序
sortByScore :: [Record] -> [Record]
sortByScore = quickSort . map (\r -> (score r, r)) . map (\r -> (score r, r))

-- 多字段排序
sortByMultipleFields :: [Record] -> [Record]
sortByMultipleFields = 
    quickSort . map (\r -> (name r, score r, r)) . map (\r -> (name r, score r, r))

-- 使用示例
records :: [Record]
records = 
    [ Record 1 "Alice" 85.5
    , Record 2 "Bob" 92.0
    , Record 3 "Charlie" 78.5
    , Record 4 "Diana" 95.0
    ]

sortedRecords :: [Record]
sortedRecords = sortByScore records
```

## 总结

不同排序算法的特点：

1. **冒泡排序**：简单但效率低，适合小数据集
2. **选择排序**：简单，交换次数少
3. **插入排序**：对小数据集高效，稳定
4. **归并排序**：稳定，时间复杂度好，但需要额外空间
5. **快速排序**：平均情况下最快，但不稳定
6. **堆排序**：原地排序，时间复杂度好
7. **计数排序**：适合元素范围小的整数排序
8. **基数排序**：适合整数排序，稳定

选择排序算法时需要考虑：
- 数据规模
- 数据特征（是否已部分排序）
- 稳定性要求
- 空间限制
- 实现复杂度

---

**相关链接**：
- [图算法](图算法.md)
- [字符串算法](字符串算法.md)
- [优化算法](优化算法.md)
- [数据结构](../06-Data-Structures/基础数据结构.md) 