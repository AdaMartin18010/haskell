# 函数式编程基础

## 概述

函数式编程是一种编程范式，它将计算过程视为数学函数的求值，避免状态和可变数据。本章介绍函数式编程的核心概念和Haskell实现。

## 数学基础

### 函数定义

在数学中，函数 $f: A \rightarrow B$ 是从集合 $A$ 到集合 $B$ 的映射，满足：

- **单值性**：对于每个 $a \in A$，存在唯一的 $b \in B$ 使得 $f(a) = b$
- **确定性**：相同的输入总是产生相同的输出

### 函数组合

给定函数 $f: A \rightarrow B$ 和 $g: B \rightarrow C$，它们的组合 $g \circ f: A \rightarrow C$ 定义为：
$$(g \circ f)(a) = g(f(a))$$

### 高阶函数

高阶函数是接受函数作为参数或返回函数作为结果的函数。

## Haskell实现

### 基本函数定义

```haskell
-- 基本函数定义
add :: Int -> Int -> Int
add x y = x + y

-- 函数类型签名
-- add :: Int -> Int -> Int 表示 add 接受两个 Int 参数，返回 Int

-- 部分应用
addFive :: Int -> Int
addFive = add 5

-- 函数组合
compose :: (b -> c) -> (a -> b) -> a -> c
compose f g x = f (g x)

-- 使用 (.) 操作符
compose' :: (b -> c) -> (a -> b) -> a -> c
compose' = (.)
```

### 纯函数

```haskell
-- 纯函数：相同输入总是产生相同输出，无副作用
pureFunction :: Int -> Int
pureFunction x = x * x + 2 * x + 1

-- 非纯函数示例（在IO单子中）
impureFunction :: Int -> IO Int
impureFunction x = do
    putStrLn $ "Processing: " ++ show x
    return (x * x)

-- 测试纯函数
testPureFunction :: Bool
testPureFunction = 
    pureFunction 3 == pureFunction 3 &&  -- 确定性
    pureFunction 3 == 16                 -- 可预测
```

### 不可变性

```haskell
-- 不可变数据结构
data Point = Point { x :: Double, y :: Double }
    deriving (Show, Eq)

-- 创建新值而不是修改现有值
movePoint :: Point -> Double -> Double -> Point
movePoint (Point x y) dx dy = Point (x + dx) (y + dy)

-- 使用示例
origin :: Point
origin = Point 0 0

movedOrigin :: Point
movedOrigin = movePoint origin 1 2
-- 注意：origin 仍然是 (0, 0)，movedOrigin 是 (1, 2)
```

### 高阶函数1

```haskell
-- 接受函数作为参数
applyTwice :: (a -> a) -> a -> a
applyTwice f x = f (f x)

-- 返回函数作为结果
makeAdder :: Int -> (Int -> Int)
makeAdder n = \x -> x + n

-- 高阶函数示例
map' :: (a -> b) -> [a] -> [b]
map' _ [] = []
map' f (x:xs) = f x : map' f xs

filter' :: (a -> Bool) -> [a] -> [a]
filter' _ [] = []
filter' p (x:xs)
    | p x       = x : filter' p xs
    | otherwise = filter' p xs

foldr' :: (a -> b -> b) -> b -> [a] -> b
foldr' _ z [] = z
foldr' f z (x:xs) = f x (foldr' f z xs)
```

### 函数组合1

```haskell
-- 函数组合操作符
(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)

-- 使用函数组合
square :: Num a => a -> a
square x = x * x

double :: Num a => a -> a
double x = x * 2

-- 组合函数：先平方，再翻倍
squareThenDouble :: Num a => a -> a
squareThenDouble = double . square

-- 管道操作符（需要导入 Data.Function）
import Data.Function ((&))

-- 使用管道操作符
squareThenDouble' :: Num a => a -> a
squareThenDouble' x = x & square & double
```

### 惰性求值

```haskell
-- 惰性求值示例
infiniteList :: [Integer]
infiniteList = [1..]

-- 只计算需要的部分
takeFirstFive :: [Integer]
takeFirstFive = take 5 infiniteList

-- 惰性求值的优势
expensiveComputation :: Int -> Int
expensiveComputation n = 
    if n < 0 
        then error "Negative number"
        else sum [1..n]

-- 条件求值
conditionalEval :: Bool -> Int -> Int
conditionalEval True n = expensiveComputation n
conditionalEval False _ = 0

-- 只有在条件为真时才计算
safeEval :: Int -> Int
safeEval n = conditionalEval (n > 0) n
```

## 形式化证明

### 函数组合的结合律

**定理**：函数组合满足结合律，即对于函数 $f: A \rightarrow B$，$g: B \rightarrow C$，$h: C \rightarrow D$，有：
$$(h \circ g) \circ f = h \circ (g \circ f)$$

**证明**：
对于任意 $a \in A$，
$$\begin{align}
((h \circ g) \circ f)(a) &= (h \circ g)(f(a)) \\
&= h(g(f(a))) \\
&= h((g \circ f)(a)) \\
&= (h \circ (g \circ f))(a)
\end{align}$$

### Haskell验证

```haskell
-- 验证函数组合的结合律
associativityTest :: Bool
associativityTest =
    let f x = x + 1
        g x = x * 2
        h x = x - 3
        input = 5
    in ((h . g) . f) input == (h . (g . f)) input

-- 运行测试
testAssociativity :: IO ()
testAssociativity = do
    putStrLn $ "Associativity test: " ++ show associativityTest
```

## 实际应用

### 数据处理管道

```haskell
-- 数据处理管道示例
data Person = Person
    { name :: String
    , age :: Int
    , salary :: Double
    } deriving (Show)

-- 示例数据
people :: [Person]
people =
    [ Person "Alice" 25 50000
    , Person "Bob" 30 60000
    , Person "Charlie" 35 70000
    , Person "Diana" 28 55000
    ]

-- 数据处理管道
processPeople :: [Person] -> [String]
processPeople =
    filter (\p -> age p > 25)           -- 过滤年龄大于25的人
    . filter (\p -> salary p > 55000)   -- 过滤工资大于55000的人
    . map (\p -> name p ++ " - $" ++ show (salary p))  -- 格式化输出

-- 使用管道
result :: [String]
result = processPeople people
```

### 配置管理

```haskell
-- 配置管理示例
data Config = Config
    { host :: String
    , port :: Int
    , timeout :: Int
    } deriving (Show)

-- 默认配置
defaultConfig :: Config
defaultConfig = Config "localhost" 8080 30

-- 配置更新函数
updateHost :: String -> Config -> Config
updateHost newHost config = config { host = newHost }

updatePort :: Int -> Config -> Config
updatePort newPort config = config { port = newPort }

updateTimeout :: Int -> Config -> Config
updateTimeout newTimeout config = config { timeout = newTimeout }

-- 配置构建器
buildConfig :: String -> Int -> Int -> Config
buildConfig h p t =
    defaultConfig
    & updateHost h
    & updatePort p
    & updateTimeout t
```

## 性能考虑

### 内存使用

```haskell
-- 内存效率的列表处理
efficientSum :: [Int] -> Int
efficientSum = foldl' (+) 0  -- 使用严格版本的foldl

-- 避免中间列表
efficientFilter :: (a -> Bool) -> [a] -> [a]
efficientFilter p = foldr (\x acc -> if p x then x:acc else acc) []

-- 流处理
streamProcess :: [Int] -> [Int]
streamProcess =
    filter (> 0)      -- 惰性过滤
    . map (* 2)       -- 惰性映射
    . take 1000       -- 只取前1000个元素
```

### 优化技巧

```haskell
-- 使用严格求值避免内存泄漏
strictEval :: [Int] -> Int
strictEval = foldl' (+) 0

-- 使用seq强制求值
forceEval :: a -> b -> b
forceEval x y = seq x y

-- 避免重复计算
memoizedFib :: Int -> Integer
memoizedFib = (map fib [0..] !!)
    where fib 0 = 0
          fib 1 = 1
          fib n = memoizedFib (n-1) + memoizedFib (n-2)
```

## 总结

函数式编程的核心特征：

1. **纯函数**：相同输入总是产生相同输出，无副作用
2. **不可变性**：数据一旦创建就不能修改
3. **高阶函数**：函数可以作为参数和返回值
4. **函数组合**：通过组合简单函数构建复杂功能
5. **惰性求值**：只在需要时计算表达式

这些特性使得函数式程序更加：
- **可预测**：纯函数的行为完全由输入决定
- **可测试**：没有副作用，易于单元测试
- **可组合**：函数可以自由组合和重用
- **可并行**：没有共享状态，天然支持并行计算

---

**相关链接**：
- [Haskell语言特性](Haskell语言特性.md)
- [表达式与求值](表达式与求值.md)
- [模式匹配](模式匹配.md)
- [类型系统](../04-Type-System/类型基础.md)
