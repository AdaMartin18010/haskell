# Haskell 模式匹配 (Pattern Matching)

## 概述

模式匹配是Haskell函数式编程的核心特性，它允许我们根据数据的结构来分解和匹配值。模式匹配提供了声明式的编程风格，使代码更加清晰和表达力强。

## 数学定义

### 模式匹配的形式化定义

给定一个数据类型 $T$ 和值 $v \in T$，模式匹配可以形式化为：

$$\text{match}(v, p) = \begin{cases}
\text{True} & \text{if } v \text{ matches pattern } p \\
\text{False} & \text{otherwise}
\end{cases}$$

### 模式匹配的语义

对于模式 $p$ 和值 $v$，匹配关系 $\models$ 定义为：

$$v \models p \iff \exists \sigma : \text{Var} \to \text{Value} \text{ such that } \sigma(p) = v$$

其中 $\sigma$ 是变量绑定函数。

## 基本模式类型

### 1. 变量模式 (Variable Pattern)

```haskell
-- 变量模式匹配任何值并绑定到变量
f x = x + 1

-- 数学定义：对于任意值 v，v 匹配变量模式 x
-- 绑定：σ(x) = v
```

### 2. 常量模式 (Constant Pattern)

```haskell
-- 常量模式只匹配特定值
isZero 0 = True
isZero _ = False

-- 数学定义：v 匹配常量模式 c 当且仅当 v = c
-- 0 ⊨ 0 为 True，其他值 ⊨ 0 为 False
```

### 3. 通配符模式 (Wildcard Pattern)

```haskell
-- 通配符模式匹配任何值但不绑定
const42 _ = 42

-- 数学定义：对于任意值 v，v ⊨ _ 为 True
-- 不产生任何绑定
```

### 4. 构造函数模式 (Constructor Pattern)

```haskell
-- 列表构造函数模式
head' (x:_) = x
head' [] = error "Empty list"

-- Maybe 类型模式
fromJust (Just x) = x
fromJust Nothing = error "Nothing"

-- 数学定义：对于构造函数 C 和值 v
-- v ⊨ C p₁ ... pₙ 当且仅当 v = C v₁ ... vₙ 且 vᵢ ⊨ pᵢ
```

## 高级模式匹配

### 1. 嵌套模式 (Nested Patterns)

```haskell
-- 嵌套模式匹配复杂数据结构
extractFirst :: [[a]] -> Maybe a
extractFirst ((x:_):_) = Just x
extractFirst _ = Nothing

-- 数学定义：嵌套模式匹配需要递归应用匹配关系
-- v ⊨ C(p₁, ..., pₙ) 当且仅当 v = C(v₁, ..., vₙ) 且 ∀i. vᵢ ⊨ pᵢ
```

### 2. 记录模式 (Record Patterns)

```haskell
-- 定义记录类型
data Person = Person 
    { name :: String
    , age :: Int
    , city :: String
    }

-- 记录模式匹配
greet (Person {name = n, age = a}) = 
    "Hello " ++ n ++ ", you are " ++ show a ++ " years old"

-- 数学定义：记录模式匹配字段值
-- v ⊨ {f₁ = p₁, ..., fₙ = pₙ} 当且仅当 v.fᵢ ⊨ pᵢ
```

### 3. 模式守卫 (Pattern Guards)

```haskell
-- 使用模式守卫进行条件匹配
classifyNumber :: Int -> String
classifyNumber n
    | n < 0 = "Negative"
    | n == 0 = "Zero"
    | n > 0 = "Positive"

-- 数学定义：模式守卫是条件模式的组合
-- match(v, p | g) = match(v, p) ∧ eval(g)
```

## 模式匹配的代数性质

### 1. 结合律

对于模式 $p_1, p_2, p_3$：

$$(p_1 \oplus p_2) \oplus p_3 = p_1 \oplus (p_2 \oplus p_3)$$

其中 $\oplus$ 表示模式组合操作。

### 2. 分配律

对于模式 $p$ 和条件 $g_1, g_2$：

$$p \land (g_1 \lor g_2) = (p \land g_1) \lor (p \land g_2)$$

### 3. 幂等律

对于模式 $p$：

$$p \oplus p = p$$

## 实际应用示例

### 1. 列表处理

```haskell
-- 列表模式匹配的完整示例
listProcessor :: [Int] -> String
listProcessor [] = "Empty list"
listProcessor [x] = "Single element: " ++ show x
listProcessor (x:y:[]) = "Two elements: " ++ show x ++ ", " ++ show y
listProcessor (x:y:z:xs) = "Multiple elements starting with: " ++ 
                           show x ++ ", " ++ show y ++ ", " ++ show z

-- 测试
main :: IO ()
main = do
    print $ listProcessor []           -- "Empty list"
    print $ listProcessor [1]          -- "Single element: 1"
    print $ listProcessor [1, 2]       -- "Two elements: 1, 2"
    print $ listProcessor [1, 2, 3, 4] -- "Multiple elements starting with: 1, 2, 3"
```

### 2. 树结构处理

```haskell
-- 二叉树定义
data Tree a = Empty | Node a (Tree a) (Tree a)

-- 树模式匹配
treeSize :: Tree a -> Int
treeSize Empty = 0
treeSize (Node _ left right) = 1 + treeSize left + treeSize right

treeHeight :: Tree a -> Int
treeHeight Empty = 0
treeHeight (Node _ left right) = 1 + max (treeHeight left) (treeHeight right)

-- 测试
main :: IO ()
main = do
    let tree = Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)
    print $ treeSize tree   -- 3
    print $ treeHeight tree -- 2
```

### 3. 错误处理

```haskell
-- Maybe 类型的模式匹配
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

processResult :: Maybe Double -> String
processResult Nothing = "Division by zero error"
processResult (Just result) = "Result: " ++ show result

-- Either 类型的模式匹配
data CalculationError = DivisionByZero | InvalidInput String

safeDivideEither :: Double -> Double -> Either CalculationError Double
safeDivideEither _ 0 = Left DivisionByZero
safeDivideEither x y = Right (x / y)

handleCalculation :: Either CalculationError Double -> String
handleCalculation (Left DivisionByZero) = "Division by zero error"
handleCalculation (Left (InvalidInput msg)) = "Invalid input: " ++ msg
handleCalculation (Right result) = "Result: " ++ show result
```

## 模式匹配的优化

### 1. 编译时优化

Haskell编译器对模式匹配进行多种优化：

```haskell
-- 编译器会优化为跳转表
optimizedMatch :: Int -> String
optimizedMatch 0 = "Zero"
optimizedMatch 1 = "One"
optimizedMatch 2 = "Two"
optimizedMatch _ = "Other"

-- 数学定义：编译器生成最优的匹配顺序
-- 时间复杂度：O(1) 对于常量模式
```

### 2. 模式匹配的完整性检查

```haskell
-- 完整的模式匹配（编译器会检查）
data Color = Red | Green | Blue

colorToString :: Color -> String
colorToString Red = "Red"
colorToString Green = "Green"
colorToString Blue = "Blue"

-- 数学定义：完整性检查确保 ∀v ∈ Color. ∃p. v ⊨ p
```

## 形式化验证

### 1. 模式匹配的正确性

```haskell
-- 使用 QuickCheck 验证模式匹配的正确性
import Test.QuickCheck

-- 属性：模式匹配应该保持值的不变性
prop_patternMatchPreservesValue :: [Int] -> Bool
prop_patternMatchPreservesValue xs = 
    case xs of
        [] -> length xs == 0
        (y:ys) -> length xs == 1 + length ys

-- 测试
main :: IO ()
main = quickCheck prop_patternMatchPreservesValue
```

### 2. 模式匹配的终止性

```haskell
-- 确保模式匹配总是终止
-- 通过结构归纳法证明

-- 对于列表模式匹配的终止性证明：
-- 基础情况：[] 模式直接匹配
-- 归纳步骤：对于 (x:xs) 模式，xs 比原列表短
-- 因此递归调用会终止
```

## 总结

模式匹配是Haskell函数式编程的核心特性，它提供了：

1. **声明式编程**：通过模式描述数据结构
2. **类型安全**：编译时检查模式完整性
3. **性能优化**：编译器生成高效的匹配代码
4. **可读性**：代码意图清晰明确

模式匹配的数学基础确保了其正确性和可靠性，使其成为函数式编程中不可或缺的工具。

---

**相关主题**：
- [函数式编程基础](./函数式编程基础.md)
- [类型系统](../04-Type-System/类型基础.md)
- [递归函数](../02-Control-Flow/递归函数.md)
