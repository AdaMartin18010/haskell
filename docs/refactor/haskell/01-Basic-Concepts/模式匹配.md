# Haskell 模式匹配 (Pattern Matching)

## 概述

模式匹配是Haskell函数式编程的核心特性，它允许我们根据数据的结构来分解和匹配值。模式匹配不仅是一种语法特性，更是一种强大的抽象机制，体现了代数数据类型和函数式编程的数学基础。

## 数学基础

### 代数数据类型的形式化定义

在范畴论中，代数数据类型可以形式化为：

$$\text{ADT} = \sum_{i=1}^{n} \prod_{j=1}^{m_i} T_{i,j}$$

其中：
- $\sum$ 表示余积（coproduct）
- $\prod$ 表示积（product）
- $T_{i,j}$ 是类型参数

### 模式匹配的语义

模式匹配的语义可以形式化为：

$$\text{match}(p, v) = \begin{cases}
\text{Just } \sigma & \text{if } v \text{ matches } p \text{ with substitution } \sigma \\
\text{Nothing} & \text{otherwise}
\end{cases}$$

## 基本模式

### 1. 变量模式

```haskell
-- 变量模式：匹配任何值并绑定到变量
f x = x + 1

-- 数学定义：变量模式 $v$ 匹配任何值 $x$，产生替换 $\{v \mapsto x\}$
```

### 2. 常量模式

```haskell
-- 常量模式：匹配特定值
isZero 0 = True
isZero _ = False

-- 数学定义：常量模式 $c$ 只匹配值 $c$
```

### 3. 通配符模式

```haskell
-- 通配符模式：匹配任何值但不绑定
head (x:_) = x
tail (_:xs) = xs

-- 数学定义：通配符模式 $_$ 匹配任何值，不产生绑定
```

### 4. 构造函数模式

```haskell
-- 列表构造函数模式
sumList [] = 0
sumList (x:xs) = x + sumList xs

-- Maybe类型模式
safeHead [] = Nothing
safeHead (x:_) = Just x

-- 数学定义：构造函数模式 $C(p_1, \ldots, p_n)$ 匹配值 $C(v_1, \ldots, v_n)$
-- 当且仅当每个 $p_i$ 匹配对应的 $v_i$
```

## 高级模式

### 1. 嵌套模式

```haskell
-- 嵌套模式匹配
extractFirst :: [[a]] -> Maybe a
extractFirst ((x:_):_) = Just x
extractFirst _ = Nothing

-- 数学定义：嵌套模式 $p_1(p_2(\ldots))$ 的匹配需要逐层验证
```

### 2. 记录模式

```haskell
-- 记录类型定义
data Person = Person 
    { name :: String
    , age :: Int
    , email :: String
    }

-- 记录模式匹配
greet (Person {name = n, age = a}) = 
    "Hello " ++ n ++ ", you are " ++ show a ++ " years old"

-- 数学定义：记录模式 $\{f_1 = p_1, \ldots, f_n = p_n\}$ 匹配记录值
-- $\{f_1 = v_1, \ldots, f_n = v_n\}$ 当且仅当每个 $p_i$ 匹配 $v_i$
```

### 3. 模式守卫

```haskell
-- 模式守卫：结合模式匹配和条件判断
classifyNumber :: Int -> String
classifyNumber n
    | n < 0     = "Negative"
    | n == 0    = "Zero"
    | n < 10    = "Small positive"
    | otherwise = "Large positive"

-- 数学定义：模式守卫 $\text{pattern} \mid \text{guard} \rightarrow \text{expr}$
-- 当模式匹配成功且守卫条件为真时执行
```

## 模式匹配的语义

### 匹配顺序

Haskell中的模式匹配遵循以下规则：

1. **从上到下**：模式按定义顺序尝试匹配
2. **从左到右**：在函数参数中从左到右匹配
3. **最具体优先**：更具体的模式优先于更一般的模式

### 完备性检查

```haskell
-- 不完备的模式匹配（会编译警告）
partialFunction :: Bool -> String
partialFunction True = "True"

-- 完备的模式匹配
completeFunction :: Bool -> String
completeFunction True = "True"
completeFunction False = "False"
```

## 高级应用

### 1. 视图模式

```haskell
-- 视图模式：使用函数转换值后再匹配
{-# LANGUAGE ViewPatterns #-}

-- 定义视图函数
isEven :: Int -> Bool
isEven n = n `mod` 2 == 0

-- 使用视图模式
describeNumber :: Int -> String
describeNumber (isEven -> True) = "Even number"
describeNumber (isEven -> False) = "Odd number"
```

### 2. 模式同义词

```haskell
{-# LANGUAGE PatternSynonyms #-}

-- 定义模式同义词
pattern Empty = []
pattern Single x = [x]
pattern Double x y = [x, y]

-- 使用模式同义词
listLength :: [a] -> Int
listLength Empty = 0
listLength (Single _) = 1
listLength (Double _ _) = 2
listLength (_:_:_) = 3  -- 其他情况
```

### 3. 双向模式

```haskell
{-# LANGUAGE PatternSynonyms #-}

-- 双向模式同义词
pattern NonEmpty x xs <- (x:xs)
  where
    NonEmpty x xs = x:xs

-- 使用双向模式
safeHead :: [a] -> Maybe a
safeHead (NonEmpty x _) = Just x
safeHead _ = Nothing
```

## 形式化语义

### 模式匹配的类型系统

模式匹配的类型系统可以形式化为：

$$\frac{\Gamma \vdash p : \tau \quad \Gamma \vdash e : \tau \quad \Gamma, \sigma \vdash e' : \tau'}{\Gamma \vdash \text{case } e \text{ of } \{ p \rightarrow e' \} : \tau'}$$

其中：
- $\Gamma$ 是类型环境
- $p$ 是模式
- $e$ 是被匹配的表达式
- $\sigma$ 是模式匹配产生的绑定

### 模式匹配的求值规则

$$\frac{v \text{ matches } p \text{ with } \sigma \quad \sigma(e') \Downarrow v'}{\text{case } v \text{ of } \{ p \rightarrow e' \} \Downarrow v'}$$

## 实际应用示例

### 1. 解析器组合子

```haskell
-- 简单的解析器类型
newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }

-- 模式匹配在解析器中的应用
parseChar :: Char -> Parser Char
parseChar c = Parser $ \input ->
    case input of
        (x:xs) | x == c -> Just (c, xs)
        _ -> Nothing

parseDigit :: Parser Int
parseDigit = Parser $ \input ->
    case input of
        (x:xs) | x `elem` "0123456789" -> Just (read [x], xs)
        _ -> Nothing
```

### 2. 状态机

```haskell
-- 状态机定义
data State = Idle | Running | Paused | Stopped
data Event = Start | Pause | Resume | Stop

-- 使用模式匹配实现状态转换
transition :: State -> Event -> State
transition Idle Start = Running
transition Running Pause = Paused
transition Running Stop = Stopped
transition Paused Resume = Running
transition Paused Stop = Stopped
transition _ _ = error "Invalid transition"
```

### 3. 表达式求值

```haskell
-- 表达式类型
data Expr = Lit Int
          | Add Expr Expr
          | Mul Expr Expr
          | Sub Expr Expr

-- 使用模式匹配求值
eval :: Expr -> Int
eval (Lit n) = n
eval (Add e1 e2) = eval e1 + eval e2
eval (Mul e1 e2) = eval e1 * eval e2
eval (Sub e1 e2) = eval e1 - eval e2
```

## 性能考虑

### 1. 模式匹配的编译优化

Haskell编译器对模式匹配进行多种优化：

```haskell
-- 编译器会优化为决策树
optimizedMatch :: [Int] -> String
optimizedMatch [] = "Empty"
optimizedMatch [x] = "Single: " ++ show x
optimizedMatch [x, y] = "Double: " ++ show x ++ ", " ++ show y
optimizedMatch (x:y:z:_) = "Multiple: " ++ show x ++ ", " ++ show y ++ ", " ++ show z
```

### 2. 严格性分析

```haskell
-- 严格模式匹配
strictMatch :: [Int] -> Int
strictMatch (x:_) = x + 1  -- x被严格求值

-- 惰性模式匹配
lazyMatch :: [Int] -> Int
lazyMatch ~(x:_) = 42  -- x不会被立即求值
```

## 总结

模式匹配是Haskell函数式编程的核心特性，它：

1. **提供类型安全**：编译时检查模式完备性
2. **支持代数数据类型**：自然地处理复杂数据结构
3. **实现函数式抽象**：通过模式匹配实现函数式编程的核心概念
4. **优化性能**：编译器可以生成高效的决策树代码

模式匹配体现了函数式编程的数学基础，将代数数据类型的概念直接映射到编程语言中，使得代码既简洁又具有强大的表达能力。

---

**相关主题**：
- [函数式编程基础](函数式编程基础.md)
- [类型系统](../04-Type-System/类型基础.md)
- [代数数据类型](../04-Type-System/高级类型.md)
- [函数定义](函数定义.md) 