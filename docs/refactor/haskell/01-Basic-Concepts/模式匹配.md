# Haskell 模式匹配 (Pattern Matching)

## 概述

模式匹配是Haskell函数式编程的核心特性，它允许我们根据数据的结构来分解和匹配值。模式匹配提供了声明式的编程风格，使代码更加清晰和表达力强。

## 数学定义

### 模式匹配的形式化定义

在类型论中，模式匹配可以形式化为：

$$\text{match} : \Pi_{(x:A)} \Sigma_{(p:P)} \text{Pattern}(p) \times (p \rightarrow B) \rightarrow B$$

其中：

- $A$ 是数据类型
- $P$ 是模式集合
- $\text{Pattern}(p)$ 表示模式 $p$ 的有效性
- $B$ 是结果类型

### 模式匹配的公理

1. **完备性公理**: 对于所有值 $v : A$，存在模式 $p$ 使得 $v$ 匹配 $p$
2. **排他性公理**: 如果 $v$ 匹配模式 $p_1$ 和 $p_2$，则 $p_1 = p_2$
3. **构造性公理**: 每个模式都对应一个构造器

## 基本模式类型

### 1. 变量模式

```haskell
-- 变量模式：匹配任何值并绑定到变量
f :: Int -> Int
f x = x + 1

-- 数学定义：变量模式 $v$ 匹配任何值 $x$，且 $v \mapsto x$
```

### 2. 常量模式

```haskell
-- 常量模式：匹配特定值
isZero :: Int -> Bool
isZero 0 = True
isZero _ = False

-- 数学定义：常量模式 $c$ 匹配当且仅当 $x = c$
```

### 3. 构造器模式

```haskell
-- 列表构造器模式
data List a = Nil | Cons a (List a)

sumList :: List Int -> Int
sumList Nil = 0
sumList (Cons x xs) = x + sumList xs

-- 数学定义：构造器模式 $C(p_1, ..., p_n)$ 匹配当且仅当
-- $x = C(v_1, ..., v_n)$ 且每个 $v_i$ 匹配 $p_i$
```

### 4. 元组模式

```haskell
-- 元组模式
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)

-- 数学定义：元组模式 $(p_1, p_2)$ 匹配当且仅当
-- $x = (v_1, v_2)$ 且 $v_1$ 匹配 $p_1$，$v_2$ 匹配 $p_2$
```

### 5. 记录模式

```haskell
-- 记录模式
data Person = Person { name :: String, age :: Int }

greet :: Person -> String
greet (Person { name = n, age = a }) = "Hello " ++ n ++ ", you are " ++ show a ++ " years old"

-- 数学定义：记录模式 $\{f_1 = p_1, ..., f_n = p_n\}$ 匹配当且仅当
-- $x = \{f_1 = v_1, ..., f_n = v_n\}$ 且每个 $v_i$ 匹配 $p_i$
```

## 高级模式特性

### 1. 模式守卫

```haskell
-- 模式守卫：在模式匹配中添加条件
absolute :: Int -> Int
absolute x
  | x < 0     = -x
  | otherwise = x

-- 数学定义：模式守卫 $p \mid g$ 匹配当且仅当
-- $x$ 匹配 $p$ 且 $g(x)$ 为真
```

### 2. 模式绑定

```haskell
-- 模式绑定：使用 @ 符号绑定整个值
f :: [Int] -> Int
f xs@(x:_) = length xs + x
f [] = 0

-- 数学定义：模式绑定 $v@p$ 匹配当且仅当
-- $x$ 匹配 $p$ 且 $v \mapsto x$
```

### 3. 惰性模式

```haskell
-- 惰性模式：使用 ~ 符号进行惰性匹配
f :: [Int] -> Int
f ~(x:xs) = 1

-- 数学定义：惰性模式 $\sim p$ 总是匹配，
-- 但只在需要时才计算 $p$ 的子模式
```

## 模式匹配的语义

### 匹配顺序

```haskell
-- 模式按从上到下的顺序匹配
factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n - 1)

-- 数学定义：匹配顺序确保第一个匹配的模式被选择
```

### 穷尽性检查

```haskell
-- 编译器检查模式是否穷尽
data Color = Red | Green | Blue

colorName :: Color -> String
colorName Red = "Red"
colorName Green = "Green"
colorName Blue = "Blue"

-- 数学定义：穷尽性检查确保对于所有 $x : A$，
-- 存在模式 $p$ 使得 $x$ 匹配 $p$
```

## 实际应用示例

### 1. 二叉树操作

```haskell
data Tree a = Empty | Node a (Tree a) (Tree a)

-- 计算树的高度
height :: Tree a -> Int
height Empty = 0
height (Node _ left right) = 1 + max (height left) (height right)

-- 中序遍历
inorder :: Tree a -> [a]
inorder Empty = []
inorder (Node x left right) = inorder left ++ [x] ++ inorder right

-- 查找元素
find :: Eq a => a -> Tree a -> Bool
find _ Empty = False
find x (Node y left right)
  | x == y    = True
  | x < y     = find x left
  | otherwise = find x right
```

### 2. JSON解析

```haskell
data JSON = JNull
          | JBool Bool
          | JNumber Double
          | JString String
          | JArray [JSON]
          | JObject [(String, JSON)]

-- JSON求值
evalJSON :: JSON -> Maybe String
evalJSON JNull = Just "null"
evalJSON (JBool b) = Just (show b)
evalJSON (JNumber n) = Just (show n)
evalJSON (JString s) = Just s
evalJSON (JArray xs) = Just ("[" ++ concat (mapMaybe evalJSON xs) ++ "]")
evalJSON (JObject pairs) = Just ("{" ++ concatMap showPair pairs ++ "}")
  where
    showPair (k, v) = k ++ ":" ++ maybe "null" id (evalJSON v)
```

### 3. 状态机

```haskell
data State = S0 | S1 | S2
data Event = E0 | E1 | E2

-- 状态转换函数
transition :: State -> Event -> State
transition S0 E0 = S1
transition S0 E1 = S2
transition S1 E0 = S2
transition S1 E1 = S0
transition S2 E0 = S0
transition S2 E1 = S1
transition _ _ = S0  -- 默认状态

-- 状态机执行
runStateMachine :: [Event] -> State -> [State]
runStateMachine [] state = [state]
runStateMachine (e:es) state = 
  let nextState = transition state e
  in state : runStateMachine es nextState
```

## 性能考虑

### 1. 模式匹配的编译

```haskell
-- 编译器将模式匹配转换为决策树
-- 例如：
f :: Int -> String
f 0 = "zero"
f 1 = "one"
f 2 = "two"
f _ = "other"

-- 编译为：
-- if x == 0 then "zero"
-- else if x == 1 then "one"
-- else if x == 2 then "two"
-- else "other"
```

### 2. 模式匹配的优化

```haskell
-- 使用模式匹配优化递归
fibonacci :: Int -> Int
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n-1) + fibonacci (n-2)

-- 使用记忆化优化
fibonacciMemo :: Int -> Int
fibonacciMemo = (map fib [0..] !!)
  where
    fib 0 = 0
    fib 1 = 1
    fib n = fibonacciMemo (n-1) + fibonacciMemo (n-2)
```

## 形式化验证

### 1. 模式匹配的正确性

```haskell
-- 使用QuickCheck验证模式匹配的正确性
import Test.QuickCheck

-- 验证列表反转的性质
prop_reverse :: [Int] -> Bool
prop_reverse xs = reverse (reverse xs) == xs

-- 验证模式匹配的完备性
prop_pattern_completeness :: [Int] -> Bool
prop_pattern_completeness xs = 
  case xs of
    [] -> True
    (y:ys) -> True
```

### 2. 类型安全

```haskell
-- 模式匹配保证类型安全
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:_) = Just x

-- 类型系统确保：
-- 1. 所有模式都有相同的返回类型
-- 2. 模式匹配是穷尽的
-- 3. 变量绑定是类型安全的
```

## 总结

模式匹配是Haskell函数式编程的核心特性，它提供了：

1. **声明式编程**: 通过模式描述数据结构
2. **类型安全**: 编译时检查模式匹配的正确性
3. **穷尽性检查**: 确保所有情况都被处理
4. **性能优化**: 编译器可以优化模式匹配的执行

模式匹配使得Haskell代码更加清晰、安全和高效，是函数式编程的重要工具。

---

**相关主题**:

- [函数式编程基础](./函数式编程基础.md)
- [类型系统](../04-Type-System/类型基础.md)
- [递归函数](../02-Control-Flow/02-Recursive-Functions.md)
- [高阶函数](../02-Control-Flow/03-Higher-Order-Functions.md)
