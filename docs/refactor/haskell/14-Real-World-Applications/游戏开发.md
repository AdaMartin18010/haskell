# 游戏开发 - Haskell实现

## 概述

游戏开发是Haskell在实际应用中的重要领域，通过函数式编程的特性可以构建高性能、可维护的游戏系统。本文档使用Haskell实现游戏开发的核心组件，包括游戏引擎、物理模拟、游戏逻辑、渲染等。

## 游戏引擎架构

### 基本框架

```haskell
-- 游戏状态
data GameState = GameState
    { entities :: Map EntityId Entity
    , systems :: [GameSystem]
    , time :: Time
    , input :: InputState
    , renderer :: Renderer
    , physics :: PhysicsEngine
    } deriving Show

-- 实体ID
newtype EntityId = EntityId Int
    deriving (Show, Eq, Ord)

-- 实体
data Entity = Entity
    { id :: EntityId
    , position :: Vector2D
    , velocity :: Vector2D
    , acceleration :: Vector2D
    , rotation :: Double
    , angularVelocity :: Double
    , mass :: Double
    , collider :: Maybe Collider
    , renderable :: Maybe Renderable
    , components :: Map ComponentType Component
    } deriving Show

-- 组件类型
data ComponentType = 
    TransformComponent
    | PhysicsComponent
    | RenderComponent
    | InputComponent
    | AIComponent
    | HealthComponent
    deriving (Show, Eq, Ord)

-- 组件
data Component = 
    TransformComponentData Vector2D Double
    | PhysicsComponentData Vector2D Vector2D Double
    | RenderComponentData Sprite
    | InputComponentData InputHandler
    | AIComponentData AIState
    | HealthComponentData Double Double
    deriving Show

-- 游戏系统
type GameSystem = GameState -> GameState

-- 游戏循环
gameLoop :: GameState -> IO GameState
gameLoop state = do
    -- 处理输入
    input <- processInput (input state)
    
    -- 更新游戏状态
    let updatedState = updateGameState state { input = input }
    
    -- 渲染
    render (renderer updatedState) updatedState
    
    -- 继续循环
    gameLoop updatedState

-- 更新游戏状态
updateGameState :: GameState -> GameState
updateGameState state = 
    foldl (\s system -> system s) state (systems state)
```

### 向量和数学库

```haskell
-- 二维向量
data Vector2D = Vector2D
    { x :: Double
    , y :: Double
    } deriving (Show, Eq)

-- 向量运算
instance Num Vector2D where
    (+) (Vector2D x1 y1) (Vector2D x2 y2) = Vector2D (x1 + x2) (y1 + y2)
    (-) (Vector2D x1 y1) (Vector2D x2 y2) = Vector2D (x1 - x2) (y1 - y2)
    (*) (Vector2D x1 y1) (Vector2D x2 y2) = Vector2D (x1 * x2) (y1 * y2)
    abs (Vector2D x y) = Vector2D (abs x) (abs y)
    signum (Vector2D x y) = Vector2D (signum x) (signum y)
    fromInteger n = Vector2D (fromInteger n) (fromInteger n)

-- 向量标量运算
scalarMultiply :: Double -> Vector2D -> Vector2D
scalarMultiply s (Vector2D x y) = Vector2D (s * x) (s * y)

-- 向量点积
dotProduct :: Vector2D -> Vector2D -> Double
dotProduct (Vector2D x1 y1) (Vector2D x2 y2) = x1 * x2 + y1 * y2

-- 向量长度
magnitude :: Vector2D -> Double
magnitude v = sqrt (dotProduct v v)

-- 向量归一化
normalize :: Vector2D -> Vector2D
normalize v = scalarMultiply (1 / magnitude v) v

-- 向量距离
distance :: Vector2D -> Vector2D -> Double
distance v1 v2 = magnitude (v1 - v2)

-- 时间
data Time = Time
    { deltaTime :: Double
    , totalTime :: Double
    } deriving Show

-- 输入状态
data InputState = InputState
    { keys :: Set Key
    , mousePosition :: Vector2D
    , mouseButtons :: Set MouseButton
    } deriving Show

-- 按键
data Key = 
    KeyW | KeyA | KeyS | KeyD
    | KeySpace | KeyEnter | KeyEscape
    deriving (Show, Eq, Ord)

-- 鼠标按钮
data MouseButton = 
    MouseLeft | MouseRight | MouseMiddle
    deriving (Show, Eq, Ord)
```

## 物理引擎

### 物理组件

```haskell
-- 碰撞体
data Collider = 
    CircleCollider Double
    | RectangleCollider Double Double
    | PolygonCollider [Vector2D]
    deriving Show

-- 物理引擎
data PhysicsEngine = PhysicsEngine
    { gravity :: Vector2D
    , airResistance :: Double
    , collisionPairs :: [(EntityId, EntityId)]
    } deriving Show

-- 物理系统
physicsSystem :: GameSystem
physicsSystem state = 
    let entities = Map.elems (entities state)
        updatedEntities = map updateEntityPhysics entities
        newEntities = Map.fromList [(id entity, entity) | entity <- updatedEntities]
        collisionPairs = detectCollisions updatedEntities
        resolvedEntities = resolveCollisions collisionPairs newEntities
    in state { entities = resolvedEntities }

-- 更新实体物理
updateEntityPhysics :: Entity -> Entity
updateEntityPhysics entity = 
    let newVelocity = velocity entity + acceleration entity
        newPosition = position entity + newVelocity
        newRotation = rotation entity + angularVelocity entity
    in entity { position = newPosition
              , velocity = newVelocity
              , rotation = newRotation }

-- 检测碰撞
detectCollisions :: [Entity] -> [(EntityId, EntityId)]
detectCollisions entities = 
    let pairs = [(e1, e2) | e1 <- entities, e2 <- entities, id e1 < id e2]
        collidingPairs = filter (\(e1, e2) -> 
            case (collider e1, collider e2) of
                (Just c1, Just c2) -> checkCollision (position e1) c1 (position e2) c2
                _ -> False) pairs
    in [(id e1, id e2) | (e1, e2) <- collidingPairs]

-- 检查碰撞
checkCollision :: Vector2D -> Collider -> Vector2D -> Collider -> Bool
checkCollision pos1 c1 pos2 c2 = 
    case (c1, c2) of
        (CircleCollider r1, CircleCollider r2) -> 
            distance pos1 pos2 < r1 + r2
        (RectangleCollider w1 h1, RectangleCollider w2 h2) -> 
            checkRectangleCollision pos1 w1 h1 pos2 w2 h2
        (CircleCollider r1, RectangleCollider w2 h2) -> 
            checkCircleRectangleCollision pos1 r1 pos2 w2 h2
        (RectangleCollider w1 h1, CircleCollider r2) -> 
            checkCircleRectangleCollision pos2 r2 pos1 w1 h1
        _ -> False

-- 矩形碰撞检测
checkRectangleCollision :: Vector2D -> Double -> Double -> Vector2D -> Double -> Double -> Bool
checkRectangleCollision pos1 w1 h1 pos2 w2 h2 = 
    let left1 = x pos1 - w1 / 2
        right1 = x pos1 + w1 / 2
        top1 = y pos1 - h1 / 2
        bottom1 = y pos1 + h1 / 2
        left2 = x pos2 - w2 / 2
        right2 = x pos2 + w2 / 2
        top2 = y pos2 - h2 / 2
        bottom2 = y pos2 + h2 / 2
    in not (right1 < left2 || right2 < left1 || bottom1 < top2 || bottom2 < top1)

-- 圆形矩形碰撞检测
checkCircleRectangleCollision :: Vector2D -> Double -> Vector2D -> Double -> Double -> Bool
checkCircleRectangleCollision circlePos radius rectPos rectWidth rectHeight = 
    let closestX = max (x rectPos - rectWidth / 2) (min (x circlePos) (x rectPos + rectWidth / 2))
        closestY = max (y rectPos - rectHeight / 2) (min (y circlePos) (y rectPos + rectHeight / 2))
        closestPoint = Vector2D closestX closestY
    in distance circlePos closestPoint < radius

-- 解决碰撞
resolveCollisions :: [(EntityId, EntityId)] -> Map EntityId Entity -> Map EntityId Entity
resolveCollisions collisionPairs entities = 
    foldl resolveCollisionPair entities collisionPairs

-- 解决单个碰撞对
resolveCollisionPair :: Map EntityId Entity -> (EntityId, EntityId) -> Map EntityId Entity
resolveCollisionPair entities (id1, id2) = 
    case (Map.lookup id1 entities, Map.lookup id2 entities) of
        (Just e1, Just e2) -> 
            let (newE1, newE2) = resolveCollision e1 e2
            in Map.insert id1 newE1 (Map.insert id2 newE2 entities)
        _ -> entities

-- 解决两个实体的碰撞
resolveCollision :: Entity -> Entity -> (Entity, Entity)
resolveCollision e1 e2 = 
    let relativeVelocity = velocity e2 - velocity e1
        normal = normalize (position e2 - position e1)
        relativeSpeed = dotProduct relativeVelocity normal
        
        -- 弹性碰撞
        restitution = 0.8
        impulse = -(1 + restitution) * relativeSpeed / (1 / mass e1 + 1 / mass e2)
        
        newVelocity1 = velocity e1 - scalarMultiply (impulse / mass e1) normal
        newVelocity2 = velocity e2 + scalarMultiply (impulse / mass e2) normal
        
        -- 分离重叠
        overlap = 0.1
        separation = scalarMultiply overlap normal
        newPosition1 = position e1 - separation
        newPosition2 = position e2 + separation
    in (e1 { position = newPosition1, velocity = newVelocity1 }
       , e2 { position = newPosition2, velocity = newVelocity2 })
```

## 渲染系统

### 渲染组件

```haskell
-- 精灵
data Sprite = Sprite
    { texture :: Texture
    , sourceRect :: Rectangle
    , color :: Color
    } deriving Show

-- 纹理
data Texture = Texture
    { textureId :: Int
    , width :: Int
    , height :: Int
    } deriving Show

-- 矩形
data Rectangle = Rectangle
    { x :: Int
    , y :: Int
    , width :: Int
    , height :: Int
    } deriving Show

-- 颜色
data Color = Color
    { red :: Double
    , green :: Double
    , blue :: Double
    , alpha :: Double
    } deriving Show

-- 可渲染组件
data Renderable = Renderable
    { sprite :: Sprite
    , layer :: Int
    , visible :: Bool
    } deriving Show

-- 渲染器
data Renderer = Renderer
    { window :: Window
    , shaders :: Map String Shader
    , currentShader :: Maybe String
    } deriving Show

-- 窗口
data Window = Window
    { width :: Int
    , height :: Int
    , title :: String
    } deriving Show

-- 着色器
data Shader = Shader
    { programId :: Int
    , uniforms :: Map String UniformLocation
    } deriving Show

-- 统一变量位置
newtype UniformLocation = UniformLocation Int
    deriving Show

-- 渲染系统
renderSystem :: GameSystem
renderSystem state = 
    let renderableEntities = filter hasRenderable (Map.elems (entities state))
        sortedEntities = sortBy (comparing renderLayer) renderableEntities
    in foldl renderEntity state sortedEntities

-- 检查实体是否有渲染组件
hasRenderable :: Entity -> Bool
hasRenderable entity = isJust (renderable entity)

-- 获取渲染层
renderLayer :: Entity -> Int
renderLayer entity = 
    case renderable entity of
        Just r -> layer r
        Nothing -> 0

-- 渲染实体
renderEntity :: GameState -> Entity -> GameState
renderEntity state entity = 
    case renderable entity of
        Just r -> 
            if visible r
            then renderSprite (renderer state) (sprite r) (position entity) (rotation entity)
                 state
            else state
        Nothing -> state

-- 渲染精灵
renderSprite :: Renderer -> Sprite -> Vector2D -> Double -> GameState -> GameState
renderSprite renderer sprite position rotation state = 
    -- 这里应该调用实际的OpenGL渲染代码
    -- 简化实现
    state

-- 渲染文本
renderText :: Renderer -> String -> Vector2D -> Color -> GameState -> GameState
renderText renderer text position color state = 
    -- 文本渲染实现
    state

-- 渲染形状
renderShape :: Renderer -> Shape -> Vector2D -> Color -> GameState -> GameState
renderShape renderer shape position color state = 
    case shape of
        Circle radius -> renderCircle renderer radius position color state
        Rectangle width height -> renderRectangle renderer width height position color state
        Line start end -> renderLine renderer start end color state

-- 形状
data Shape = 
    Circle Double
    | Rectangle Double Double
    | Line Vector2D Vector2D
    deriving Show

-- 渲染圆形
renderCircle :: Renderer -> Double -> Vector2D -> Color -> GameState -> GameState
renderCircle renderer radius position color state = 
    -- 圆形渲染实现
    state

-- 渲染矩形
renderRectangle :: Renderer -> Double -> Double -> Vector2D -> Color -> GameState -> GameState
renderRectangle renderer width height position color state = 
    -- 矩形渲染实现
    state

-- 渲染线条
renderLine :: Renderer -> Vector2D -> Vector2D -> Color -> GameState -> GameState
renderLine renderer start end color state = 
    -- 线条渲染实现
    state
```

## 输入系统

### 输入处理

```haskell
-- 输入处理器
data InputHandler = InputHandler
    { keyHandlers :: Map Key (Entity -> Entity)
    , mouseHandlers :: Map MouseButton (Vector2D -> Entity -> Entity)
    } deriving Show

-- 输入系统
inputSystem :: GameSystem
inputSystem state = 
    let inputEntities = filter hasInputComponent (Map.elems (entities state))
        updatedEntities = map (processInput (input state)) inputEntities
        newEntities = Map.fromList [(id entity, entity) | entity <- updatedEntities]
    in state { entities = newEntities }

-- 检查实体是否有输入组件
hasInputComponent :: Entity -> Bool
hasInputComponent entity = 
    Map.member InputComponent (components entity)

-- 处理输入
processInput :: InputState -> Entity -> Entity
processInput inputState entity = 
    case Map.lookup InputComponent (components entity) of
        Just (InputComponentData handler) -> 
            foldl (applyKeyHandler inputState) entity (Map.toList (keyHandlers handler))
        _ -> entity

-- 应用按键处理器
applyKeyHandler :: InputState -> Entity -> (Key, Entity -> Entity) -> Entity
applyKeyHandler inputState entity (key, handler) = 
    if Set.member key (keys inputState)
    then handler entity
    else entity

-- 处理鼠标输入
processMouseInput :: InputState -> Entity -> Entity
processMouseInput inputState entity = 
    case Map.lookup InputComponent (components entity) of
        Just (InputComponentData handler) -> 
            foldl (applyMouseHandler inputState) entity (Map.toList (mouseHandlers handler))
        _ -> entity

-- 应用鼠标处理器
applyMouseHandler :: InputState -> Entity -> (MouseButton, Vector2D -> Entity -> Entity) -> Entity
applyMouseHandler inputState entity (button, handler) = 
    if Set.member button (mouseButtons inputState)
    then handler (mousePosition inputState) entity
    else entity

-- 创建玩家输入处理器
createPlayerInputHandler :: InputHandler
createPlayerInputHandler = InputHandler
    { keyHandlers = Map.fromList
        [ (KeyW, moveUp)
        , (KeyS, moveDown)
        , (KeyA, moveLeft)
        , (KeyD, moveRight)
        , (KeySpace, jump)
        ]
    , mouseHandlers = Map.fromList
        [ (MouseLeft, shoot)
        , (MouseRight, aim)
        ]
    }

-- 移动函数
moveUp :: Entity -> Entity
moveUp entity = entity { velocity = velocity entity + Vector2D 0 (-100) }

moveDown :: Entity -> Entity
moveDown entity = entity { velocity = velocity entity + Vector2D 0 100 }

moveLeft :: Entity -> Entity
moveLeft entity = entity { velocity = velocity entity + Vector2D (-100) 0 }

moveRight :: Entity -> Entity
moveRight entity = entity { velocity = velocity entity + Vector2D 100 0 }

jump :: Entity -> Entity
jump entity = entity { velocity = velocity entity + Vector2D 0 (-200) }

shoot :: Vector2D -> Entity -> Entity
shoot mousePos entity = 
    let direction = normalize (mousePos - position entity)
        bulletVelocity = scalarMultiply 300 direction
    in entity { velocity = velocity entity + bulletVelocity }

aim :: Vector2D -> Entity -> Entity
aim mousePos entity = 
    let direction = mousePos - position entity
        angle = atan2 (y direction) (x direction)
    in entity { rotation = angle }
```

## AI系统

### AI组件

```haskell
-- AI状态
data AIState = AIState
    { behavior :: AIBehavior
    , target :: Maybe EntityId
    , path :: [Vector2D]
    , stateMachine :: AIStateMachine
    } deriving Show

-- AI行为
data AIBehavior = 
    Idle
    | Patrol [Vector2D]
    | Chase EntityId
    | Attack EntityId
    | Flee Vector2D
    deriving Show

-- AI状态机
data AIStateMachine = AIStateMachine
    { currentState :: AIStateType
    , transitions :: Map AIStateType [AITransition]
    } deriving Show

-- AI状态类型
data AIStateType = 
    AIIdle | AIPatrol | AIChase | AIAttack | AIFlee
    deriving (Show, Eq, Ord)

-- AI转换
data AITransition = AITransition
    { condition :: AICondition
    , targetState :: AIStateType
    } deriving Show

-- AI条件
data AICondition = 
    PlayerInSight Double
    | PlayerInRange Double
    | HealthLow Double
    | NoTarget
    deriving Show

-- AI系统
aiSystem :: GameSystem
aiSystem state = 
    let aiEntities = filter hasAIComponent (Map.elems (entities state))
        updatedEntities = map (updateAI state) aiEntities
        newEntities = Map.fromList [(id entity, entity) | entity <- updatedEntities]
    in state { entities = newEntities }

-- 检查实体是否有AI组件
hasAIComponent :: Entity -> Bool
hasAIComponent entity = 
    Map.member AIComponent (components entity)

-- 更新AI
updateAI :: GameState -> Entity -> Entity
updateAI state entity = 
    case Map.lookup AIComponent (components entity) of
        Just (AIComponentData aiState) -> 
            let updatedAIState = updateAIState state entity aiState
                newComponents = Map.insert AIComponent (AIComponentData updatedAIState) (components entity)
            in entity { components = newComponents }
        _ -> entity

-- 更新AI状态
updateAIState :: GameState -> Entity -> AIState -> AIState
updateAIState state entity aiState = 
    let newBehavior = updateBehavior state entity (behavior aiState)
        newStateMachine = updateStateMachine state entity (stateMachine aiState)
    in aiState { behavior = newBehavior
               , stateMachine = newStateMachine }

-- 更新行为
updateBehavior :: GameState -> Entity -> AIBehavior -> AIBehavior
updateBehavior state entity behavior = 
    case behavior of
        Idle -> updateIdleBehavior state entity
        Patrol waypoints -> updatePatrolBehavior state entity waypoints
        Chase targetId -> updateChaseBehavior state entity targetId
        Attack targetId -> updateAttackBehavior state entity targetId
        Flee targetPos -> updateFleeBehavior state entity targetPos

-- 更新空闲行为
updateIdleBehavior :: GameState -> Entity -> AIBehavior
updateIdleBehavior state entity = 
    -- 检查是否有玩家进入视野
    let players = findPlayersInRange state entity 100
    in if null players
       then Idle
       else Chase (id (head players))

-- 更新巡逻行为
updatePatrolBehavior :: GameState -> Entity -> [Vector2D] -> AIBehavior
updatePatrolBehavior state entity waypoints = 
    if null waypoints
    then Idle
    else 
        let target = head waypoints
            distance = distance (position entity) target
        in if distance < 10
           then Patrol (tail waypoints ++ [head waypoints])
           else Patrol waypoints

-- 更新追击行为
updateChaseBehavior :: GameState -> Entity -> EntityId -> AIBehavior
updateChaseBehavior state entity targetId = 
    case Map.lookup targetId (entities state) of
        Just target -> 
            let direction = normalize (position target - position entity)
                newVelocity = scalarMultiply 50 direction
            in Chase targetId
        Nothing -> Idle

-- 更新攻击行为
updateAttackBehavior :: GameState -> Entity -> EntityId -> AIBehavior
updateAttackBehavior state entity targetId = 
    case Map.lookup targetId (entities state) of
        Just target -> 
            let distance = distance (position entity) (position target)
            in if distance < 20
               then Attack targetId
               else Chase targetId
        Nothing -> Idle

-- 更新逃跑行为
updateFleeBehavior :: GameState -> Entity -> Vector2D -> AIBehavior
updateFleeBehavior state entity targetPos = 
    let direction = normalize (position entity - targetPos)
        newVelocity = scalarMultiply 80 direction
    in Flee targetPos

-- 更新状态机
updateStateMachine :: GameState -> Entity -> AIStateMachine -> AIStateMachine
updateStateMachine state entity stateMachine = 
    let transitions = Map.findWithDefault [] (currentState stateMachine) (transitions stateMachine)
        validTransition = findValidTransition state entity transitions
    in case validTransition of
        Just transition -> stateMachine { currentState = targetState transition }
        Nothing -> stateMachine

-- 查找有效转换
findValidTransition :: GameState -> Entity -> [AITransition] -> Maybe AITransition
findValidTransition state entity transitions = 
    find (\transition -> checkAICondition state entity (condition transition)) transitions

-- 检查AI条件
checkAICondition :: GameState -> Entity -> AICondition -> Bool
checkAICondition state entity condition = 
    case condition of
        PlayerInSight range -> 
            let players = findPlayersInRange state entity range
            in not (null players)
        PlayerInRange range -> 
            let players = findPlayersInRange state entity range
            in not (null players)
        HealthLow threshold -> 
            case Map.lookup HealthComponent (components entity) of
                Just (HealthComponentData current max) -> current / max < threshold
                _ -> False
        NoTarget -> True

-- 查找范围内的玩家
findPlayersInRange :: GameState -> Entity -> Double -> [Entity]
findPlayersInRange state entity range = 
    let allEntities = Map.elems (entities state)
        players = filter (\e -> id e /= id entity && isPlayer e) allEntities
        inRange = filter (\e -> distance (position entity) (position e) < range) players
    in inRange

-- 检查是否为玩家
isPlayer :: Entity -> Bool
isPlayer entity = 
    Map.member InputComponent (components entity)
```

## 实际应用示例

### 2D平台游戏

```haskell
-- 平台游戏状态
data PlatformGameState = PlatformGameState
    { gameState :: GameState
    , player :: EntityId
    , platforms :: [EntityId]
    , enemies :: [EntityId]
    , collectibles :: [EntityId]
    , score :: Int
    , level :: Int
    } deriving Show

-- 创建平台游戏
createPlatformGame :: IO PlatformGameState
createPlatformGame = do
    let player = createPlayer
        platforms = createPlatforms
        enemies = createEnemies
        collectibles = createCollectibles
        gameState = createGameState player platforms enemies collectibles
    return $ PlatformGameState gameState (id player) (map id platforms) (map id enemies) (map id collectibles) 0 1

-- 创建玩家
createPlayer :: Entity
createPlayer = Entity
    { id = EntityId 1
    , position = Vector2D 100 100
    , velocity = Vector2D 0 0
    , acceleration = Vector2D 0 0
    , rotation = 0
    , angularVelocity = 0
    , mass = 1.0
    , collider = Just (RectangleCollider 32 32)
    , renderable = Just (Renderable (createPlayerSprite) 1 True)
    , components = Map.fromList
        [ (InputComponent, InputComponentData createPlayerInputHandler)
        , (HealthComponent, HealthComponentData 100 100)
        ]
    }

-- 创建玩家精灵
createPlayerSprite :: Sprite
createPlayerSprite = Sprite
    { texture = Texture 1 32 32
    , sourceRect = Rectangle 0 0 32 32
    , color = Color 1 1 1 1
    }

-- 创建平台
createPlatforms :: [Entity]
createPlatforms = 
    [ Entity (EntityId 2) (Vector2D 200 300) (Vector2D 0 0) (Vector2D 0 0) 0 0 0 
        (Just (RectangleCollider 200 20)) 
        (Just (Renderable (createPlatformSprite) 0 True)) 
        Map.empty
    , Entity (EntityId 3) (Vector2D 500 400) (Vector2D 0 0) (Vector2D 0 0) 0 0 0 
        (Just (RectangleCollider 200 20)) 
        (Just (Renderable (createPlatformSprite) 0 True)) 
        Map.empty
    ]

-- 创建平台精灵
createPlatformSprite :: Sprite
createPlatformSprite = Sprite
    { texture = Texture 2 200 20
    , sourceRect = Rectangle 0 0 200 20
    , color = Color 0.5 0.5 0.5 1
    }

-- 创建敌人
createEnemies :: [Entity]
createEnemies = 
    [ Entity (EntityId 4) (Vector2D 300 250) (Vector2D 0 0) (Vector2D 0 0) 0 0 1.0 
        (Just (CircleCollider 16)) 
        (Just (Renderable (createEnemySprite) 1 True)) 
        (Map.singleton AIComponent (AIComponentData (createEnemyAI)))
    ]

-- 创建敌人精灵
createEnemySprite :: Sprite
createEnemySprite = Sprite
    { texture = Texture 3 32 32
    , sourceRect = Rectangle 0 0 32 32
    , color = Color 1 0 0 1
    }

-- 创建敌人AI
createEnemyAI :: AIState
createEnemyAI = AIState
    { behavior = Patrol [Vector2D 250 250, Vector2D 350 250]
    , target = Nothing
    , path = []
    , stateMachine = AIStateMachine AIIdle Map.empty
    }

-- 创建收集品
createCollectibles :: [Entity]
createCollectibles = 
    [ Entity (EntityId 5) (Vector2D 250 250) (Vector2D 0 0) (Vector2D 0 0) 0 0 0 
        (Just (CircleCollider 8)) 
        (Just (Renderable (createCollectibleSprite) 1 True)) 
        Map.empty
    ]

-- 创建收集品精灵
createCollectibleSprite :: Sprite
createCollectibleSprite = Sprite
    { texture = Texture 4 16 16
    , sourceRect = Rectangle 0 0 16 16
    , color = Color 1 1 0 1
    }

-- 创建游戏状态
createGameState :: Entity -> [Entity] -> [Entity] -> [Entity] -> GameState
createGameState player platforms enemies collectibles = 
    let allEntities = [player] ++ platforms ++ enemies ++ collectibles
        entityMap = Map.fromList [(id entity, entity) | entity <- allEntities]
        systems = [physicsSystem, inputSystem, aiSystem, renderSystem]
    in GameState
        { entities = entityMap
        , systems = systems
        , time = Time 0.016 0
        , input = InputState Set.empty (Vector2D 0 0) Set.empty
        , renderer = createRenderer
        , physics = PhysicsEngine (Vector2D 0 500) 0.98 []
        }

-- 创建渲染器
createRenderer :: Renderer
createRenderer = Renderer
    { window = Window 800 600 "Platform Game"
    , shaders = Map.empty
    , currentShader = Nothing
    }

-- 平台游戏主循环
platformGameLoop :: PlatformGameState -> IO PlatformGameState
platformGameLoop gameState = do
    -- 更新游戏状态
    let updatedGameState = updatePlatformGame gameState
    
    -- 检查游戏结束条件
    if gameOver updatedGameState
        then return updatedGameState
        else platformGameLoop updatedGameState

-- 更新平台游戏
updatePlatformGame :: PlatformGameState -> PlatformGameState
updatePlatformGame gameState = 
    let updatedGameState = gameState { gameState = updateGameState (gameState gameState) }
        newScore = calculateScore updatedGameState
        newLevel = calculateLevel updatedGameState
    in updatedGameState { score = newScore, level = newLevel }

-- 计算分数
calculateScore :: PlatformGameState -> Int
calculateScore gameState = 
    let entities = entities (gameState gameState)
        collectibles = [e | e <- Map.elems entities, id e `elem` collectibles gameState]
        collected = length $ filter (not . isVisible) collectibles
    in score gameState + collected * 10

-- 检查是否可见
isVisible :: Entity -> Bool
isVisible entity = 
    case renderable entity of
        Just r -> visible r
        Nothing -> False

-- 计算等级
calculateLevel :: PlatformGameState -> Int
calculateLevel gameState = 
    (score gameState `div` 100) + 1

-- 检查游戏结束
gameOver :: PlatformGameState -> Bool
gameOver gameState = 
    let entities = entities (gameState gameState)
        playerEntity = Map.lookup (player gameState) entities
    in case playerEntity of
        Just player -> 
            case Map.lookup HealthComponent (components player) of
                Just (HealthComponentData current _) -> current <= 0
                _ -> False
        Nothing -> True
```

## 总结

本文档展示了Haskell中游戏开发的完整实现，包括：

1. **游戏引擎架构**：基本框架、实体组件系统、游戏循环
2. **物理引擎**：碰撞检测、物理模拟、碰撞解决
3. **渲染系统**：精灵渲染、形状渲染、文本渲染
4. **输入系统**：键盘输入、鼠标输入、输入处理器
5. **AI系统**：AI行为、状态机、路径寻找
6. **实际应用**：2D平台游戏完整实现

这些技术展示了Haskell在游戏开发中的优势：

- **类型安全**：编译时保证游戏逻辑正确性
- **函数式风格**：清晰的游戏架构
- **不可变性**：避免副作用，便于并行化
- **高阶函数**：抽象游戏模式
- **模式匹配**：优雅的实体处理

通过这些实现，我们可以看到Haskell不仅适合理论研究，也适合实际的游戏开发。
