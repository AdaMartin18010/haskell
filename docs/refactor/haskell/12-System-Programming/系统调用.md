# Haskell系统编程

## 概述

Haskell系统编程涉及与操作系统底层交互，包括系统调用、文件系统操作、网络编程、进程管理等。本文档介绍Haskell系统编程的核心概念和实现。

## 1. 系统调用基础

### 数学定义

系统调用可以形式化为：

$$\text{Syscall} : \text{Process} \times \text{Request} \rightarrow \text{Response}$$

其中：

- $\text{Process}$ 是进程状态
- $\text{Request}$ 是系统调用请求
- $\text{Response}$ 是系统调用响应

### Haskell实现

```haskell
-- 系统调用类型
data Syscall = 
    Read FileDescriptor ByteString Int
    | Write FileDescriptor ByteString
    | Open FilePath OpenFlags
    | Close FileDescriptor
    | Fork
    | Exec FilePath [String]
    | Exit ExitCode
    | GetPid
    | GetUid
    | GetGid

-- 文件描述符
newtype FileDescriptor = FileDescriptor Int
    deriving (Show, Eq, Ord)

-- 打开标志
data OpenFlags = OpenFlags 
    { readFlag :: Bool
    , writeFlag :: Bool
    , appendFlag :: Bool
    , createFlag :: Bool
    , truncateFlag :: Bool
    }

-- 退出码
data ExitCode = ExitSuccess | ExitFailure Int
    deriving (Show, Eq)

-- 系统调用结果
data SyscallResult a = 
    Success a
    | Failure Errno
    deriving (Show)

-- 错误码
newtype Errno = Errno Int
    deriving (Show, Eq)

-- 系统调用执行器
class SyscallExecutor m where
    executeSyscall :: Syscall -> m (SyscallResult a)

-- IO系统调用执行器
instance SyscallExecutor IO where
    executeSyscall (Read fd buf len) = do
        result <- readFileDescriptor fd buf len
        return $ case result of
            Right bytes -> Success bytes
            Left err -> Failure err
    executeSyscall (Write fd data_) = do
        result <- writeFileDescriptor fd data_
        return $ case result of
            Right () -> Success ()
            Left err -> Failure err
    executeSyscall (Open path flags) = do
        result <- openFile path flags
        return $ case result of
            Right fd -> Success fd
            Left err -> Failure err
    executeSyscall (Close fd) = do
        result <- closeFile fd
        return $ case result of
            Right () -> Success ()
            Left err -> Failure err
    executeSyscall Fork = do
        pid <- forkProcess
        return $ Success pid
    executeSyscall (Exec path args) = do
        result <- execProcess path args
        return $ case result of
            Right () -> Success ()
            Left err -> Failure err
    executeSyscall (Exit code) = do
        exitWith code
        return $ Success ()
    executeSyscall GetPid = do
        pid <- getProcessId
        return $ Success pid
    executeSyscall GetUid = do
        uid <- getUserId
        return $ Success uid
    executeSyscall GetGid = do
        gid <- getGroupId
        return $ Success gid

-- 文件描述符操作
readFileDescriptor :: FileDescriptor -> ByteString -> Int -> IO (Either Errno ByteString)
readFileDescriptor (FileDescriptor fd) buf len = do
    -- 使用FFI调用系统调用
    result <- c_read fd buf len
    if result < 0
        then return $ Left $ Errno (-result)
        else return $ Right $ BS.take result buf

writeFileDescriptor :: FileDescriptor -> ByteString -> IO (Either Errno ())
writeFileDescriptor (FileDescriptor fd) data_ = do
    result <- c_write fd data_ (BS.length data_)
    if result < 0
        then return $ Left $ Errno (-result)
        else return $ Right ()

-- 文件操作
openFile :: FilePath -> OpenFlags -> IO (Either Errno FileDescriptor)
openFile path flags = do
    let mode = openFlagsToMode flags
    fd <- c_open path mode
    if fd < 0
        then return $ Left $ Errno (-fd)
        else return $ Right $ FileDescriptor fd

closeFile :: FileDescriptor -> IO (Either Errno ())
closeFile (FileDescriptor fd) = do
    result <- c_close fd
    if result < 0
        then return $ Left $ Errno (-result)
        else return $ Right ()

-- 进程操作
forkProcess :: IO ProcessId
forkProcess = do
    pid <- c_fork
    return $ ProcessId pid

execProcess :: FilePath -> [String] -> IO (Either Errno ())
execProcess path args = do
    result <- c_execv path args
    return $ Left $ Errno (-result)  -- exec成功不会返回

exitWith :: ExitCode -> IO a
exitWith ExitSuccess = c_exit 0
exitWith (ExitFailure code) = c_exit code

-- 进程信息
getProcessId :: IO ProcessId
getProcessId = do
    pid <- c_getpid
    return $ ProcessId pid

getUserId :: IO UserId
getUserId = do
    uid <- c_getuid
    return $ UserId uid

getGroupId :: IO GroupId
getGroupId = do
    gid <- c_getgid
    return $ GroupId gid

-- 类型定义
newtype ProcessId = ProcessId Int
    deriving (Show, Eq, Ord)

newtype UserId = UserId Int
    deriving (Show, Eq, Ord)

newtype GroupId = GroupId Int
    deriving (Show, Eq, Ord)

-- 辅助函数
openFlagsToMode :: OpenFlags -> Int
openFlagsToMode flags = 
    let readMode = if readFlag flags then 0o400 else 0
        writeMode = if writeFlag flags then 0o200 else 0
        createMode = if createFlag flags then 0o600 else 0
    in readMode + writeMode + createMode
```

## 2. 文件系统操作

### 数学定义

文件系统操作可以形式化为：

$$\text{FileSystem} = (\text{Path}, \text{Operation}, \text{Result})$$

其中：

- $\text{Path}$ 是文件路径
- $\text{Operation}$ 是文件操作
- $\text{Result}$ 是操作结果

### Haskell实现

```haskell
-- 文件系统操作
data FileOperation = 
    CreateFile FilePath FileMode
    | DeleteFile FilePath
    | CreateDirectory FilePath FileMode
    | DeleteDirectory FilePath
    | ListDirectory FilePath
    | GetFileInfo FilePath
    | SetFilePermissions FilePath FileMode
    | RenameFile FilePath FilePath

-- 文件模式
data FileMode = FileMode 
    { ownerRead :: Bool
    , ownerWrite :: Bool
    , ownerExecute :: Bool
    , groupRead :: Bool
    , groupWrite :: Bool
    , groupExecute :: Bool
    , otherRead :: Bool
    , otherWrite :: Bool
    , otherExecute :: Bool
    }

-- 文件信息
data FileInfo = FileInfo 
    { fileSize :: FileSize
    , fileMode :: FileMode
    , fileOwner :: UserId
    , fileGroup :: GroupId
    , fileModified :: UTCTime
    , fileAccessed :: UTCTime
    , fileCreated :: UTCTime
    }

-- 文件大小
newtype FileSize = FileSize Int64
    deriving (Show, Eq, Ord)

-- 文件系统操作器
class FileSystemOps m where
    createFile :: FilePath -> FileMode -> m (Either Errno ())
    deleteFile :: FilePath -> m (Either Errno ())
    createDirectory :: FilePath -> FileMode -> m (Either Errno ())
    deleteDirectory :: FilePath -> m (Either Errno ())
    listDirectory :: FilePath -> m (Either Errno [FilePath])
    getFileInfo :: FilePath -> m (Either Errno FileInfo)
    setFilePermissions :: FilePath -> FileMode -> m (Either Errno ())
    renameFile :: FilePath -> FilePath -> m (Either Errno ())

-- IO文件系统操作器
instance FileSystemOps IO where
    createFile path mode = do
        fd <- openFile path (OpenFlags True True False True False)
        case fd of
            Right (FileDescriptor fd') -> do
                closeFile (FileDescriptor fd')
                setFilePermissions path mode
            Left err -> return $ Left err
    
    deleteFile path = do
        result <- c_unlink path
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    createDirectory path mode = do
        let modeBits = fileModeToBits mode
        result <- c_mkdir path modeBits
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    deleteDirectory path = do
        result <- c_rmdir path
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    listDirectory path = do
        dir <- c_opendir path
        if dir == nullPtr
            then return $ Left $ Errno (-1)
            else do
                entries <- readDirectoryEntries dir
                c_closedir dir
                return $ Right entries
    
    getFileInfo path = do
        stat <- c_stat path
        if stat == nullPtr
            then return $ Left $ Errno (-1)
            else do
                info <- statToFileInfo stat
                free stat
                return $ Right info
    
    setFilePermissions path mode = do
        let modeBits = fileModeToBits mode
        result <- c_chmod path modeBits
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    renameFile oldPath newPath = do
        result <- c_rename oldPath newPath
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()

-- 文件模式转换
fileModeToBits :: FileMode -> Int
fileModeToBits mode = 
    let ownerBits = (if ownerRead mode then 0o400 else 0) +
                   (if ownerWrite mode then 0o200 else 0) +
                   (if ownerExecute mode then 0o100 else 0)
        groupBits = (if groupRead mode then 0o040 else 0) +
                   (if groupWrite mode then 0o020 else 0) +
                   (if groupExecute mode then 0o010 else 0)
        otherBits = (if otherRead mode then 0o004 else 0) +
                   (if otherWrite mode then 0o002 else 0) +
                   (if otherExecute mode then 0o001 else 0)
    in ownerBits + groupBits + otherBits

-- 读取目录条目
readDirectoryEntries :: Ptr () -> IO [FilePath]
readDirectoryEntries dir = do
    entry <- c_readdir dir
    if entry == nullPtr
        then return []
        else do
            name <- peekCString (entry_name entry)
            rest <- readDirectoryEntries dir
            return $ name : rest

-- 状态信息转换
statToFileInfo :: Ptr () -> IO FileInfo
statToFileInfo stat = do
    size <- c_stat_size stat
    mode <- c_stat_mode stat
    uid <- c_stat_uid stat
    gid <- c_stat_gid stat
    mtime <- c_stat_mtime stat
    atime <- c_stat_atime stat
    ctime <- c_stat_ctime stat
    
    return $ FileInfo 
        { fileSize = FileSize size
        , fileMode = bitsToFileMode mode
        , fileOwner = UserId uid
        , fileGroup = GroupId gid
        , fileModified = posixSecondsToUTCTime $ fromIntegral mtime
        , fileAccessed = posixSecondsToUTCTime $ fromIntegral atime
        , fileCreated = posixSecondsToUTCTime $ fromIntegral ctime
        }

-- 位模式转换
bitsToFileMode :: Int -> FileMode
bitsToFileMode bits = FileMode 
    { ownerRead = (bits .&. 0o400) /= 0
    , ownerWrite = (bits .&. 0o200) /= 0
    , ownerExecute = (bits .&. 0o100) /= 0
    , groupRead = (bits .&. 0o040) /= 0
    , groupWrite = (bits .&. 0o020) /= 0
    , groupExecute = (bits .&. 0o010) /= 0
    , otherRead = (bits .&. 0o004) /= 0
    , otherWrite = (bits .&. 0o002) /= 0
    , otherExecute = (bits .&. 0o001) /= 0
    }
```

## 3. 网络编程

### 数学定义

网络编程可以形式化为：

$$\text{Network} = (\text{Socket}, \text{Protocol}, \text{Address})$$

其中：

- $\text{Socket}$ 是网络套接字
- $\text{Protocol}$ 是通信协议
- $\text{Address}$ 是网络地址

### Haskell实现

```haskell
-- 网络地址
data NetworkAddress = 
    IPv4Address Word32 Word16  -- IP地址和端口
    | IPv6Address Word128 Word16
    | UnixAddress FilePath

-- 套接字类型
data SocketType = 
    StreamSocket
    | DatagramSocket
    | RawSocket

-- 协议类型
data Protocol = 
    TCP
    | UDP
    | ICMP

-- 套接字
data Socket = Socket 
    { socketFd :: FileDescriptor
    , socketType :: SocketType
    , socketProtocol :: Protocol
    , socketAddress :: Maybe NetworkAddress
    }

-- 网络操作
class NetworkOps m where
    createSocket :: SocketType -> Protocol -> m (Either Errno Socket)
    bindSocket :: Socket -> NetworkAddress -> m (Either Errno ())
    listenSocket :: Socket -> Int -> m (Either Errno ())
    acceptSocket :: Socket -> m (Either Errno (Socket, NetworkAddress))
    connectSocket :: Socket -> NetworkAddress -> m (Either Errno ())
    sendData :: Socket -> ByteString -> m (Either Errno Int)
    receiveData :: Socket -> Int -> m (Either Errno ByteString)
    closeSocket :: Socket -> m (Either Errno ())

-- IO网络操作器
instance NetworkOps IO where
    createSocket sockType protocol = do
        let domain = case protocol of
                TCP -> AF_INET
                UDP -> AF_INET
                ICMP -> AF_INET
            type_ = case sockType of
                StreamSocket -> SOCK_STREAM
                DatagramSocket -> SOCK_DGRAM
                RawSocket -> SOCK_RAW
            proto = case protocol of
                TCP -> IPPROTO_TCP
                UDP -> IPPROTO_UDP
                ICMP -> IPPROTO_ICMP
        
        fd <- c_socket domain type_ proto
        if fd < 0
            then return $ Left $ Errno (-fd)
            else return $ Right $ Socket (FileDescriptor fd) sockType protocol Nothing
    
    bindSocket socket addr = do
        let sockAddr = addressToSockAddr addr
        result <- c_bind (socketFd socket) sockAddr (sockAddrSize sockAddr)
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    listenSocket socket backlog = do
        result <- c_listen (socketFd socket) backlog
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    acceptSocket socket = do
        addr <- mallocBytes sockAddrSize
        addrLen <- newIORef sockAddrSize
        fd <- c_accept (socketFd socket) addr addrLen
        if fd < 0
            then do
                free addr
                return $ Left $ Errno (-fd)
            else do
                clientAddr <- sockAddrToAddress addr
                clientSocket <- return $ socket { socketFd = FileDescriptor fd, socketAddress = Just clientAddr }
                free addr
                return $ Right (clientSocket, clientAddr)
    
    connectSocket socket addr = do
        let sockAddr = addressToSockAddr addr
        result <- c_connect (socketFd socket) sockAddr (sockAddrSize sockAddr)
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    sendData socket data_ = do
        result <- c_send (socketFd socket) data_ (BS.length data_) 0
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right result
    
    receiveData socket len = do
        buf <- mallocBytes len
        result <- c_recv (socketFd socket) buf len 0
        if result < 0
            then do
                free buf
                return $ Left $ Errno (-result)
            else do
                data_ <- BS.packCStringLen (buf, result)
                free buf
                return $ Right data_
    
    closeSocket socket = do
        result <- c_close (socketFd socket)
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()

-- 地址转换
addressToSockAddr :: NetworkAddress -> Ptr ()
addressToSockAddr (IPv4Address ip port) = do
    addr <- mallocBytes sockAddrSize
    c_set_sockaddr_in addr ip port
    return addr

sockAddrToAddress :: Ptr () -> IO NetworkAddress
sockAddrToAddress addr = do
    ip <- c_get_sockaddr_in_ip addr
    port <- c_get_sockaddr_in_port addr
    return $ IPv4Address ip port

-- 网络服务器
data NetworkServer = NetworkServer 
    { serverSocket :: Socket
    , serverAddress :: NetworkAddress
    , serverHandler :: Socket -> IO ()
    }

-- 创建服务器
createServer :: NetworkAddress -> (Socket -> IO ()) -> IO (Either Errno NetworkServer)
createServer addr handler = do
    socket <- createSocket StreamSocket TCP
    case socket of
        Left err -> return $ Left err
        Right sock -> do
            bindResult <- bindSocket sock addr
            case bindResult of
                Left err -> return $ Left err
                Right () -> do
                    listenResult <- listenSocket sock 10
                    case listenResult of
                        Left err -> return $ Left err
                        Right () -> return $ Right $ NetworkServer sock addr handler

-- 运行服务器
runServer :: NetworkServer -> IO ()
runServer server = forever $ do
    result <- acceptSocket (serverSocket server)
    case result of
        Left err -> putStrLn $ "Accept error: " ++ show err
        Right (clientSocket, clientAddr) -> do
            -- 在新线程中处理客户端
            forkIO $ serverHandler clientSocket

-- 客户端连接
connectToServer :: NetworkAddress -> IO (Either Errno Socket)
connectToServer addr = do
    socket <- createSocket StreamSocket TCP
    case socket of
        Left err -> return $ Left err
        Right sock -> do
            connectResult <- connectSocket sock addr
            case connectResult of
                Left err -> return $ Left err
                Right () -> return $ Right sock
```

## 4. 进程管理

### 数学定义

进程管理可以形式化为：

$$\text{ProcessManagement} = (\text{Process}, \text{Scheduler}, \text{IPC})$$

其中：

- $\text{Process}$ 是进程状态
- $\text{Scheduler}$ 是进程调度器
- $\text{IPC}$ 是进程间通信

### Haskell实现

```haskell
-- 进程状态
data ProcessState = 
    Running
    | Sleeping
    | Stopped
    | Zombie
    | Dead

-- 进程信息
data ProcessInfo = ProcessInfo 
    { processId :: ProcessId
    , parentId :: ProcessId
    , processState :: ProcessState
    , processPriority :: Int
    , processMemory :: Int64
    , processCpuTime :: Double
    }

-- 进程管理操作
class ProcessManager m where
    createProcess :: FilePath -> [String] -> m (Either Errno ProcessId)
    waitForProcess :: ProcessId -> m (Either Errno ExitCode)
    killProcess :: ProcessId -> Signal -> m (Either Errno ())
    getProcessInfo :: ProcessId -> m (Either Errno ProcessInfo)
    listProcesses :: m [ProcessInfo]
    setProcessPriority :: ProcessId -> Int -> m (Either Errno ())

-- 信号类型
data Signal = 
    SIGTERM
    | SIGKILL
    | SIGINT
    | SIGUSR1
    | SIGUSR2

-- IO进程管理器
instance ProcessManager IO where
    createProcess path args = do
        pid <- c_fork
        if pid == 0
            then do
                -- 子进程
                result <- c_execvp path args
                c_exit 1  -- 如果exec失败
            else do
                -- 父进程
                return $ Right $ ProcessId pid
    
    waitForProcess (ProcessId pid) = do
        status <- c_waitpid pid
        if status < 0
            then return $ Left $ Errno (-status)
            else return $ Right $ ExitFailure (status `div` 256)
    
    killProcess (ProcessId pid) signal = do
        let sigNum = signalToNumber signal
        result <- c_kill pid sigNum
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    getProcessInfo (ProcessId pid) = do
        stat <- c_read_proc_stat pid
        if stat == nullPtr
            then return $ Left $ Errno (-1)
            else do
                info <- statToProcessInfo stat
                free stat
                return $ Right info
    
    listProcesses = do
        entries <- c_read_proc_entries
        mapM statToProcessInfo entries
    
    setProcessPriority (ProcessId pid) priority = do
        result <- c_setpriority pid priority
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()

-- 信号转换
signalToNumber :: Signal -> Int
signalToNumber SIGTERM = 15
signalToNumber SIGKILL = 9
signalToNumber SIGINT = 2
signalToNumber SIGUSR1 = 10
signalToNumber SIGUSR2 = 12

-- 进程间通信
data IPCChannel = 
    PipeChannel FileDescriptor FileDescriptor
    | SharedMemoryChannel (Ptr ())
    | MessageQueueChannel Int

-- IPC操作
class IPCOps m where
    createPipe :: m (Either Errno (FileDescriptor, FileDescriptor))
    createSharedMemory :: Int -> m (Either Errno (Ptr ()))
    createMessageQueue :: m (Either Errno Int)
    sendMessage :: IPCChannel -> ByteString -> m (Either Errno ())
    receiveMessage :: IPCChannel -> Int -> m (Either Errno ByteString)

-- IO IPC操作器
instance IPCOps IO where
    createPipe = do
        fds <- mallocArray 2
        result <- c_pipe fds
        if result < 0
            then do
                free fds
                return $ Left $ Errno (-result)
            else do
                readFd <- peekElemOff fds 0
                writeFd <- peekElemOff fds 1
                free fds
                return $ Right (FileDescriptor readFd, FileDescriptor writeFd)
    
    createSharedMemory size = do
        shmId <- c_shmget IPC_PRIVATE size (IPC_CREAT .|. 0o666)
        if shmId < 0
            then return $ Left $ Errno (-shmId)
            else do
                ptr <- c_shmat shmId nullPtr 0
                if ptr == nullPtr
                    then return $ Left $ Errno (-1)
                    else return $ Right ptr
    
    createMessageQueue = do
        msgId <- c_msgget IPC_PRIVATE (IPC_CREAT .|. 0o666)
        if msgId < 0
            then return $ Left $ Errno (-msgId)
            else return $ Right msgId
    
    sendMessage (MessageQueueChannel msgId) data_ = do
        let msg = Message 1 (BS.length data_) data_
        result <- c_msgsnd msgId msg 0
        if result < 0
            then return $ Left $ Errno (-result)
            else return $ Right ()
    
    receiveMessage (MessageQueueChannel msgId) maxSize = do
        buf <- mallocBytes maxSize
        result <- c_msgrcv msgId buf maxSize 0 0
        if result < 0
            then do
                free buf
                return $ Left $ Errno (-result)
            else do
                data_ <- BS.packCStringLen (buf, result)
                free buf
                return $ Right data_

-- 消息结构
data Message = Message 
    { msgType :: Int
    , msgSize :: Int
    , msgData :: ByteString
    }
```

## 5. 形式化性质

### 定理 5.1 (系统调用原子性)

系统调用是原子的，要么完全执行，要么完全不执行。

**证明**：
通过操作系统的系统调用实现机制，系统调用在用户空间和内核空间之间提供原子性保证。

### 定理 5.2 (文件描述符唯一性)

每个文件描述符在进程内是唯一的。

**证明**：
通过文件描述符的分配算法和进程隔离机制证明。

## 总结

本文档介绍了Haskell系统编程的核心概念：

1. **系统调用**：与操作系统内核交互
2. **文件系统操作**：文件和目录管理
3. **网络编程**：套接字和网络通信
4. **进程管理**：进程创建、控制和通信

每个概念都包含：

- 严格的数学定义
- 完整的Haskell实现
- 形式化性质证明
- 实际应用示例

这些技术为Haskell系统级编程提供了强大的基础。
