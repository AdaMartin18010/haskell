# 内存优化

## 概述

Haskell的内存优化基于惰性求值、垃圾回收和函数式编程的特性。理解Haskell的内存模型对于编写高性能程序至关重要。

## 数学基础

### 内存复杂度

内存使用可以建模为：

$$\text{Memory}(f) = \text{Space}(f) + \text{Allocation}(f) + \text{Garbage}(f)$$

其中：
- $\text{Space}(f)$：函数执行时的空间复杂度
- $\text{Allocation}(f)$：内存分配量
- $\text{Garbage}(f)$：垃圾回收开销

### 空间复杂度分析

对于函数 $f$，其空间复杂度为：

$$\text{Space}(f) = \max_{x \in \text{Input}} \text{MemoryUsage}(f(x))$$

## 1. 惰性求值优化

### 数学定义

惰性求值避免不必要的计算：

$$\text{Lazy}(f) = \text{Thunk}(f) \text{ until } \text{Demand}$$

### Haskell实现

```haskell
-- 惰性求值示例
lazyEvaluationExample :: IO ()
lazyEvaluationExample = do
    putStrLn "=== Lazy Evaluation Examples ==="
    
    -- 惰性列表构造
    let infiniteList = [1..]
    putStrLn "Infinite list created (lazily)"
    
    -- 只取前几个元素
    let firstFive = take 5 infiniteList
    putStrLn $ "First five: " ++ show firstFive
    
    -- 惰性计算
    let expensiveComputation = sum [1..1000000]
    putStrLn "Expensive computation defined (not computed yet)"
    
    -- 只有在需要时才计算
    let result = expensiveComputation + 1
    putStrLn $ "Result: " ++ show result

-- 惰性模式匹配
lazyPatternMatching :: IO ()
lazyPatternMatching = do
    putStrLn "=== Lazy Pattern Matching ==="
    
    let list = [1, 2, 3, 4, 5]
    
    -- 惰性模式匹配
    case list of
        (x:y:_) -> putStrLn $ "First two elements: " ++ show x ++ ", " ++ show y
        _ -> putStrLn "List too short"
    
    -- 避免计算整个列表
    let safeHead [] = Nothing
        safeHead (x:_) = Just x
    
    putStrLn $ "Safe head: " ++ show (safeHead list)

-- 惰性函数定义
lazyFunctionExample :: IO ()
lazyFunctionExample = do
    putStrLn "=== Lazy Function Examples ==="
    
    -- 惰性函数
    let lazyFilter p (x:xs) = if p x then x : lazyFilter p xs else lazyFilter p xs
        lazyFilter _ [] = []
    
    let numbers = [1..10]
    let evens = lazyFilter even numbers
    
    putStrLn $ "Even numbers: " ++ show (take 5 evens)
    
    -- 惰性映射
    let lazyMap f (x:xs) = f x : lazyMap f xs
        lazyMap _ [] = []
    
    let doubled = lazyMap (*2) numbers
    putStrLn $ "Doubled: " ++ show (take 5 doubled)
```

## 2. 严格求值优化

### 数学定义

严格求值立即计算值：

$$\text{Strict}(f) = \text{Immediate}(f(x))$$

### Haskell实现

```haskell
-- 严格求值示例
strictEvaluationExample :: IO ()
strictEvaluationExample = do
    putStrLn "=== Strict Evaluation Examples ==="
    
    -- 使用seq强制求值
    let x = 1 + 2
        y = 3 + 4
    x `seq` y `seq` putStrLn $ "Strict evaluation: " ++ show (x + y)
    
    -- 严格模式匹配
    let strictSum [] = 0
        strictSum (x:xs) = x + strictSum xs
    
    let numbers = [1..5]
    putStrLn $ "Strict sum: " ++ show (strictSum numbers)
    
    -- 使用BangPatterns
    let strictFunction !x !y = x + y
    
    putStrLn $ "Strict function: " ++ show (strictFunction 3 4)

-- 严格数据结构
strictDataStructures :: IO ()
strictDataStructures = do
    putStrLn "=== Strict Data Structures ==="
    
    -- 严格列表
    data StrictList a = SNil | SCons !a !(StrictList a)
    
    let strictList = SCons 1 (SCons 2 (SCons 3 SNil))
    
    -- 严格列表操作
    let strictLength SNil = 0
        strictLength (SCons _ xs) = 1 + strictLength xs
    
    putStrLn $ "Strict list length: " ++ show (strictLength strictList)
    
    -- 严格元组
    let strictTuple = (1 + 2, 3 + 4)
    putStrLn $ "Strict tuple: " ++ show strictTuple

-- 强制求值技术
forceEvaluation :: IO ()
forceEvaluation = do
    putStrLn "=== Force Evaluation Techniques ==="
    
    -- 使用seq
    let x = 1 + 2
    x `seq` putStrLn $ "Forced evaluation: " ++ show x
    
    -- 使用deepseq
    let list = [1..1000]
    list `seq` putStrLn "List forced to spine"
    
    -- 使用BangPatterns
    let forceWithBang !x = x + 1
    putStrLn $ "Forced with bang: " ++ show (forceWithBang 5)
```

## 3. 内存泄漏检测

### 数学定义

内存泄漏检测：

$$\text{Leak}(f) = \text{Memory}(f) - \text{ExpectedMemory}(f)$$

### Haskell实现

```haskell
-- 内存泄漏检测示例
memoryLeakDetection :: IO ()
memoryLeakDetection = do
    putStrLn "=== Memory Leak Detection ==="
    
    -- 常见的内存泄漏模式
    putStrLn "1. 无限增长的数据结构"
    
    -- 错误：累积未使用的数据
    let leakyAccumulator = foldl (\acc x -> acc ++ [x]) [] [1..1000]
    putStrLn $ "Leaky accumulator length: " ++ show (length leakyAccumulator)
    
    -- 正确：使用严格累加器
    let strictAccumulator = foldl' (\acc x -> acc + x) 0 [1..1000]
    putStrLn $ "Strict accumulator: " ++ show strictAccumulator
    
    putStrLn "2. 闭包捕获大对象"
    
    -- 错误：闭包捕获大对象
    let bigObject = [1..10000]
        leakyClosure = \x -> length bigObject + x
    putStrLn $ "Leaky closure result: " ++ show (leakyClosure 5)
    
    -- 正确：避免捕获大对象
    let bigObjectLength = length [1..10000]
        goodClosure = \x -> bigObjectLength + x
    putStrLn $ "Good closure result: " ++ show (goodClosure 5)

-- 空间复杂度分析
spaceComplexityAnalysis :: IO ()
spaceComplexityAnalysis = do
    putStrLn "=== Space Complexity Analysis ==="
    
    -- O(1) 空间
    let constantSpace x = x + 1
    putStrLn "Constant space function defined"
    
    -- O(n) 空间
    let linearSpace xs = reverse xs
    putStrLn $ "Linear space: " ++ show (linearSpace [1..5])
    
    -- O(n²) 空间
    let quadraticSpace xs = [xs ++ [x] | x <- xs]
    putStrLn $ "Quadratic space: " ++ show (quadraticSpace [1..3])
    
    -- 尾递归优化
    let tailRecursiveSum acc [] = acc
        tailRecursiveSum acc (x:xs) = tailRecursiveSum (acc + x) xs
    
    putStrLn $ "Tail recursive sum: " ++ show (tailRecursiveSum 0 [1..1000])
```

## 4. 垃圾回收优化

### 数学定义

垃圾回收效率：

$$\text{GCEfficiency} = \frac{\text{LiveObjects}}{\text{TotalObjects}}$$

### Haskell实现

```haskell
-- 垃圾回收优化示例
garbageCollectionOptimization :: IO ()
garbageCollectionOptimization = do
    putStrLn "=== Garbage Collection Optimization ==="
    
    -- 减少对象创建
    putStrLn "1. 减少临时对象创建"
    
    -- 错误：创建大量临时对象
    let inefficientConcat = foldr (++) [] (map show [1..1000])
    putStrLn $ "Inefficient concat length: " ++ show (length inefficientConcat)
    
    -- 正确：使用StringBuilder模式
    let efficientConcat = foldr (\x acc -> show x ++ acc) "" [1..1000]
    putStrLn $ "Efficient concat length: " ++ show (length efficientConcat)
    
    putStrLn "2. 重用对象"
    
    -- 错误：每次都创建新对象
    let inefficientMap f xs = foldr (\x acc -> f x : acc) [] xs
    
    -- 正确：使用内置map
    let efficientMap = map
    
    putStrLn $ "Efficient map: " ++ show (efficientMap (*2) [1..5])
    
    putStrLn "3. 避免循环引用"
    
    -- 使用弱引用或避免循环引用
    let tree = Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)
    putStrLn $ "Tree without cycles: " ++ show tree
  where
    data Tree a = Empty | Node a (Tree a) (Tree a)

-- 内存池模式
memoryPoolPattern :: IO ()
memoryPoolPattern = do
    putStrLn "=== Memory Pool Pattern ==="
    
    -- 对象池
    data ObjectPool a = ObjectPool {
        available :: [a],
        inUse :: [a]
    }
    
    -- 创建对象池
    let createPool objects = ObjectPool objects []
    
    -- 获取对象
    let getObject (ObjectPool (x:xs) inUse) = (x, ObjectPool xs (x:inUse))
        getObject (ObjectPool [] inUse) = error "Pool empty"
    
    -- 返回对象
    let returnObject obj (ObjectPool available inUse) = 
            ObjectPool (obj:available) (filter (/= obj) inUse)
    
    let pool = createPool [1..5]
    putStrLn $ "Pool created with " ++ show (length (available pool)) ++ " objects"
    
    let (obj1, pool1) = getObject pool
    putStrLn $ "Got object: " ++ show obj1
    
    let pool2 = returnObject obj1 pool1
    putStrLn $ "Returned object, available: " ++ show (length (available pool2))
```

## 5. 数据结构优化

### 数学定义

数据结构效率：

$$\text{Efficiency}(DS) = \frac{\text{Operations}}{\text{MemoryUsage}}$$

### Haskell实现

```haskell
-- 数据结构优化示例
dataStructureOptimization :: IO ()
dataStructureOptimization = do
    putStrLn "=== Data Structure Optimization ==="
    
    -- 1. 使用合适的数据结构
    putStrLn "1. 选择合适的容器"
    
    -- 列表：适合顺序访问
    let list = [1..1000]
    putStrLn $ "List head: " ++ show (head list)
    
    -- 数组：适合随机访问
    let array = listArray (0, 999) [1..1000]
    putStrLn $ "Array access: " ++ show (array ! 500)
    
    -- 集合：适合查找
    let set = Set.fromList [1..1000]
    putStrLn $ "Set member: " ++ show (Set.member 500 set)
    
    -- 映射：适合键值对
    let map = Map.fromList [(i, i*i) | i <- [1..100]]
    putStrLn $ "Map lookup: " ++ show (Map.lookup 50 map)
    
    putStrLn "2. 优化数据结构布局"
    
    -- 紧凑的数据结构
    data CompactPair a b = CompactPair !a !b
    
    let compactPair = CompactPair 1 2
    putStrLn $ "Compact pair: " ++ show compactPair
    
    -- 使用UNPACK编译指示
    data UnpackedStruct = UnpackedStruct {
        field1 :: {-# UNPACK #-} !Int,
        field2 :: {-# UNPACK #-} !Double
    }
    
    let unpacked = UnpackedStruct 42 3.14
    putStrLn $ "Unpacked struct: " ++ show unpacked

-- 缓存优化
cacheOptimization :: IO ()
cacheOptimization = do
    putStrLn "=== Cache Optimization ==="
    
    -- 1. 局部性优化
    putStrLn "1. 提高缓存局部性"
    
    -- 连续访问
    let matrix = [[1..100] | _ <- [1..100]]
    let rowSum = sum (head matrix)
    putStrLn $ "Row sum: " ++ show rowSum
    
    -- 2. 缓存计算结果
    putStrLn "2. 缓存计算结果"
    
    let memoizedFib = (map fib [0..] !!)
        where fib 0 = 0
              fib 1 = 1
              fib n = memoizedFib (n-1) + memoizedFib (n-2)
    
    putStrLn $ "Memoized fibonacci 10: " ++ show (memoizedFib 10)
    
    -- 3. 使用严格求值避免缓存未使用的结果
    putStrLn "3. 避免缓存未使用的结果"
    
    let strictComputation = foldl' (+) 0 [1..1000]
    putStrLn $ "Strict computation: " ++ show strictComputation
```

## 6. 性能监控

### 数学定义

性能指标：

$$\text{Performance} = \frac{\text{WorkDone}}{\text{TimeUsed} \times \text{MemoryUsed}}$$

### Haskell实现

```haskell
-- 性能监控示例
performanceMonitoring :: IO ()
performanceMonitoring = do
    putStrLn "=== Performance Monitoring ==="
    
    -- 1. 内存使用监控
    putStrLn "1. 监控内存使用"
    
    let memoryIntensive = [1..1000000]
    putStrLn $ "Memory intensive list length: " ++ show (length memoryIntensive)
    
    -- 2. 时间性能监控
    putStrLn "2. 监控执行时间"
    
    let startTime = 0  -- 实际使用getCurrentTime
    let computation = sum [1..1000000]
    let endTime = 0    -- 实际使用getCurrentTime
    let duration = endTime - startTime
    
    putStrLn $ "Computation time: " ++ show duration
    
    -- 3. 空间复杂度分析
    putStrLn "3. 分析空间复杂度"
    
    let spaceAnalysis xs = length xs + sum (map length xs)
    putStrLn $ "Space analysis: " ++ show (spaceAnalysis [[1..10], [1..5], [1..3]])

-- 性能基准测试
benchmarkExample :: IO ()
benchmarkExample = do
    putStrLn "=== Benchmark Example ==="
    
    -- 基准测试函数
    let benchmark name action = do
            putStrLn $ "Benchmarking: " ++ name
            let result = action
            putStrLn $ "Result: " ++ show result
    
    -- 测试不同实现
    benchmark "List concatenation" $ length ([1..1000] ++ [1..1000])
    benchmark "List construction" $ length [1..2000]
    benchmark "Strict fold" $ foldl' (+) 0 [1..1000]
    benchmark "Lazy fold" $ foldr (+) 0 [1..1000]
```

## 7. 最佳实践

### 内存优化最佳实践

```haskell
-- 最佳实践示例
bestPractices :: IO ()
bestPractices = do
    putStrLn "=== Memory Optimization Best Practices ==="
    
    putStrLn "1. 使用严格求值避免空间泄漏"
    
    -- 错误：累积thunk
    let badSum = foldr (+) 0 [1..1000]
    
    -- 正确：使用严格求值
    let goodSum = foldl' (+) 0 [1..1000]
    
    putStrLn $ "Good sum: " ++ show goodSum
    
    putStrLn "2. 避免共享大对象"
    
    -- 错误：共享大对象
    let bigObject = [1..10000]
        functions = [\x -> length bigObject + x | _ <- [1..100]]
    
    -- 正确：避免共享
    let functions' = [\x -> 10000 + x | _ <- [1..100]]
    
    putStrLn "3. 使用合适的数据结构"
    
    -- 对于查找操作，使用Set而不是List
    let set = Set.fromList [1..1000]
    putStrLn $ "Set lookup: " ++ show (Set.member 500 set)
    
    putStrLn "4. 及时释放资源"
    
    -- 使用withFile确保文件句柄被释放
    putStrLn "File handle will be automatically released"
    
    putStrLn "5. 避免循环引用"
    
    -- 使用弱引用或重新设计数据结构
    putStrLn "Avoid circular references in data structures"
```

## 总结

Haskell的内存优化提供了：

1. **惰性求值**：避免不必要的计算
2. **严格求值**：控制内存使用
3. **垃圾回收**：自动内存管理
4. **数据结构优化**：选择合适的容器
5. **性能监控**：测量和优化性能
6. **最佳实践**：避免常见的内存问题

这些技术帮助开发者编写高效、内存安全的Haskell程序。 