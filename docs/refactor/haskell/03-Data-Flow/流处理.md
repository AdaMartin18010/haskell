# Haskell 流处理 (Stream Processing)

## 概述

流处理是处理无限或大量数据的核心技术，在Haskell中通过惰性求值和流数据结构实现。流处理允许我们以声明式的方式处理数据流，支持管道操作、转换和聚合。

## 数学定义

### 流的形式化定义

流是一个无限序列，可以形式化为：

$$\text{Stream } A = \mathbb{N} \to A$$

其中 $A$ 是元素类型，$\mathbb{N}$ 是自然数集合。

### 流的代数结构

#### 1. 流的函子结构

对于类型 $A$ 和函数 $f : A \to B$，流的函子映射定义为：

$$\text{map}_f : \text{Stream } A \to \text{Stream } B$$
$$\text{map}_f(s)(n) = f(s(n))$$

#### 2. 流的单子结构

流的单子操作定义为：

$$\text{return} : A \to \text{Stream } A$$
$$\text{return}(a)(n) = a$$

$$\text{bind} : \text{Stream } A \to (A \to \text{Stream } B) \to \text{Stream } B$$
$$\text{bind}(s, f)(n) = f(s(n))(n)$$

## Haskell中的流处理

### 基本流定义

```haskell
-- 基本流类型
data Stream a = Cons a (Stream a)

-- 数学定义：Stream a = a × Stream a
-- 表示一个头部元素和尾部流的乘积类型

-- 流的构造
head :: Stream a -> a
head (Cons x _) = x

tail :: Stream a -> Stream a
tail (Cons _ xs) = xs

-- 无限流生成
repeat :: a -> Stream a
repeat x = Cons x (repeat x)

iterate :: (a -> a) -> a -> Stream a
iterate f x = Cons x (iterate f (f x))

-- 数学定义：iterate f x = x : iterate f (f x)
```

### 基本流操作

```haskell
-- 流的基本操作
takeStream :: Int -> Stream a -> [a]
takeStream 0 _ = []
takeStream n (Cons x xs) = x : takeStream (n-1) xs

dropStream :: Int -> Stream a -> Stream a
dropStream 0 xs = xs
dropStream n (Cons _ xs) = dropStream (n-1) xs

-- 流的映射
mapStream :: (a -> b) -> Stream a -> Stream b
mapStream f (Cons x xs) = Cons (f x) (mapStream f xs)

-- 数学定义：mapStream f = λs. Cons (f (head s)) (mapStream f (tail s))
```

## 高级流处理

### 1. 流转换

```haskell
-- 流转换操作
filterStream :: (a -> Bool) -> Stream a -> Stream a
filterStream p (Cons x xs)
    | p x = Cons x (filterStream p xs)
    | otherwise = filterStream p xs

zipStream :: Stream a -> Stream b -> Stream (a, b)
zipStream (Cons x xs) (Cons y ys) = Cons (x, y) (zipStream xs ys)

-- 流的组合
interleave :: Stream a -> Stream a -> Stream a
interleave (Cons x xs) ys = Cons x (interleave ys xs)

-- 数学定义：interleave s1 s2 = head s1 : interleave s2 (tail s1)
```

### 2. 流聚合

```haskell
-- 流聚合操作
foldStream :: (a -> b -> b) -> b -> Stream a -> b
foldStream f acc (Cons x xs) = foldStream f (f x acc) xs

scanStream :: (a -> b -> b) -> b -> Stream a -> Stream b
scanStream f acc (Cons x xs) = Cons acc (scanStream f (f x acc) xs)

-- 流的累积
runningSum :: Stream Int -> Stream Int
runningSum = scanStream (+) 0

runningAverage :: Stream Double -> Stream Double
runningAverage = scanStream (\x (sum, count) -> (sum + x, count + 1)) (0, 0)
                . mapStream (\(sum, count) -> sum / fromIntegral count)

-- 测试
main :: IO ()
main = do
    let numbers = iterate (+1) 1  -- 1, 2, 3, 4, ...
    print $ takeStream 5 (runningSum numbers)  -- [0, 1, 3, 6, 10]
```

### 3. 流管道

```haskell
-- 流管道操作
type StreamPipe a b = Stream a -> Stream b

-- 管道组合
(>>>) :: StreamPipe a b -> StreamPipe b c -> StreamPipe a c
f >>> g = g . f

-- 并行管道
(&&&) :: StreamPipe a b -> StreamPipe a c -> StreamPipe a (b, c)
f &&& g = \s -> zipStream (f s) (g s)

-- 分支管道
(|||) :: StreamPipe a b -> StreamPipe a b -> StreamPipe a b
f ||| g = \s -> interleave (f s) (g s)

-- 实际应用
dataProcessing :: StreamPipe Int Int
dataProcessing = filterStream even
               >>> mapStream (*2)
               >>> mapStream (+1)

-- 测试
main :: IO ()
main = do
    let input = iterate (+1) 1
    let output = dataProcessing input
    print $ takeStream 5 output  -- [3, 5, 7, 9, 11]
```

## 实际应用示例

### 1. 数据流处理

```haskell
-- 传感器数据处理
data SensorData = SensorData 
    { timestamp :: Double
    , value :: Double
    , sensorId :: String
    }

-- 传感器流处理
processSensorData :: Stream SensorData -> Stream Double
processSensorData = mapStream value
                 >>> filterStream (>0)
                 >>> mapStream sqrt
                 >>> scanStream (+) 0

-- 异常检测
detectAnomalies :: Stream Double -> Stream Bool
detectAnomalies = scanStream (\x (sum, count) -> (sum + x, count + 1)) (0, 0)
                . mapStream (\(sum, count) -> 
                    let avg = sum / fromIntegral count
                    in abs (sum - avg) > 2 * avg)

-- 测试
main :: IO ()
main = do
    let sensorStream = iterate (\d -> d { timestamp = timestamp d + 1
                                       , value = value d + 0.1 }) 
                              (SensorData 0 1.0 "sensor1")
    let processed = processSensorData sensorStream
    print $ takeStream 5 processed
```

### 2. 日志流处理

```haskell
-- 日志流处理
data LogEntry = LogEntry 
    { time :: Double
    , level :: String
    , message :: String
    }

-- 日志分析管道
logAnalysis :: Stream LogEntry -> Stream (String, Int)
logAnalysis = mapStream level
            >>> groupByStream (==)
            >>> mapStream (\group -> (head group, length group))

-- 错误率监控
errorRate :: Stream LogEntry -> Stream Double
errorRate = mapStream (\log -> if level log == "ERROR" then 1 else 0)
         >>> scanStream (+) 0
         >>> zipWithStream (/) (iterate (+1) 1)

-- 测试
main :: IO ()
main = do
    let logs = iterate (\l -> l { time = time l + 1
                               , level = if time l `mod` 10 == 0 then "ERROR" else "INFO" })
                      (LogEntry 0 "INFO" "System started")
    let rates = errorRate logs
    print $ takeStream 10 rates
```

### 3. 金融数据流处理

```haskell
-- 金融数据流处理
data PriceData = PriceData 
    { symbol :: String
    , price :: Double
    , volume :: Int
    }

-- 移动平均线
movingAverage :: Int -> Stream Double -> Stream Double
movingAverage window = scanStream (\x window' -> 
    if length window' >= window 
    then tail window' ++ [x]
    else window' ++ [x]) []
  . mapStream (\window' -> sum window' / fromIntegral (length window'))

-- 价格变化率
priceChange :: Stream PriceData -> Stream Double
priceChange = scanStream (\current (last, _) -> (current, last)) (PriceData "" 0 0)
            . mapStream (\(current, last) -> 
                if price last == 0 then 0 else (price current - price last) / price last)

-- 测试
main :: IO ()
main = do
    let prices = iterate (\p -> p { price = price p * 1.01 }) 
                        (PriceData "AAPL" 100.0 1000)
    let ma5 = movingAverage 5 (mapStream price prices)
    let changes = priceChange prices
    print $ takeStream 5 ma5
```

## 流处理的优化

### 1. 内存优化

```haskell
-- 内存优化的流处理
-- 使用弱头范式避免内存泄漏
strictStream :: Stream a -> Stream a
strictStream (Cons x xs) = Cons (seq x x) (strictStream xs)

-- 批量处理
batchProcess :: Int -> Stream a -> Stream [a]
batchProcess size = scanStream (\x batch -> 
    if length batch >= size 
    then [x]
    else batch ++ [x]) []
  . filterStream (\batch -> length batch == size)

-- 数学定义：批量处理将流分组为固定大小的批次
```

### 2. 并行流处理

```haskell
-- 并行流处理
import Control.Parallel
import Control.Parallel.Strategies

-- 并行映射
parMapStream :: (a -> b) -> Stream a -> Stream b
parMapStream f (Cons x xs) = Cons (f x `using` rpar) (parMapStream f xs)

-- 并行归约
parFoldStream :: (a -> b -> b) -> b -> Stream a -> b
parFoldStream f acc (Cons x xs) = 
    let result = f x acc `using` rpar
    in parFoldStream f result xs

-- 数学定义：并行处理利用多个处理器同时计算
```

## 形式化验证

### 1. 流处理的性质验证

```haskell
import Test.QuickCheck

-- 验证流映射的性质
prop_mapIdentity :: Stream Int -> Bool
prop_mapIdentity s = mapStream id s == s

prop_mapComposition :: Stream Int -> Bool
prop_mapComposition s = 
    let f = (+1)
        g = (*2)
    in mapStream (f . g) s == mapStream f (mapStream g s)

-- 验证流的结合律
prop_streamAssociativity :: Stream Int -> Bool
prop_streamAssociativity s = 
    let f = filterStream even
        g = mapStream (*2)
        h = mapStream (+1)
    in (f >>> g) >>> h s == f >>> (g >>> h) s

-- 测试
main :: IO ()
main = do
    quickCheck prop_mapIdentity
    quickCheck prop_mapComposition
    quickCheck prop_streamAssociativity
```

### 2. 流处理的终止性

```haskell
-- 流处理的终止性证明
-- 对于有限输入，流处理总是终止
-- 对于无限输入，流处理在惰性求值下可以处理

-- 证明：每个流操作都是结构递归的
-- 基础情况：空流或单个元素
-- 归纳步骤：对流的尾部递归调用
```

## 总结

Haskell的流处理提供了：

1. **惰性求值**：只计算需要的元素
2. **声明式编程**：通过管道描述数据处理
3. **内存效率**：避免存储整个数据集
4. **可组合性**：流操作可以自由组合
5. **并行处理**：支持并行计算

流处理的数学基础确保了其正确性和可靠性，使其成为处理大数据和实时数据的强大工具。

---

**相关主题**：

- [数据流编程](./数据流编程.md)
- [管道操作](./管道操作.md)
- [高阶函数](../02-Control-Flow/高阶函数.md)
