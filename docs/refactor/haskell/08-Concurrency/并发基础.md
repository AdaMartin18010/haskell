# 并发基础

## 概述

Haskell的并发编程基于函数式编程的不可变性和纯函数特性，提供了安全、高效的并发抽象。Haskell的并发模型包括轻量级线程、STM（软件事务内存）、异步编程等。

## 数学基础

### 并发理论

并发系统可以建模为：

$$\text{ConcurrentSystem} = \text{Processes} \times \text{Communication} \times \text{Synchronization}$$

其中：

- **进程**：独立的执行单元
- **通信**：进程间的消息传递
- **同步**：进程间的协调机制

### 并发安全性

并发安全性满足：

$$\text{Safety} = \forall \text{execution}, \text{invariant}(s) \text{ holds}$$

## 1. 轻量级线程 (Lightweight Threads)

### 数学定义

轻量级线程是用户空间的执行单元：

$$\text{Thread} = \text{Stack} \times \text{Context} \times \text{State}$$

### Haskell实现

```haskell
import Control.Concurrent
import Control.Monad

-- 基本线程操作
forkIO :: IO () -> IO ThreadId
forkIO action = do
    threadId <- myThreadId
    putStrLn $ "Forking thread from: " ++ show threadId
    -- 实际实现由GHC提供

myThreadId :: IO ThreadId
myThreadId = return undefined  -- 实际实现由GHC提供

-- 线程延迟
threadDelay :: Int -> IO ()
threadDelay microseconds = do
    putStrLn $ "Sleeping for " ++ show microseconds ++ " microseconds"
    -- 实际实现由GHC提供

-- 线程终止
killThread :: ThreadId -> IO ()
killThread tid = do
    putStrLn $ "Killing thread: " ++ show tid
    -- 实际实现由GHC提供

-- 基本示例
basicThreadExample :: IO ()
basicThreadExample = do
    putStrLn "Main thread starting"
    
    -- 创建子线程
    tid <- forkIO $ do
        putStrLn "Child thread starting"
        threadDelay 1000000  -- 1秒
        putStrLn "Child thread finishing"
    
    putStrLn "Main thread continuing"
    threadDelay 2000000  -- 2秒
    putStrLn "Main thread finishing"

-- 多线程示例
multiThreadExample :: IO ()
multiThreadExample = do
    putStrLn "Starting multi-thread example"
    
    -- 创建多个线程
    tids <- forM [1..3] $ \i -> forkIO $ do
        putStrLn $ "Thread " ++ show i ++ " starting"
        threadDelay (i * 500000)  -- 不同延迟
        putStrLn $ "Thread " ++ show i ++ " finishing"
    
    putStrLn "All threads created"
    threadDelay 2000000
    putStrLn "Main thread finishing"

-- 线程间通信示例
threadCommunicationExample :: IO ()
threadCommunicationExample = do
    putStrLn "Starting thread communication example"
    
    -- 创建生产者线程
    producerTid <- forkIO $ do
        forM_ [1..5] $ \i -> do
            putStrLn $ "Producing: " ++ show i
            threadDelay 500000
    
    -- 创建消费者线程
    consumerTid <- forkIO $ do
        forM_ [1..5] $ \i -> do
            threadDelay 300000
            putStrLn $ "Consuming: " ++ show i
    
    threadDelay 3000000
    putStrLn "Communication example finished"
```

## 2. MVar - 可变变量

### 数学定义

MVar是线程间的同步原语：

$$\text{MVar}(A) = \text{Maybe}(A) \text{ with synchronization}$$

### Haskell实现

```haskell
import Control.Concurrent.MVar

-- MVar基本操作
newEmptyMVar :: IO (MVar a)
newEmptyMVar = do
    putStrLn "Creating empty MVar"
    return undefined  -- 实际实现由GHC提供

newMVar :: a -> IO (MVar a)
newMVar value = do
    putStrLn $ "Creating MVar with value: " ++ show value
    return undefined  -- 实际实现由GHC提供

takeMVar :: MVar a -> IO a
takeMVar mvar = do
    putStrLn "Taking from MVar"
    return undefined  -- 实际实现由GHC提供

putMVar :: MVar a -> a -> IO ()
putMVar mvar value = do
    putStrLn $ "Putting value in MVar: " ++ show value
    -- 实际实现由GHC提供

readMVar :: MVar a -> IO a
readMVar mvar = do
    putStrLn "Reading from MVar"
    return undefined  -- 实际实现由GHC提供

tryTakeMVar :: MVar a -> IO (Maybe a)
tryTakeMVar mvar = do
    putStrLn "Trying to take from MVar"
    return Nothing  -- 实际实现由GHC提供

tryPutMVar :: MVar a -> a -> IO Bool
tryPutMVar mvar value = do
    putStrLn $ "Trying to put value in MVar: " ++ show value
    return True  -- 实际实现由GHC提供

-- MVar示例
mvarExample :: IO ()
mvarExample = do
    putStrLn "Starting MVar example"
    
    -- 创建空的MVar
    mvar <- newEmptyMVar
    
    -- 生产者线程
    producerTid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            putStrLn $ "Producer putting: " ++ show i
            putMVar mvar i
            threadDelay 500000
    
    -- 消费者线程
    consumerTid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            value <- takeMVar mvar
            putStrLn $ "Consumer got: " ++ show value
            threadDelay 300000
    
    threadDelay 2000000
    putStrLn "MVar example finished"

-- 预填充MVar示例
prefilledMVarExample :: IO ()
prefilledMVarExample = do
    putStrLn "Starting prefilled MVar example"
    
    -- 创建预填充的MVar
    mvar <- newMVar "initial value"
    
    -- 读取线程
    readerTid <- forkIO $ do
        value <- readMVar mvar
        putStrLn $ "Reader got: " ++ show value
        threadDelay 1000000
        value2 <- readMVar mvar
        putStrLn $ "Reader got again: " ++ show value2
    
    -- 修改线程
    modifierTid <- forkIO $ do
        threadDelay 500000
        oldValue <- takeMVar mvar
        putStrLn $ "Modifier took: " ++ show oldValue
        putMVar mvar "modified value"
        putStrLn "Modifier put new value"
    
    threadDelay 2000000
    putStrLn "Prefilled MVar example finished"

-- 非阻塞MVar操作示例
nonBlockingMVarExample :: IO ()
nonBlockingMVarExample = do
    putStrLn "Starting non-blocking MVar example"
    
    mvar <- newEmptyMVar
    
    -- 非阻塞尝试
    result1 <- tryTakeMVar mvar
    putStrLn $ "Try take result: " ++ show result1
    
    success <- tryPutMVar mvar "test"
    putStrLn $ "Try put success: " ++ show success
    
    result2 <- tryTakeMVar mvar
    putStrLn $ "Try take result after put: " ++ show result2
    
    putStrLn "Non-blocking MVar example finished"
```

## 3. 通道 (Channels)

### 数学定义

通道是线程间的通信机制：

$$\text{Channel}(A) = \text{Queue}(A) \text{ with synchronization}$$

### Haskell实现

```haskell
import Control.Concurrent.Chan

-- 通道基本操作
newChan :: IO (Chan a)
newChan = do
    putStrLn "Creating new channel"
    return undefined  -- 实际实现由GHC提供

writeChan :: Chan a -> a -> IO ()
writeChan chan value = do
    putStrLn $ "Writing to channel: " ++ show value
    -- 实际实现由GHC提供

readChan :: Chan a -> IO a
readChan chan = do
    putStrLn "Reading from channel"
    return undefined  -- 实际实现由GHC提供

dupChan :: Chan a -> IO (Chan a)
dupChan chan = do
    putStrLn "Duplicating channel"
    return undefined  -- 实际实现由GHC提供

-- 通道示例
channelExample :: IO ()
channelExample = do
    putStrLn "Starting channel example"
    
    -- 创建通道
    chan <- newChan
    
    -- 生产者线程
    producerTid <- forkIO $ do
        forM_ [1..5] $ \i -> do
            putStrLn $ "Producer writing: " ++ show i
            writeChan chan i
            threadDelay 300000
    
    -- 消费者线程
    consumerTid <- forkIO $ do
        forM_ [1..5] $ \i -> do
            value <- readChan chan
            putStrLn $ "Consumer read: " ++ show value
            threadDelay 200000
    
    threadDelay 2000000
    putStrLn "Channel example finished"

-- 多消费者示例
multiConsumerExample :: IO ()
multiConsumerExample = do
    putStrLn "Starting multi-consumer example"
    
    chan <- newChan
    
    -- 生产者
    producerTid <- forkIO $ do
        forM_ [1..6] $ \i -> do
            putStrLn $ "Producer writing: " ++ show i
            writeChan chan i
            threadDelay 200000
    
    -- 消费者1
    consumer1Tid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            value <- readChan chan
            putStrLn $ "Consumer 1 read: " ++ show value
            threadDelay 100000
    
    -- 消费者2
    consumer2Tid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            value <- readChan chan
            putStrLn $ "Consumer 2 read: " ++ show value
            threadDelay 150000
    
    threadDelay 2000000
    putStrLn "Multi-consumer example finished"

-- 通道复制示例
duplicateChannelExample :: IO ()
duplicateChannelExample = do
    putStrLn "Starting duplicate channel example"
    
    originalChan <- newChan
    dupChan1 <- dupChan originalChan
    dupChan2 <- dupChan originalChan
    
    -- 生产者
    producerTid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            putStrLn $ "Producer writing: " ++ show i
            writeChan originalChan i
            threadDelay 500000
    
    -- 消费者1（从原始通道）
    consumer1Tid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            value <- readChan originalChan
            putStrLn $ "Consumer 1 (original) read: " ++ show value
            threadDelay 200000
    
    -- 消费者2（从复制通道）
    consumer2Tid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            value <- readChan dupChan1
            putStrLn $ "Consumer 2 (duplicate) read: " ++ show value
            threadDelay 300000
    
    threadDelay 2000000
    putStrLn "Duplicate channel example finished"
```

## 4. 软件事务内存 (STM)

### 数学定义

STM提供原子事务：

$$\text{STM}(A) = \text{Transaction} \times \text{Atomicity} \times \text{Consistency}$$

### Haskell实现

```haskell
import Control.Concurrent.STM
import Control.Monad.STM

-- STM变量
newTVar :: a -> STM (TVar a)
newTVar value = do
    putStrLn $ "Creating TVar with value: " ++ show value
    return undefined  -- 实际实现由GHC提供

readTVar :: TVar a -> STM a
readTVar tvar = do
    putStrLn "Reading from TVar"
    return undefined  -- 实际实现由GHC提供

writeTVar :: TVar a -> a -> STM ()
writeTVar tvar value = do
    putStrLn $ "Writing to TVar: " ++ show value
    -- 实际实现由GHC提供

modifyTVar :: TVar a -> (a -> a) -> STM ()
modifyTVar tvar f = do
    putStrLn "Modifying TVar"
    -- 实际实现由GHC提供

-- STM执行
atomically :: STM a -> IO a
atomically stm = do
    putStrLn "Executing STM transaction atomically"
    return undefined  -- 实际实现由GHC提供

-- STM示例
stmExample :: IO ()
stmExample = do
    putStrLn "Starting STM example"
    
    -- 创建TVar
    tvar <- atomically $ newTVar 0
    
    -- 多个线程并发修改
    tids <- forM [1..3] $ \i -> forkIO $ do
        forM_ [1..3] $ \j -> do
            atomically $ do
                current <- readTVar tvar
                writeTVar tvar (current + i)
                putStrLn $ "Thread " ++ show i ++ " incremented to " ++ show (current + i)
            threadDelay 100000
    
    threadDelay 1000000
    
    -- 读取最终值
    finalValue <- atomically $ readTVar tvar
    putStrLn $ "Final value: " ++ show finalValue
    
    putStrLn "STM example finished"

-- 条件STM示例
conditionalSTMExample :: IO ()
conditionalSTMExample = do
    putStrLn "Starting conditional STM example"
    
    tvar <- atomically $ newTVar 0
    
    -- 条件更新线程
    conditionalTid <- forkIO $ do
        atomically $ do
            current <- readTVar tvar
            when (current < 5) $ do
                writeTVar tvar (current + 1)
                putStrLn $ "Conditional update: " ++ show (current + 1)
        threadDelay 200000
    
    -- 普通更新线程
    normalTid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            atomically $ do
                current <- readTVar tvar
                writeTVar tvar (current + 10)
                putStrLn $ "Normal update: " ++ show (current + 10)
            threadDelay 300000
    
    threadDelay 1500000
    finalValue <- atomically $ readTVar tvar
    putStrLn $ "Final value: " ++ show finalValue
    
    putStrLn "Conditional STM example finished"

-- 多TVar事务示例
multiTVarExample :: IO ()
multiTVarExample = do
    putStrLn "Starting multi-TVar example"
    
    tvar1 <- atomically $ newTVar 0
    tvar2 <- atomically $ newTVar 0
    
    -- 原子交换线程
    swapTid <- forkIO $ do
        atomically $ do
            val1 <- readTVar tvar1
            val2 <- readTVar tvar2
            writeTVar tvar1 val2
            writeTVar tvar2 val1
            putStrLn $ "Swapped: " ++ show val1 ++ " <-> " ++ show val2
        threadDelay 500000
    
    -- 独立更新线程
    updateTid <- forkIO $ do
        forM_ [1..3] $ \i -> do
            atomically $ do
                modifyTVar tvar1 (+1)
                modifyTVar tvar2 (+2)
                putStrLn $ "Updated both TVars: " ++ show i
            threadDelay 200000
    
    threadDelay 1500000
    
    -- 读取最终值
    (final1, final2) <- atomically $ do
        v1 <- readTVar tvar1
        v2 <- readTVar tvar2
        return (v1, v2)
    
    putStrLn $ "Final values: " ++ show final1 ++ ", " ++ show final2
    putStrLn "Multi-TVar example finished"
```

## 5. 异步编程 (Async)

### 数学定义

异步编程模型：

$$\text{Async}(A) = \text{Future}(A) \times \text{NonBlocking}$$

### Haskell实现

```haskell
import Control.Concurrent.Async

-- 异步操作
async :: IO a -> IO (Async a)
async action = do
    putStrLn "Creating async action"
    return undefined  -- 实际实现由GHC提供

wait :: Async a -> IO a
wait async = do
    putStrLn "Waiting for async result"
    return undefined  -- 实际实现由GHC提供

waitCatch :: Async a -> IO (Either SomeException a)
waitCatch async = do
    putStrLn "Waiting for async result with exception handling"
    return undefined  -- 实际实现由GHC提供

cancel :: Async a -> IO ()
cancel async = do
    putStrLn "Cancelling async action"
    -- 实际实现由GHC提供

-- 并发执行
concurrently :: IO a -> IO b -> IO (a, b)
concurrently action1 action2 = do
    putStrLn "Executing actions concurrently"
    return undefined  -- 实际实现由GHC提供

race :: IO a -> IO b -> IO (Either a b)
race action1 action2 = do
    putStrLn "Racing actions"
    return undefined  -- 实际实现由GHC提供

-- 异步示例
asyncExample :: IO ()
asyncExample = do
    putStrLn "Starting async example"
    
    -- 创建异步操作
    async1 <- async $ do
        putStrLn "Async 1 starting"
        threadDelay 1000000
        putStrLn "Async 1 finishing"
        return "Result 1"
    
    async2 <- async $ do
        putStrLn "Async 2 starting"
        threadDelay 500000
        putStrLn "Async 2 finishing"
        return "Result 2"
    
    -- 等待结果
    result1 <- wait async1
    result2 <- wait async2
    
    putStrLn $ "Results: " ++ result1 ++ ", " ++ result2
    putStrLn "Async example finished"

-- 并发执行示例
concurrentExample :: IO ()
concurrentExample = do
    putStrLn "Starting concurrent example"
    
    -- 并发执行两个操作
    (result1, result2) <- concurrently 
        (do threadDelay 1000000; return "Slow")
        (do threadDelay 500000; return "Fast")
    
    putStrLn $ "Concurrent results: " ++ result1 ++ ", " ++ result2
    putStrLn "Concurrent example finished"

-- 竞态示例
raceExample :: IO ()
raceExample = do
    putStrLn "Starting race example"
    
    -- 竞态执行
    result <- race 
        (do threadDelay 2000000; return "Slow")
        (do threadDelay 500000; return "Fast")
    
    case result of
        Left slow -> putStrLn $ "Slow won: " ++ slow
        Right fast -> putStrLn $ "Fast won: " ++ fast
    
    putStrLn "Race example finished"

-- 异常处理示例
exceptionHandlingExample :: IO ()
exceptionHandlingExample = do
    putStrLn "Starting exception handling example"
    
    -- 可能抛出异常的异步操作
    async1 <- async $ do
        putStrLn "Async with exception starting"
        threadDelay 500000
        error "Simulated exception"
    
    async2 <- async $ do
        putStrLn "Normal async starting"
        threadDelay 1000000
        return "Success"
    
    -- 处理异常
    result1 <- waitCatch async1
    result2 <- waitCatch async2
    
    putStrLn $ "Exception result: " ++ show result1
    putStrLn $ "Success result: " ++ show result2
    
    putStrLn "Exception handling example finished"
```

## 6. 并发模式

### 生产者-消费者模式

```haskell
-- 生产者-消费者模式
producerConsumerPattern :: IO ()
producerConsumerPattern = do
    putStrLn "Starting producer-consumer pattern"
    
    chan <- newChan
    
    -- 生产者
    producerTid <- forkIO $ do
        forM_ [1..5] $ \i -> do
            putStrLn $ "Producer: " ++ show i
            writeChan chan i
            threadDelay 300000
    
    -- 消费者
    consumerTid <- forkIO $ do
        forM_ [1..5] $ \i -> do
            value <- readChan chan
            putStrLn $ "Consumer: " ++ show value
            threadDelay 200000
    
    threadDelay 2000000
    putStrLn "Producer-consumer pattern finished"

-- 工作池模式
workerPoolPattern :: IO ()
workerPoolPattern = do
    putStrLn "Starting worker pool pattern"
    
    jobChan <- newChan
    resultChan <- newChan
    
    -- 创建工作线程
    workerTids <- forM [1..3] $ \workerId -> forkIO $ do
        forever $ do
            job <- readChan jobChan
            putStrLn $ "Worker " ++ show workerId ++ " processing: " ++ show job
            threadDelay 200000
            writeChan resultChan (job * 2)
    
    -- 提交作业
    forM_ [1..6] $ \job -> do
        putStrLn $ "Submitting job: " ++ show job
        writeChan jobChan job
        threadDelay 100000
    
    -- 收集结果
    forM_ [1..6] $ \i -> do
        result <- readChan resultChan
        putStrLn $ "Result: " ++ show result
    
    putStrLn "Worker pool pattern finished"
```

## 总结

Haskell的并发编程提供了：

1. **轻量级线程**：高效的用户空间线程
2. **MVar**：线程间的同步原语
3. **通道**：线程间的通信机制
4. **STM**：软件事务内存
5. **异步编程**：非阻塞的并发操作
6. **并发模式**：常用的并发设计模式

这些特性为Haskell提供了强大、安全的并发编程能力。

---

**相关主题**：

- [线程管理](线程管理.md)
- [同步机制](同步机制.md)
- [异步编程](异步编程.md)
- [STM系统](../04-Type-System/高级类型.md)
