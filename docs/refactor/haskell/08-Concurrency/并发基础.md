# Haskell并发编程基础

## 概述

并发编程是Haskell中的重要特性，它允许程序同时执行多个计算任务。Haskell提供了多种并发模型，包括轻量级线程、软件事务内存(STM)、异步编程等。本文档介绍Haskell并发编程的基础概念和实现。

## 1. 并发模型

### 数学定义

并发系统可以形式化为：

$$\text{ConcurrentSystem} = (S, T, \rightarrow, s_0)$$

其中：
- $S$ 是状态集合
- $T$ 是线程集合
- $\rightarrow \subseteq S \times T \times S$ 是状态转换关系
- $s_0 \in S$ 是初始状态

### Haskell实现

```haskell
-- 并发系统的基本类型
type ThreadId = Int
type State = Map String Value
type Transition = (State, ThreadId, State)

-- 并发系统
data ConcurrentSystem = ConcurrentSystem 
    { states :: Set State
    , threads :: Set ThreadId
    , transitions :: Set Transition
    , initialState :: State
    }

-- 线程状态
data ThreadState = Running | Blocked | Terminated
  deriving (Show, Eq)

-- 线程信息
data ThreadInfo = ThreadInfo 
    { threadId :: ThreadId
    , threadState :: ThreadState
    , threadAction :: IO ()
    }

-- 并发管理器
data ConcurrencyManager = ConcurrencyManager 
    { activeThreads :: Map ThreadId ThreadInfo
    , nextThreadId :: ThreadId
    , scheduler :: Scheduler
    }

-- 调度器
data Scheduler = RoundRobin | Priority | Fair
  deriving (Show, Eq)

-- 创建并发系统
newConcurrencyManager :: ConcurrencyManager
newConcurrencyManager = ConcurrencyManager 
    { activeThreads = empty
    , nextThreadId = 1
    , scheduler = RoundRobin
    }
```

## 2. 轻量级线程

### 数学定义

轻量级线程是一个执行单元：

$$\text{Thread} = (\text{id}, \text{state}, \text{action}, \text{context})$$

其中：
- $\text{id}$ 是线程标识符
- $\text{state}$ 是线程状态
- $\text{action}$ 是线程执行的动作
- $\text{context}$ 是线程上下文

### Haskell实现

```haskell
-- 导入并发模块
import Control.Concurrent
import Control.Monad
import System.IO.Unsafe

-- 线程创建
createThread :: IO () -> IO ThreadId
createThread action = forkIO action

-- 线程等待
waitForThread :: ThreadId -> IO ()
waitForThread tid = do
    result <- waitForThreadResult tid
    case result of
        Just _ -> return ()
        Nothing -> waitForThread tid

-- 线程结果
waitForThreadResult :: ThreadId -> IO (Maybe ())
waitForThreadResult tid = do
    -- 简化实现，实际使用MVar或TVar
    return Nothing

-- 线程取消
cancelThread :: ThreadId -> IO ()
cancelThread tid = killThread tid

-- 线程延迟
threadDelay :: Int -> IO ()
threadDelay microseconds = 
    Control.Concurrent.threadDelay microseconds

-- 示例：并发计算
concurrentComputation :: IO [Int]
concurrentComputation = do
    -- 创建多个线程进行并发计算
    t1 <- forkIO (computeTask 1)
    t2 <- forkIO (computeTask 2)
    t3 <- forkIO (computeTask 3)
    
    -- 等待所有线程完成
    waitForThread t1
    waitForThread t2
    waitForThread t3
    
    return [1, 2, 3]  -- 简化返回

-- 计算任务
computeTask :: Int -> IO ()
computeTask n = do
    putStrLn $ "Computing task " ++ show n
    threadDelay (n * 1000000)  -- 模拟计算时间
    putStrLn $ "Task " ++ show n ++ " completed"

-- 线程池
data ThreadPool = ThreadPool 
    { poolSize :: Int
    , workers :: [ThreadId]
    , taskQueue :: MVar [IO ()]
    }

-- 创建线程池
newThreadPool :: Int -> IO ThreadPool
newThreadPool size = do
    queue <- newMVar []
    workers <- replicateM size (forkIO (worker queue))
    return $ ThreadPool size workers queue

-- 工作线程
worker :: MVar [IO ()] -> IO ()
worker queue = forever $ do
    tasks <- takeMVar queue
    case tasks of
        [] -> putMVar queue []
        (task:tasks') -> do
            putMVar queue tasks'
            task

-- 提交任务到线程池
submitTask :: ThreadPool -> IO () -> IO ()
submitTask pool task = do
    tasks <- takeMVar (taskQueue pool)
    putMVar (taskQueue pool) (tasks ++ [task])
```

## 3. 软件事务内存 (STM)

### 数学定义

STM事务是一个原子操作序列：

$$\text{STMTransaction} = [\text{STMOperation}]$$

其中STM操作包括：
- $\text{read}(v)$ - 读取变量 $v$
- $\text{write}(v, x)$ - 写入值 $x$ 到变量 $v$

事务满足ACID性质：
- **原子性** (Atomicity)
- **一致性** (Consistency)
- **隔离性** (Isolation)
- **持久性** (Durability)

### Haskell实现

```haskell
-- 导入STM模块
import Control.Concurrent.STM
import Control.Monad.STM

-- TVar (Transactional Variable)
-- 创建TVar
newTVar :: a -> STM (TVar a)
newTVar = STM.newTVar

-- 读取TVar
readTVar :: TVar a -> STM a
readTVar = STM.readTVar

-- 写入TVar
writeTVar :: TVar a -> a -> STM ()
writeTVar = STM.writeTVar

-- 原子执行STM事务
atomically :: STM a -> IO a
atomically = STM.atomically

-- 银行账户示例
data BankAccount = BankAccount 
    { accountId :: String
    , balance :: TVar Double
    }

-- 创建账户
newAccount :: String -> Double -> STM BankAccount
newAccount id initialBalance = do
    bal <- newTVar initialBalance
    return $ BankAccount id bal

-- 存款
deposit :: BankAccount -> Double -> STM ()
deposit account amount = do
    currentBalance <- readTVar (balance account)
    writeTVar (balance account) (currentBalance + amount)

-- 取款
withdraw :: BankAccount -> Double -> STM Bool
withdraw account amount = do
    currentBalance <- readTVar (balance account)
    if currentBalance >= amount
        then do
            writeTVar (balance account) (currentBalance - amount)
            return True
        else return False

-- 转账
transfer :: BankAccount -> BankAccount -> Double -> STM Bool
transfer from to amount = do
    success <- withdraw from amount
    if success
        then do
            deposit to amount
            return True
        else return False

-- 账户余额查询
getBalance :: BankAccount -> STM Double
getBalance account = readTVar (balance account)

-- 并发转账示例
concurrentTransfer :: IO ()
concurrentTransfer = do
    -- 创建账户
    account1 <- atomically $ newAccount "A1" 1000.0
    account2 <- atomically $ newAccount "A2" 500.0
    
    -- 并发转账
    t1 <- forkIO $ do
        success <- atomically $ transfer account1 account2 200.0
        putStrLn $ "Transfer 1: " ++ show success
    
    t2 <- forkIO $ do
        success <- atomically $ transfer account2 account1 100.0
        putStrLn $ "Transfer 2: " ++ show success
    
    -- 等待完成
    waitForThread t1
    waitForThread t2
    
    -- 查看最终余额
    bal1 <- atomically $ getBalance account1
    bal2 <- atomically $ getBalance account2
    putStrLn $ "Final balances: A1=" ++ show bal1 ++ ", A2=" ++ show bal2
```

## 4. 同步机制

### 数学定义

同步机制确保线程间的协调：

$$\text{SyncMechanism} = (\text{condition}, \text{action}, \text{wait}, \text{signal})$$

其中：
- $\text{condition}$ 是同步条件
- $\text{action}$ 是同步动作
- $\text{wait}$ 是等待操作
- $\text{signal}$ 是信号操作

### Haskell实现

```haskell
-- MVar (Mutable Variable)
-- 创建空MVar
newEmptyMVar :: IO (MVar a)
newEmptyMVar = Control.Concurrent.newEmptyMVar

-- 创建带值的MVar
newMVar :: a -> IO (MVar a)
newMVar = Control.Concurrent.newMVar

-- 从MVar取值
takeMVar :: MVar a -> IO a
takeMVar = Control.Concurrent.takeMVar

-- 向MVar放值
putMVar :: MVar a -> a -> IO ()
putMVar = Control.Concurrent.putMVar

-- 读取MVar（不取出）
readMVar :: MVar a -> IO a
readMVar = Control.Concurrent.readMVar

-- 生产者-消费者模式
data ProducerConsumer a = ProducerConsumer 
    { buffer :: MVar [a]
    , maxSize :: Int
    }

-- 创建生产者-消费者
newProducerConsumer :: Int -> IO (ProducerConsumer a)
newProducerConsumer size = do
    buf <- newMVar []
    return $ ProducerConsumer buf size

-- 生产者
producer :: ProducerConsumer Int -> IO ()
producer pc = forever $ do
    item <- generateItem
    produce pc item
    threadDelay 1000000  -- 1秒

-- 消费者
consumer :: ProducerConsumer Int -> IO ()
consumer pc = forever $ do
    item <- consume pc
    processItem item
    threadDelay 500000   -- 0.5秒

-- 生产项目
produce :: ProducerConsumer a -> a -> IO ()
produce pc item = do
    items <- takeMVar (buffer pc)
    if length items < maxSize pc
        then putMVar (buffer pc) (items ++ [item])
        else do
            putMVar (buffer pc) items
            threadDelay 100000  -- 等待空间

-- 消费项目
consume :: ProducerConsumer a -> IO a
consume pc = do
    items <- takeMVar (buffer pc)
    case items of
        [] -> do
            putMVar (buffer pc) []
            threadDelay 100000  -- 等待项目
            consume pc
        (item:rest) -> do
            putMVar (buffer pc) rest
            return item

-- 生成项目
generateItem :: IO Int
generateItem = do
    -- 模拟生成项目
    return $ unsafePerformIO $ randomRIO (1, 100)

-- 处理项目
processItem :: Int -> IO ()
processItem item = do
    putStrLn $ "Processing item: " ++ show item

-- 信号量
data Semaphore = Semaphore (MVar Int)

-- 创建信号量
newSemaphore :: Int -> IO Semaphore
newSemaphore initial = do
    mv <- newMVar initial
    return $ Semaphore mv

-- 获取信号量
acquire :: Semaphore -> IO ()
acquire (Semaphore mv) = do
    count <- takeMVar mv
    if count > 0
        then putMVar mv (count - 1)
        else do
            putMVar mv count
            threadDelay 10000
            acquire (Semaphore mv)

-- 释放信号量
release :: Semaphore -> IO ()
release (Semaphore mv) = do
    count <- takeMVar mv
    putMVar mv (count + 1)

-- 读写锁
data ReadWriteLock = ReadWriteLock 
    { readers :: MVar Int
    , writers :: MVar Int
    , writeLock :: MVar ()
    }

-- 创建读写锁
newReadWriteLock :: IO ReadWriteLock
newReadWriteLock = do
    r <- newMVar 0
    w <- newMVar 0
    wl <- newMVar ()
    return $ ReadWriteLock r w wl

-- 获取读锁
acquireReadLock :: ReadWriteLock -> IO ()
acquireReadLock lock = do
    writers <- readMVar (writers lock)
    if writers > 0
        then do
            threadDelay 1000
            acquireReadLock lock
        else do
            readers <- takeMVar (readers lock)
            putMVar (readers lock) (readers + 1)

-- 释放读锁
releaseReadLock :: ReadWriteLock -> IO ()
releaseReadLock lock = do
    readers <- takeMVar (readers lock)
    putMVar (readers lock) (readers - 1)

-- 获取写锁
acquireWriteLock :: ReadWriteLock -> IO ()
acquireWriteLock lock = do
    writers <- takeMVar (writers lock)
    putMVar (writers lock) (writers + 1)
    
    readers <- readMVar (readers lock)
    if readers > 0
        then do
            threadDelay 1000
            acquireWriteLock lock
        else return ()

-- 释放写锁
releaseWriteLock :: ReadWriteLock -> IO ()
releaseWriteLock lock = do
    writers <- takeMVar (writers lock)
    putMVar (writers lock) (writers - 1)
```

## 5. 异步编程

### 数学定义

异步操作是一个非阻塞的计算：

$$\text{AsyncOperation} = (\text{input}, \text{computation}, \text{callback})$$

其中：
- $\text{input}$ 是输入参数
- $\text{computation}$ 是计算函数
- $\text{callback}$ 是完成回调

### Haskell实现

```haskell
-- 导入异步模块
import Control.Concurrent.Async
import Control.Exception

-- 异步执行
async :: IO a -> IO (Async a)
async = Control.Concurrent.Async.async

-- 等待异步操作完成
wait :: Async a -> IO a
wait = Control.Concurrent.Async.wait

-- 取消异步操作
cancel :: Async a -> IO ()
cancel = Control.Concurrent.Async.cancel

-- 并发执行多个操作
concurrently :: IO a -> IO b -> IO (a, b)
concurrently = Control.Concurrent.Async.concurrently

-- 并发执行列表操作
mapConcurrently :: Traversable t => (a -> IO b) -> t a -> IO (t b)
mapConcurrently = Control.Concurrent.Async.mapConcurrently

-- 异步计算示例
asyncComputation :: IO [Int]
asyncComputation = do
    -- 创建多个异步任务
    a1 <- async $ computeAsync 1
    a2 <- async $ computeAsync 2
    a3 <- async $ computeAsync 3
    
    -- 等待所有任务完成
    r1 <- wait a1
    r2 <- wait a2
    r3 <- wait a3
    
    return [r1, r2, r3]

-- 异步计算任务
computeAsync :: Int -> IO Int
computeAsync n = do
    putStrLn $ "Starting async computation " ++ show n
    threadDelay (n * 1000000)  -- 模拟计算时间
    putStrLn $ "Completed async computation " ++ show n
    return (n * n)

-- 并发HTTP请求示例
concurrentHttpRequests :: [String] -> IO [String]
concurrentHttpRequests urls = do
    results <- mapConcurrently fetchUrl urls
    return results

-- 模拟HTTP请求
fetchUrl :: String -> IO String
fetchUrl url = do
    putStrLn $ "Fetching: " ++ url
    threadDelay (randomRIO (100000, 500000))  -- 随机延迟
    return $ "Response from " ++ url

-- 异步异常处理
asyncWithException :: IO a -> IO (Either SomeException a)
asyncWithException action = do
    a <- async action
    try $ wait a

-- 超时处理
withTimeout :: Int -> IO a -> IO (Maybe a)
withTimeout microseconds action = do
    a <- async action
    result <- race (wait a) (threadDelay microseconds)
    case result of
        Left value -> return $ Just value
        Right _ -> do
            cancel a
            return Nothing

-- 异步管道
data AsyncPipe a b = AsyncPipe 
    { input :: MVar a
    , output :: MVar b
    , processor :: a -> IO b
    }

-- 创建异步管道
newAsyncPipe :: (a -> IO b) -> IO (AsyncPipe a b)
newAsyncPipe processor = do
    input <- newEmptyMVar
    output <- newEmptyMVar
    return $ AsyncPipe input output processor

-- 启动管道处理
startPipe :: AsyncPipe a b -> IO (Async ())
startPipe pipe = async $ pipeWorker pipe

-- 管道工作线程
pipeWorker :: AsyncPipe a b -> IO ()
pipeWorker pipe = forever $ do
    item <- takeMVar (input pipe)
    result <- processor pipe item
    putMVar (output pipe) result

-- 发送数据到管道
sendToPipe :: AsyncPipe a b -> a -> IO ()
sendToPipe pipe item = putMVar (input pipe) item

-- 从管道接收数据
receiveFromPipe :: AsyncPipe a b -> IO b
receiveFromPipe pipe = takeMVar (output pipe)
```

## 6. 形式化性质

### 定理 6.1 (STM原子性)

对于任意STM事务 $T$，如果 $T$ 成功提交，则 $T$ 的所有操作都是原子执行的。

**证明**：
通过STM的实现机制，事务要么完全执行，要么完全不执行，保证了原子性。

### 定理 6.2 (死锁避免)

如果所有线程都按照相同的顺序获取锁，则不会发生死锁。

**证明**：
通过归纳法证明，如果线程按顺序获取锁，则不会形成循环等待。

## 总结

本文档介绍了Haskell并发编程的基础概念：

1. **并发模型**：形式化的并发系统定义
2. **轻量级线程**：高效的线程管理
3. **软件事务内存**：原子事务操作
4. **同步机制**：线程间协调
5. **异步编程**：非阻塞并发操作

每个概念都包含：
- 严格的数学定义
- 完整的Haskell实现
- 形式化性质证明
- 实际应用示例

这些基础为构建高性能、可靠的并发应用程序提供了坚实的基础。

---

**相关主题**：

- [线程管理](线程管理.md)
- [同步机制](同步机制.md)
- [异步编程](异步编程.md)
- [STM系统](../04-Type-System/高级类型.md)
