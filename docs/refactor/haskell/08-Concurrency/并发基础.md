# Haskell 并发基础 (Concurrency Basics)

## 概述

Haskell的并发编程基于函数式编程的数学基础，提供了类型安全、可组合的并发抽象。并发模型基于范畴论和代数结构，将并发计算形式化为数学对象。

## 数学基础

### 并发计算的形式化定义

在范畴论中，并发计算可以定义为：

$$\text{Concurrent}(A) = \text{IO}(A) \times \text{Time} \times \text{Space}$$

其中：
- $\text{IO}(A)$ 是输入输出操作
- $\text{Time}$ 是时间维度
- $\text{Space}$ 是空间维度

### 并发关系

两个并发计算 $C_1$ 和 $C_2$ 的关系可以定义为：

$$C_1 \parallel C_2 = \text{Par}(C_1, C_2)$$

其中 $\text{Par}$ 表示并行组合。

## 基本并发原语

### 1. IO单子 (IO Monad)

#### 数学定义

IO单子是处理副作用的基本抽象：

$$\text{IO}(A) = \text{World} \rightarrow (A, \text{World})$$

其中 $\text{World}$ 表示外部世界的状态。

#### Haskell实现

```haskell
-- IO单子的基本操作
basicIO :: IO String
basicIO = do
    putStrLn "Hello, World!"
    return "Done"

-- 数学表示：$\text{basicIO}: \text{IO}(\text{String})$

-- IO单子的组合
composeIO :: IO Int -> IO String -> IO String
composeIO io1 io2 = do
    result1 <- io1
    result2 <- io2
    return (show result1 ++ " " ++ result2)

-- 数学表示：$\text{composeIO}: \text{IO}(\text{Int}) \rightarrow \text{IO}(\text{String}) \rightarrow \text{IO}(\text{String})$
```

### 2. 线程 (Threads)

#### 数学定义

线程是并发执行的基本单位：

$$\text{Thread}(A) = \text{IO}(A) \times \text{ThreadId}$$

其中 $\text{ThreadId}$ 是线程标识符。

#### Haskell实现

```haskell
-- 线程创建
import Control.Concurrent

-- 创建线程
createThread :: IO () -> IO ThreadId
createThread action = forkIO action

-- 数学表示：$\text{createThread}: \text{IO}() \rightarrow \text{IO}(\text{ThreadId})$

-- 线程示例
threadExample :: IO ()
threadExample = do
    tid1 <- forkIO (putStrLn "Thread 1")
    tid2 <- forkIO (putStrLn "Thread 2")
    putStrLn "Main thread"
    
-- 数学表示：$\text{threadExample} = \text{forkIO}(\text{putStrLn}(\text{"Thread 1"})) \parallel \text{forkIO}(\text{putStrLn}(\text{"Thread 2"})) \parallel \text{putStrLn}(\text{"Main thread"})$
```

### 3. MVar (Mutable Variable)

#### 数学定义

MVar是线程间通信的基本原语：

$$\text{MVar}(A) = \text{Maybe}(A) \times \text{Queue}(\text{ThreadId})$$

其中 $\text{Queue}(\text{ThreadId})$ 是等待队列。

#### Haskell实现

```haskell
-- MVar操作
mvarExample :: IO ()
mvarExample = do
    mvar <- newEmptyMVar
    forkIO $ do
        putStrLn "Producer: putting value"
        putMVar mvar "Hello from producer"
    forkIO $ do
        putStrLn "Consumer: waiting for value"
        value <- takeMVar mvar
        putStrLn ("Consumer: got " ++ value)

-- 数学表示：
-- $\text{mvarExample} = \text{newEmptyMVar} \gg= \lambda m. \text{forkIO}(\text{putMVar}(m, \text{"Hello"})) \parallel \text{forkIO}(\text{takeMVar}(m))$
```

## 高级并发抽象

### 1. 软件事务内存 (STM)

#### 数学定义

STM提供了原子事务的抽象：

$$\text{STM}(A) = \text{Transaction}(\text{IO}(A))$$

其中 $\text{Transaction}$ 表示事务上下文。

#### Haskell实现

```haskell
-- STM基本操作
import Control.Concurrent.STM

-- STM变量
stmExample :: IO ()
stmExample = do
    account1 <- newTVarIO 100
    account2 <- newTVarIO 200
    
    atomically $ do
        balance1 <- readTVar account1
        balance2 <- readTVar account2
        writeTVar account1 (balance1 - 50)
        writeTVar account2 (balance2 + 50)

-- 数学表示：
-- $\text{stmExample} = \text{atomically}(\text{readTVar}(a_1) \gg= \lambda b_1. \text{readTVar}(a_2) \gg= \lambda b_2. \text{writeTVar}(a_1, b_1 - 50) \gg \text{writeTVar}(a_2, b_2 + 50))$
```

### 2. 异步计算 (Async)

#### 数学定义

异步计算是并发计算的抽象：

$$\text{Async}(A) = \text{IO}(A) \times \text{Future}(A)$$

其中 $\text{Future}(A)$ 表示未来的计算结果。

#### Haskell实现

```haskell
-- 异步计算
import Control.Concurrent.Async

-- 异步操作
asyncExample :: IO ()
asyncExample = do
    async1 <- async (return "Result 1")
    async2 <- async (return "Result 2")
    
    result1 <- wait async1
    result2 <- wait async2
    
    putStrLn (result1 ++ " " ++ result2)

-- 数学表示：
-- $\text{asyncExample} = \text{async}(\text{return}(\text{"Result 1"})) \parallel \text{async}(\text{return}(\text{"Result 2"})) \gg= \lambda r_1. \text{wait}(r_1) \gg= \lambda r_2. \text{wait}(r_2)$
```

### 3. 通道 (Channels)

#### 数学定义

通道是消息传递的抽象：

$$\text{Channel}(A) = \text{Queue}(A) \times \text{MVar}(\text{Queue}(A))$$

#### Haskell实现

```haskell
-- 通道操作
import Control.Concurrent.Chan

-- 通道示例
channelExample :: IO ()
channelExample = do
    chan <- newChan
    forkIO $ do
        writeChan chan "Message 1"
        writeChan chan "Message 2"
    forkIO $ do
        msg1 <- readChan chan
        msg2 <- readChan chan
        putStrLn (msg1 ++ " " ++ msg2)

-- 数学表示：
-- $\text{channelExample} = \text{newChan} \gg= \lambda c. \text{forkIO}(\text{writeChan}(c, \text{"Message 1"}) \gg \text{writeChan}(c, \text{"Message 2"})) \parallel \text{forkIO}(\text{readChan}(c) \gg= \lambda m_1. \text{readChan}(c) \gg= \lambda m_2. \text{putStrLn}(m_1 \cdot m_2))$
```

## 并发模式

### 1. 生产者-消费者模式

#### 数学定义

生产者-消费者模式可以形式化为：

$$\text{ProducerConsumer} = \text{Producer} \parallel \text{Consumer} \parallel \text{Buffer}$$

#### Haskell实现

```haskell
-- 生产者-消费者模式
producerConsumer :: IO ()
producerConsumer = do
    buffer <- newChan
    
    -- 生产者
    forkIO $ producer buffer
    
    -- 消费者
    forkIO $ consumer buffer
    
    threadDelay 1000000  -- 运行1秒

producer :: Chan Int -> IO ()
producer buffer = do
    mapM_ (\i -> writeChan buffer i >> threadDelay 100000) [1..10]

consumer :: Chan Int -> IO ()
consumer buffer = do
    forever $ do
        item <- readChan buffer
        putStrLn ("Consumed: " ++ show item)

-- 数学表示：
-- $\text{producerConsumer} = \text{newChan} \gg= \lambda b. \text{forkIO}(\text{producer}(b)) \parallel \text{forkIO}(\text{consumer}(b))$
```

### 2. 工作池模式

#### 数学定义

工作池模式可以形式化为：

$$\text{WorkerPool} = \text{TaskQueue} \parallel \text{Worker}_1 \parallel \cdots \parallel \text{Worker}_n$$

#### Haskell实现

```haskell
-- 工作池模式
workerPool :: Int -> IO ()
workerPool numWorkers = do
    taskQueue <- newChan
    resultQueue <- newChan
    
    -- 创建工作线程
    mapM_ (\i -> forkIO (worker i taskQueue resultQueue)) [1..numWorkers]
    
    -- 提交任务
    mapM_ (\i -> writeChan taskQueue i) [1..20]
    
    -- 收集结果
    results <- replicateM 20 (readChan resultQueue)
    putStrLn ("Results: " ++ show results)

worker :: Int -> Chan Int -> Chan Int -> IO ()
worker id taskQueue resultQueue = forever $ do
    task <- readChan taskQueue
    let result = task * task  -- 计算平方
    writeChan resultQueue result
    putStrLn ("Worker " ++ show id ++ " processed task " ++ show task)

-- 数学表示：
-- $\text{workerPool}(n) = \text{newChan} \gg= \lambda t. \text{newChan} \gg= \lambda r. \prod_{i=1}^{n} \text{forkIO}(\text{worker}(i, t, r))$
```

### 3. 屏障同步模式

#### 数学定义

屏障同步可以形式化为：

$$\text{Barrier} = \text{CountDownLatch}(n)$$

其中 $n$ 是参与同步的线程数。

#### Haskell实现

```haskell
-- 屏障同步
barrierSync :: Int -> IO ()
barrierSync numThreads = do
    barrier <- newEmptyMVar
    
    -- 创建工作线程
    mapM_ (\i -> forkIO (workerWithBarrier i barrier)) [1..numThreads]
    
    -- 等待所有线程完成
    replicateM_ numThreads (takeMVar barrier)
    putStrLn "All threads completed!"

workerWithBarrier :: Int -> MVar () -> IO ()
workerWithBarrier id barrier = do
    putStrLn ("Worker " ++ show id ++ " starting")
    threadDelay (id * 100000)  -- 模拟工作
    putStrLn ("Worker " ++ show id ++ " completed")
    putMVar barrier ()  -- 通知完成

-- 数学表示：
-- $\text{barrierSync}(n) = \text{newEmptyMVar} \gg= \lambda b. \prod_{i=1}^{n} \text{forkIO}(\text{workerWithBarrier}(i, b)) \gg \prod_{i=1}^{n} \text{takeMVar}(b)$
```

## 并发安全

### 1. 数据竞争检测

```haskell
-- 数据竞争示例
dataRaceExample :: IO ()
dataRaceExample = do
    sharedVar <- newMVar 0
    
    -- 两个线程同时修改共享变量
    forkIO $ do
        value <- takeMVar sharedVar
        putMVar sharedVar (value + 1)
    
    forkIO $ do
        value <- takeMVar sharedVar
        putMVar sharedVar (value + 1)
    
    -- 使用STM避免数据竞争
    stmVar <- newTVarIO 0
    
    atomically $ do
        value <- readTVar stmVar
        writeTVar stmVar (value + 1)

-- 数学表示：
-- $\text{dataRaceExample} = \text{newMVar}(0) \gg= \lambda v. \text{forkIO}(\text{takeMVar}(v) \gg= \lambda x. \text{putMVar}(v, x + 1)) \parallel \text{forkIO}(\text{takeMVar}(v) \gg= \lambda x. \text{putMVar}(v, x + 1))$
```

### 2. 死锁预防

```haskell
-- 死锁预防
deadlockPrevention :: IO ()
deadlockPrevention = do
    lock1 <- newMVar ()
    lock2 <- newMVar ()
    
    -- 使用一致的锁顺序避免死锁
    forkIO $ do
        takeMVar lock1
        takeMVar lock2
        putStrLn "Thread 1: acquired both locks"
        putMVar lock2 ()
        putMVar lock1 ()
    
    forkIO $ do
        takeMVar lock1  -- 相同的顺序
        takeMVar lock2
        putStrLn "Thread 2: acquired both locks"
        putMVar lock2 ()
        putMVar lock1 ()

-- 数学表示：
-- $\text{deadlockPrevention} = \text{newMVar}() \gg= \lambda l_1. \text{newMVar}() \gg= \lambda l_2. \text{forkIO}(\text{takeMVar}(l_1) \gg \text{takeMVar}(l_2)) \parallel \text{forkIO}(\text{takeMVar}(l_1) \gg \text{takeMVar}(l_2))$
```

## 性能优化

### 1. 线程池

```haskell
-- 线程池实现
data ThreadPool = ThreadPool 
    { taskQueue :: Chan (IO ())
    , workers :: [ThreadId]
    }

createThreadPool :: Int -> IO ThreadPool
createThreadPool numWorkers = do
    queue <- newChan
    workers <- replicateM numWorkers (forkIO (worker queue))
    return (ThreadPool queue workers)

worker :: Chan (IO ()) -> IO ()
worker queue = forever $ do
    task <- readChan queue
    task

submitTask :: ThreadPool -> IO () -> IO ()
submitTask pool task = writeChan (taskQueue pool) task

-- 数学表示：
-- $\text{createThreadPool}(n) = \text{newChan} \gg= \lambda q. \prod_{i=1}^{n} \text{forkIO}(\text{worker}(q)) \gg= \lambda w. \text{return}(\text{ThreadPool}(q, w))$
```

### 2. 负载均衡

```haskell
-- 负载均衡
loadBalancer :: Int -> IO ()
loadBalancer numWorkers = do
    taskQueue <- newChan
    resultQueue <- newChan
    
    -- 创建工作线程
    mapM_ (\i -> forkIO (balancedWorker i taskQueue resultQueue)) [1..numWorkers]
    
    -- 提交任务
    mapM_ (\i -> writeChan taskQueue i) [1..100]
    
    -- 收集结果
    results <- replicateM 100 (readChan resultQueue)
    putStrLn ("Processed " ++ show (length results) ++ " tasks")

balancedWorker :: Int -> Chan Int -> Chan Int -> IO ()
balancedWorker id taskQueue resultQueue = forever $ do
    task <- readChan taskQueue
    let result = processTask task
    writeChan resultQueue result
    putStrLn ("Worker " ++ show id ++ " processed task " ++ show task)

processTask :: Int -> Int
processTask n = n * n

-- 数学表示：
-- $\text{loadBalancer}(n) = \text{newChan} \gg= \lambda t. \text{newChan} \gg= \lambda r. \prod_{i=1}^{n} \text{forkIO}(\text{balancedWorker}(i, t, r))$
```

## 总结

Haskell的并发编程提供了：

1. **数学基础**：基于范畴论和代数结构
2. **类型安全**：编译时检查并发安全
3. **函数式特性**：不可变性和引用透明性
4. **高级抽象**：STM、Async、Channels等
5. **性能优化**：线程池、负载均衡等

并发编程体现了函数式编程的数学本质，将并发计算形式化为数学对象，使得并发代码既安全又高效。

---

**相关主题**：
- [线程管理](线程管理.md)
- [同步机制](同步机制.md)
- [异步编程](异步编程.md)
- [STM系统](../04-Type-System/高级类型.md) 