# Haskell 函数式设计模式 (Functional Design Patterns)

## 概述

函数式设计模式是函数式编程中的核心概念，它们提供了可重用、可组合的抽象。这些模式基于数学理论，特别是范畴论和抽象代数，为构建健壮、可维护的软件提供了理论基础。

## 数学定义

### 设计模式的形式化定义

设计模式可以形式化为一个三元组：

$$\text{Pattern} = (P, C, I)$$

其中：
- $P$ 是问题空间
- $C$ 是解决方案的约束条件
- $I$ 是实现的接口

### 模式组合的代数结构

对于模式 $P_1$ 和 $P_2$，它们的组合定义为：

$$P_1 \circ P_2 = (P_1.P \cap P_2.P, P_1.C \cup P_2.C, P_1.I \otimes P_2.I)$$

其中 $\otimes$ 表示接口的组合操作。

## 核心函数式模式

### 1. 函子模式 (Functor Pattern)

```haskell
-- 函子模式定义
class Functor f where
    fmap :: (a -> b) -> f a -> f b
    
    -- 函子定律
    -- fmap id = id
    -- fmap (f . g) = fmap f . fmap g

-- 数学定义：函子是范畴之间的协变函子
-- fmap : (a → b) → f a → f b

-- 列表函子实例
instance Functor [] where
    fmap = map

-- Maybe 函子实例
instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)

-- 自定义函子
data Tree a = Leaf a | Node (Tree a) (Tree a)

instance Functor Tree where
    fmap f (Leaf x) = Leaf (f x)
    fmap f (Node left right) = Node (fmap f left) (fmap f right)

-- 函子模式的应用
processData :: Functor f => f Int -> f String
processData = fmap show . fmap (+1)

-- 测试
main :: IO ()
main = do
    print $ processData [1, 2, 3]        -- ["2", "3", "4"]
    print $ processData (Just 5)         -- Just "6"
    print $ processData (Leaf 10)        -- Leaf "11"
```

### 2. 应用函子模式 (Applicative Pattern)

```haskell
-- 应用函子模式定义
class Functor f => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
    
    -- 应用函子定律
    -- pure id <*> v = v
    -- pure f <*> pure x = pure (f x)
    -- u <*> pure y = pure ($ y) <*> u
    -- pure (.) <*> u <*> v <*> w = u <*> (v <*> w)

-- 数学定义：应用函子是强单子函子
-- pure : a → f a
-- (<*>) : f (a → b) → f a → f b

-- Maybe 应用函子实例
instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    (Just f) <*> x = fmap f x

-- 列表应用函子实例
instance Applicative [] where
    pure x = [x]
    fs <*> xs = [f x | f <- fs, x <- xs]

-- 应用函子模式的应用
combineData :: Applicative f => f Int -> f Int -> f Int
combineData = liftA2 (+)

validateForm :: Applicative f => f String -> f String -> f String
validateForm name email = pure formatUser <*> name <*> email
  where
    formatUser n e = "User: " ++ n ++ " <" ++ e ++ ">"

-- 测试
main :: IO ()
main = do
    print $ combineData (Just 3) (Just 4)           -- Just 7
    print $ combineData [1, 2] [10, 20]             -- [11, 21, 12, 22]
    print $ validateForm (Just "Alice") (Just "alice@example.com")
    -- Just "User: Alice <alice@example.com>"
```

### 3. 单子模式 (Monad Pattern)

```haskell
-- 单子模式定义
class Applicative m => Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    return :: a -> m a
    
    -- 单子定律
    -- return a >>= f = f a
    -- m >>= return = m
    -- (m >>= f) >>= g = m >>= (\x -> f x >>= g)

-- 数学定义：单子是范畴论中的单子
-- (>>=) : m a → (a → m b) → m b
-- return : a → m a

-- Maybe 单子实例
instance Monad Maybe where
    return = Just
    Nothing >>= _ = Nothing
    (Just x) >>= f = f x

-- 列表单子实例
instance Monad [] where
    return x = [x]
    xs >>= f = concat (map f xs)

-- 单子模式的应用
safeDivision :: Double -> Double -> Maybe Double
safeDivision _ 0 = Nothing
safeDivision x y = Just (x / y)

complexCalculation :: Double -> Double -> Maybe Double
complexCalculation x y = do
    result1 <- safeDivision x y
    result2 <- safeDivision result1 2
    return (result2 * 3)

-- 列表推导的单子模式
pythagoreanTriples :: [(Int, Int, Int)]
pythagoreanTriples = do
    a <- [1..10]
    b <- [a..10]
    c <- [b..10]
    guard (a^2 + b^2 == c^2)
    return (a, b, c)

-- 测试
main :: IO ()
main = do
    print $ complexCalculation 10 2  -- Just 7.5
    print $ complexCalculation 10 0  -- Nothing
    print $ take 3 pythagoreanTriples  -- [(3,4,5), (5,12,13), (6,8,10)]
```

### 4. 折叠模式 (Fold Pattern)

```haskell
-- 折叠模式定义
class Foldable t where
    foldMap :: Monoid m => (a -> m) -> t a -> m
    foldr :: (a -> b -> b) -> b -> t a -> b
    
    -- 默认实现
    foldMap f = foldr (\x acc -> f x `mappend` acc) mempty
    foldr f z = foldMap (Endo . f) `appEndo` z

-- 数学定义：折叠是代数数据类型的消除器
-- foldr : (a → b → b) → b → t a → b

-- 列表折叠实例
instance Foldable [] where
    foldr = foldr

-- 树折叠实例
instance Foldable Tree where
    foldr f z (Leaf x) = f x z
    foldr f z (Node left right) = foldr f (foldr f z right) left

-- 折叠模式的应用
sumTree :: Num a => Tree a -> a
sumTree = foldr (+) 0

productTree :: Num a => Tree a -> a
productTree = foldr (*) 1

toListTree :: Tree a -> [a]
toListTree = foldr (:) []

-- 通用折叠函数
foldPattern :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldPattern = foldr

-- 测试
main :: IO ()
main = do
    let tree = Node (Leaf 1) (Node (Leaf 2) (Leaf 3))
    print $ sumTree tree      -- 6
    print $ productTree tree  -- 6
    print $ toListTree tree   -- [1, 2, 3]
```

### 5. 遍历模式 (Traversal Pattern)

```haskell
-- 遍历模式定义
class (Functor t, Foldable t) => Traversable t where
    traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
    sequenceA :: Applicative f => t (f a) -> f (t a)
    
    -- 默认实现
    traverse f = sequenceA . fmap f
    sequenceA = traverse id

-- 数学定义：遍历是函子和应用函子的组合
-- traverse : Applicative f => (a → f b) → t a → f (t b)

-- 列表遍历实例
instance Traversable [] where
    traverse f [] = pure []
    traverse f (x:xs) = (:) <$> f x <*> traverse f xs

-- 树遍历实例
instance Traversable Tree where
    traverse f (Leaf x) = Leaf <$> f x
    traverse f (Node left right) = Node <$> traverse f left <*> traverse f right

-- 遍历模式的应用
validateTree :: Tree String -> Maybe (Tree Int)
validateTree = traverse readMaybe

processTreeIO :: Tree Int -> IO (Tree String)
processTreeIO = traverse (\x -> putStrLn ("Processing " ++ show x) >> return (show x))

-- 测试
main :: IO ()
main = do
    let tree = Node (Leaf "1") (Node (Leaf "2") (Leaf "3"))
    print $ validateTree tree  -- Just (Node (Leaf 1) (Node (Leaf 2) (Leaf 3)))
    processTreeIO (Node (Leaf 1) (Leaf 2))
```

## 高级函数式模式

### 1. 自由单子模式 (Free Monad Pattern)

```haskell
-- 自由单子模式定义
data Free f a = Pure a | Free (f (Free f a))

-- 数学定义：自由单子是函子 f 的自由单子
-- Free f a = a + f (Free f a)

-- 自由单子实例
instance Functor f => Functor (Free f) where
    fmap f (Pure a) = Pure (f a)
    fmap f (Free fa) = Free (fmap (fmap f) fa)

instance Functor f => Applicative (Free f) where
    pure = Pure
    Pure f <*> Pure a = Pure (f a)
    Pure f <*> Free fa = Free (fmap (fmap f) fa)
    Free ff <*> a = Free (fmap (<*> a) ff)

instance Functor f => Monad (Free f) where
    return = Pure
    Pure a >>= f = f a
    Free fa >>= f = Free (fmap (>>= f) fa)

-- 自由单子模式的应用
-- 定义命令
data Command a = ReadLine (String -> a) | WriteLine String a

instance Functor Command where
    fmap f (ReadLine g) = ReadLine (f . g)
    fmap f (WriteLine s a) = WriteLine s (f a)

-- 智能构造函数
readLine :: Free Command String
readLine = Free (ReadLine Pure)

writeLine :: String -> Free Command ()
writeLine s = Free (WriteLine s (Pure ()))

-- 解释器
interpret :: Free Command a -> IO a
interpret (Pure a) = return a
interpret (Free (ReadLine f)) = do
    line <- getLine
    interpret (f line)
interpret (Free (WriteLine s a)) = do
    putStrLn s
    interpret a

-- 测试
main :: IO ()
main = do
    let program = do
        writeLine "Enter your name:"
        name <- readLine
        writeLine ("Hello, " ++ name ++ "!")
    interpret program
```

### 2. 状态单子模式 (State Monad Pattern)

```haskell
-- 状态单子模式定义
newtype State s a = State { runState :: s -> (a, s) }

-- 数学定义：状态单子是状态转换的封装
-- State s a = s → (a, s)

-- 状态单子实例
instance Functor (State s) where
    fmap f (State g) = State $ \s -> let (a, s') = g s in (f a, s')

instance Applicative (State s) where
    pure a = State $ \s -> (a, s)
    State f <*> State g = State $ \s -> 
        let (h, s') = f s
            (a, s'') = g s'
        in (h a, s'')

instance Monad (State s) where
    return = pure
    State f >>= g = State $ \s -> 
        let (a, s') = f s
            State h = g a
        in h s'

-- 状态操作
get :: State s s
get = State $ \s -> (s, s)

put :: s -> State s ()
put s = State $ \_ -> ((), s)

modify :: (s -> s) -> State s ()
modify f = State $ \s -> ((), f s)

-- 状态单子模式的应用
counter :: State Int Int
counter = do
    count <- get
    put (count + 1)
    return count

stack :: State [Int] ()
stack = do
    push 1
    push 2
    push 3
    pop
    pop

push :: Int -> State [Int] ()
push x = modify (x:)

pop :: State [Int] Int
pop = do
    (x:xs) <- get
    put xs
    return x

-- 测试
main :: IO ()
main = do
    print $ runState counter 0        -- (0, 1)
    print $ runState (replicateM 3 counter) 0  -- ([0,1,2], 3)
    print $ runState stack []         -- ((), [1])
```

### 3. 读取器单子模式 (Reader Monad Pattern)

```haskell
-- 读取器单子模式定义
newtype Reader r a = Reader { runReader :: r -> a }

-- 数学定义：读取器单子是环境依赖的计算
-- Reader r a = r → a

-- 读取器单子实例
instance Functor (Reader r) where
    fmap f (Reader g) = Reader (f . g)

instance Applicative (Reader r) where
    pure a = Reader $ \_ -> a
    Reader f <*> Reader g = Reader $ \r -> f r (g r)

instance Monad (Reader r) where
    return = pure
    Reader f >>= g = Reader $ \r -> runReader (g (f r)) r

-- 读取器操作
ask :: Reader r r
ask = Reader id

local :: (r -> r) -> Reader r a -> Reader r a
local f (Reader g) = Reader (g . f)

-- 读取器单子模式的应用
config :: Reader Config String
config = do
    env <- ask
    return $ "Database: " ++ database env ++ ", Port: " ++ show (port env)

data Config = Config 
    { database :: String
    , port :: Int
    , debug :: Bool
    }

-- 测试
main :: IO ()
main = do
    let config = Config "postgres" 5432 True
    print $ runReader config config  -- "Database: postgres, Port: 5432"
```

## 模式组合

### 1. 模式组合器

```haskell
-- 模式组合器
composePatterns :: (b -> c) -> (a -> b) -> a -> c
composePatterns = (.)

-- 模式应用器
applyPattern :: a -> (a -> b) -> b
applyPattern = flip ($)

-- 模式选择器
choosePattern :: Bool -> (a -> b) -> (a -> b) -> a -> b
choosePattern p f g x = if p then f x else g x

-- 模式组合的应用
dataProcessing :: [Int] -> [String]
dataProcessing = fmap show           -- 函子模式
               . filter even         -- 过滤模式
               . take 10             -- 限制模式

-- 测试
main :: IO ()
main = do
    let data = [1..20]
    print $ dataProcessing data  -- ["2","4","6","8","10"]
```

### 2. 模式变换器

```haskell
-- 模式变换器
transformPattern :: Functor f => (a -> b) -> f a -> f b
transformPattern = fmap

-- 模式提升
liftPattern :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftPattern = liftA2

-- 模式序列
sequencePattern :: Monad m => [m a] -> m [a]
sequencePattern = sequence

-- 模式变换器的应用
advancedProcessing :: [Maybe Int] -> Maybe [Int]
advancedProcessing = sequence  -- 模式序列

-- 测试
main :: IO ()
main = do
    let data = [Just 1, Just 2, Nothing, Just 4]
    print $ advancedProcessing data  -- Nothing
    print $ advancedProcessing [Just 1, Just 2, Just 3]  -- Just [1,2,3]
```

## 形式化验证

### 1. 模式定律验证

```haskell
import Test.QuickCheck

-- 验证函子模式定律
prop_functorIdentity :: [Int] -> Bool
prop_functorIdentity xs = fmap id xs == id xs

prop_functorComposition :: [Int] -> Bool
prop_functorComposition xs = 
    let f = (+1)
        g = (*2)
    in fmap (f . g) xs == (fmap f . fmap g) xs

-- 验证单子模式定律
prop_monadLeftIdentity :: Int -> Bool
prop_monadLeftIdentity x = 
    let f = \y -> Just (y + 1)
    in return x >>= f == f x

prop_monadRightIdentity :: Maybe Int -> Bool
prop_monadRightIdentity m = m >>= return == m

-- 测试
main :: IO ()
main = do
    quickCheck prop_functorIdentity
    quickCheck prop_functorComposition
    quickCheck prop_monadLeftIdentity
    quickCheck prop_monadRightIdentity
```

### 2. 模式组合的正确性

```haskell
-- 验证模式组合的正确性
prop_patternComposition :: [Int] -> Bool
prop_patternComposition xs = 
    let pattern1 = fmap (+1)
        pattern2 = filter even
        pattern3 = take 5
        combined = pattern3 . pattern2 . pattern1
    in length (combined xs) <= 5

-- 验证模式变换的正确性
prop_patternTransformation :: [Int] -> Bool
prop_patternTransformation xs = 
    let transform = fmap show . fmap (+1)
    in all (all isDigit) (transform xs)

-- 测试
main :: IO ()
main = do
    quickCheck prop_patternComposition
    quickCheck prop_patternTransformation
```

## 总结

函数式设计模式提供了：

1. **数学基础**：基于范畴论和抽象代数的严格理论
2. **可组合性**：模式可以自由组合和变换
3. **类型安全**：编译时检查模式使用的正确性
4. **可重用性**：模式可以在不同上下文中重用
5. **可验证性**：模式满足数学定律，可以进行形式化验证

这些模式构成了函数式编程的核心抽象，为构建健壮、可维护的软件提供了强大的工具。

---

**相关主题**：
- [函子模式](./函子模式.md)
- [单子模式](./单子模式.md)
- [应用函子模式](./应用函子模式.md)
- [高阶函数](../02-Control-Flow/高阶函数.md)
