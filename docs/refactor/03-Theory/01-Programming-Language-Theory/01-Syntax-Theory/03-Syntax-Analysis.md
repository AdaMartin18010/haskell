# 03. ËØ≠Ê≥ïÂàÜÊûêÁÆóÊ≥ï (Syntax Analysis Algorithms)

## üìã Ê¶ÇËø∞

ËØ≠Ê≥ïÂàÜÊûêÁÆóÊ≥ïÊòØÁºñËØëÂô®ÂâçÁ´ØÁöÑÈáçË¶ÅÁªÑÊàêÈÉ®ÂàÜÔºåË¥üË¥£Â∞ÜËØçÊ≥ïÂàÜÊûêÂô®ËæìÂá∫ÁöÑËØçÊ≥ïÂçïÂÖÉÂ∫èÂàóËΩ¨Êç¢‰∏∫ÊäΩË±°ËØ≠Ê≥ïÊ†ë„ÄÇÊú¨ÊñáÊ°£Ê∂µÁõñÂêÑÁßçËØ≠Ê≥ïÂàÜÊûêÁÆóÊ≥ïÁöÑËØ¶ÁªÜÂÆûÁé∞Âíå‰ºòÂåñÊäÄÊúØ„ÄÇ

## üéØ ÁÆóÊ≥ïÂàÜÁ±ª

### 1. Ëá™È°∂Âêë‰∏ãÁÆóÊ≥ï

#### 1.1 ÈÄíÂΩí‰∏ãÈôçËß£Êûê

**ÁÆóÊ≥ï 2.1** (ÈÄíÂΩí‰∏ãÈôçËß£Êûê)

```haskell
-- ÈÄíÂΩí‰∏ãÈôçËß£ÊûêÂô®Ê°ÜÊû∂
class RecursiveDescentParser a where
  -- Âü∫Êú¨Ëß£ÊûêÊñπÊ≥ï
  parseProgram :: Parser a
  parseStatement :: Parser a
  parseExpression :: Parser a
  parseTerm :: Parser a
  parseFactor :: Parser a
  
  -- ÈîôËØØÊÅ¢Â§ç
  errorRecovery :: Parser a -> Parser a
  synchronize :: Parser a
  
  -- È¢ÑÊµãËß£Êûê
  predict :: String -> Parser a
  lookahead :: Int -> Parser [String]

-- ÂÖ∑‰ΩìÂÆûÁé∞
instance RecursiveDescentParser Program where
  parseProgram = 
    do
      statements <- many parseStatement
      eof
      return $ Program statements
  
  parseStatement = 
    parseAssignment <|> parseIfStatement <|> 
    parseWhileStatement <|> parseBlock
  
  parseExpression = 
    parseLogicalOr
  
  parseTerm = 
    parseLogicalAnd
  
  parseFactor = 
    parseEquality
  
  errorRecovery parser = 
    parser <|> (synchronize *> parser)
  
  synchronize = 
    do
      tokens <- many (satisfy (not . isStatementStart))
      satisfy isStatementStart
      return ()
  
  predict token = 
    case token of
      "if" -> parseIfStatement
      "while" -> parseWhileStatement
      "{" -> parseBlock
      _ -> parseAssignment
  
  lookahead k = 
    Parser $ \input -> 
      if length input >= k
        then [(take k input, input)]
        else []

-- ËæÖÂä©ÂáΩÊï∞
isStatementStart :: String -> Bool
isStatementStart token = 
  token `elem` ["if", "while", "{", "id", "return"]

-- Á®ãÂ∫èÁªìÊûÑ
data Program = 
    Program [Statement]
  deriving (Show, Eq)

data Statement = 
    Assignment String Expression
  | IfStatement Expression Statement (Maybe Statement)
  | WhileStatement Expression Statement
  | Block [Statement]
  deriving (Show, Eq)

data Expression = 
    Variable String
  | Number Int
  | BinaryOp String Expression Expression
  | UnaryOp String Expression
  deriving (Show, Eq)
```

#### 1.2 È¢ÑÊµãËß£ÊûêÂô®

**ÁÆóÊ≥ï 2.2** (È¢ÑÊµãËß£ÊûêÂô®)

```haskell
-- È¢ÑÊµãËß£ÊûêË°®
type PredictiveParseTable = Map (String, String) [String]

-- È¢ÑÊµãËß£ÊûêÂô®
class PredictiveParser a where
  -- ÊûÑÂª∫È¢ÑÊµãË°®
  buildPredictiveTable :: a -> PredictiveParseTable
  
  -- ÊâßË°åÈ¢ÑÊµãËß£Êûê
  parse :: a -> [String] -> Maybe ParseTree
  
  -- ËÆ°ÁÆóFIRSTÂíåFOLLOWÈõÜÂêà
  computeFirst :: a -> Map String (Set String)
  computeFollow :: a -> Map String (Set String)

-- ‰∏ä‰∏ãÊñáÊó†ÂÖ≥ÊñáÊ≥ïÈ¢ÑÊµãËß£ÊûêÂô®ÂÆû‰æã
instance PredictiveParser CFG where
  buildPredictiveTable cfg = 
    let firstSets = computeFirst cfg
        followSets = computeFollow cfg firstSets
        prods = productions cfg
    in foldl (\table prod -> 
        let nt = left prod
            rhs = right prod
            first = computeFirstOfString firstSets rhs
            follow = followSets Map.! nt
            symbols = if Set.member "Œµ" first 
                       then Set.union (Set.delete "Œµ" first) follow 
                       else first
        in foldl (\t sym -> Map.insert (nt, sym) rhs t) table symbols) 
        Map.empty prods
  
  parse cfg input = 
    let table = buildPredictiveTable cfg
        initialState = ([startSymbol cfg], input, [])
    in case runPredictiveParser table initialState of
         Just (_, [], tree) -> Just tree
         _ -> Nothing
  
  computeFirst cfg = 
    let initial = Map.fromList [(nt, Set.empty) | nt <- nonterminals cfg]
        fixedPoint = iterate (updateFirst cfg) initial
    in head $ dropWhile (\m -> any (Set.null . snd) (Map.toList m)) fixedPoint
  
  computeFollow cfg firstSets = 
    let initial = Map.fromList [(nt, if nt == startSymbol cfg 
                                      then Set.singleton "$" 
                                      else Set.empty) | nt <- nonterminals cfg]
        fixedPoint = iterate (updateFollow cfg firstSets) initial
    in head $ dropWhile (\m -> any (Set.null . snd) (Map.toList m)) fixedPoint

-- ËøêË°åÈ¢ÑÊµãËß£ÊûêÂô®
runPredictiveParser :: PredictiveParseTable -> ([String], [String], [ParseTree]) -> Maybe ([String], [String], ParseTree)
runPredictiveParser table (stack, input, trees) = 
  case (stack, input) of
    ([], []) -> Just ([], [], head trees)
    ([], _) -> Nothing
    (_, []) -> Nothing
    (nt:stack', input') -> 
      if nt `elem` terminals
        then 
          if nt == head input'
            then runPredictiveParser table (stack', tail input', 
                   ParseTree nt [] (Just nt) : trees)
            else Nothing
        else 
          case Map.lookup (nt, head input') table of
            Nothing -> Nothing
            Just rhs -> 
              let newStack = rhs ++ stack'
                  newTree = ParseTree nt [] Nothing
              in runPredictiveParser table (newStack, input', newTree : trees)

-- ËÆ°ÁÆóÂ≠óÁ¨¶‰∏≤ÁöÑFIRSTÈõÜÂêà
computeFirstOfString :: Map String (Set String) -> [String] -> Set String
computeFirstOfString firstSets [] = Set.singleton "Œµ"
computeFirstOfString firstSets (sym:syms) = 
  if sym `elem` terminals
    then Set.singleton sym
    else 
      let firstSym = firstSets Map.! sym
          firstRest = computeFirstOfString firstSets syms
      in if Set.member "Œµ" firstSym
           then Set.union (Set.delete "Œµ" firstSym) firstRest
           else firstSym

-- Êõ¥Êñ∞FIRSTÈõÜÂêà
updateFirst :: CFG -> Map String (Set String) -> Map String (Set String)
updateFirst cfg firstSets = 
  foldl (\sets prod -> 
    let nt = left prod
        rhs = right prod
        first = computeFirstOfString firstSets rhs
        current = sets Map.! nt
        new = Set.union current first
    in Map.insert nt new sets) firstSets (productions cfg)

-- Êõ¥Êñ∞FOLLOWÈõÜÂêà
updateFollow :: CFG -> Map String (Set String) -> Map String (Set String) -> Map String (Set String)
updateFollow cfg firstSets followSets = 
  foldl (\sets prod -> 
    let nt = left prod
        rhs = right prod
        follow = followSets Map.! nt
        newSets = foldl (\s (i, sym) -> 
          if sym `elem` nonterminals cfg
            then 
              let beta = drop (i + 1) rhs
                  firstBeta = computeFirstOfString firstSets beta
                  followSym = s Map.! sym
                  newFollow = if Set.member "Œµ" firstBeta
                               then Set.union followSym (Set.union (Set.delete "Œµ" firstBeta) follow)
                               else Set.union followSym firstBeta
              in Map.insert sym newFollow s
            else s) sets (zip [0..] rhs)
    in newSets) followSets (productions cfg)
```

### 2. Ëá™Â∫ïÂêë‰∏äÁÆóÊ≥ï

#### 2.1 LR(0)Ëß£ÊûêÂô®

**ÁÆóÊ≥ï 2.3** (LR(0)Ëß£ÊûêÂô®)

```haskell
-- LR(0)È°πÁõÆ
data LR0Item = 
    LR0Item {
      lr0Production :: Production,
      lr0Position :: Int
    }
  deriving (Show, Eq, Ord)

-- LR(0)Áä∂ÊÄÅ
data LR0State = 
    LR0State {
      lr0Items :: Set LR0Item,
      lr0StateId :: Int
    }
  deriving (Show, Eq, Ord)

-- LR(0)Ëß£ÊûêÂô®
class LR0Parser a where
  -- ÊûÑÂª∫LR(0)Ëß£ÊûêË°®
  buildLR0ParseTable :: a -> LRParseTable
  
  -- ËÆ°ÁÆóLR(0)Èó≠ÂåÖ
  closure0 :: a -> Set LR0Item -> Set LR0Item
  
  -- ËÆ°ÁÆóLR(0) GOTO
  goto0 :: a -> Set LR0Item -> String -> Set LR0Item

-- ‰∏ä‰∏ãÊñáÊó†ÂÖ≥ÊñáÊ≥ïLR(0)Ëß£ÊûêÂô®ÂÆû‰æã
instance LR0Parser CFG where
  buildLR0ParseTable cfg = 
    let startItem = LR0Item (Production "S'" ["S"]) 0
        initialState = closure0 cfg (Set.singleton startItem)
        states = buildLR0States cfg [initialState]
        actionTable = buildLR0ActionTable cfg states
        gotoTable = buildLR0GotoTable cfg states
    in LRParseTable actionTable gotoTable
  
  closure0 cfg items = 
    let newItems = Set.unions [computeLR0Closure cfg item | item <- Set.toList items]
    in if newItems == items
         then items
         else closure0 cfg newItems
  
  goto0 cfg items symbol = 
    let nextItems = [advanceLR0Item item symbol | item <- Set.toList items, canAdvanceLR0 item symbol]
    in closure0 cfg (Set.fromList nextItems)

-- ËÆ°ÁÆóLR(0)Èó≠ÂåÖ
computeLR0Closure :: CFG -> LR0Item -> Set LR0Item
computeLR0Closure cfg item = 
  case getSymbolAfterLR0Dot item of
    Nothing -> Set.empty
    Just nt -> 
      if nt `elem` nonterminals cfg
        then 
          let prods = findProductions cfg nt
              newItems = [LR0Item prod 0 | prod <- prods]
          in Set.fromList newItems
        else Set.empty

-- Ëé∑ÂèñLR(0)ÁÇπÂêéÁöÑÁ¨¶Âè∑
getSymbolAfterLR0Dot :: LR0Item -> Maybe String
getSymbolAfterLR0Dot item = 
  let rhs = right (lr0Production item)
      pos = lr0Position item
  in if pos < length rhs
       then Just (rhs !! pos)
       else Nothing

-- Ê£ÄÊü•LR(0)È°πÁõÆÊòØÂê¶ÂèØ‰ª•ÂâçËøõ
canAdvanceLR0 :: LR0Item -> String -> Bool
canAdvanceLR0 item symbol = 
  case getSymbolAfterLR0Dot item of
    Just sym -> sym == symbol
    Nothing -> False

-- ÂâçËøõLR(0)È°πÁõÆ
advanceLR0Item :: LR0Item -> String -> LR0Item
advanceLR0Item item symbol = 
  item { lr0Position = lr0Position item + 1 }

-- ÊûÑÂª∫LR(0)Áä∂ÊÄÅ
buildLR0States :: CFG -> [Set LR0Item] -> [Set LR0Item]
buildLR0States cfg states = 
  let symbols = terminals cfg ++ nonterminals cfg
      newStates = [goto0 cfg state sym | state <- states, sym <- symbols]
      allStates = nub (states ++ newStates)
  in if length allStates == length states
       then states
       else buildLR0States cfg allStates

-- ÊûÑÂª∫LR(0)Âä®‰ΩúË°®
buildLR0ActionTable :: CFG -> [Set LR0Item] -> Map (Int, String) Action
buildLR0ActionTable cfg states = 
  let actions = [(stateId, symbol, action) | 
                 (stateId, state) <- zip [0..] states,
                 symbol <- terminals cfg,
                 action <- computeLR0Action cfg state symbol]
  in Map.fromList [(key, action) | (key, _, action) <- actions]

-- ËÆ°ÁÆóLR(0)Âä®‰Ωú
computeLR0Action :: CFG -> Set LR0Item -> String -> [Action]
computeLR0Action cfg state symbol = 
  let shiftActions = [Shift stateId | 
                      item <- Set.toList state,
                      canAdvanceLR0 item symbol]
      reduceActions = [Reduce (lr0Production item) | 
                       item <- Set.toList state,
                       isLR0Complete item]
      acceptActions = [Accept | 
                       item <- Set.toList state,
                       isLR0Complete item,
                       left (lr0Production item) == startSymbol cfg]
  in shiftActions ++ reduceActions ++ acceptActions

-- Ê£ÄÊü•LR(0)È°πÁõÆÊòØÂê¶ÂÆåÊï¥
isLR0Complete :: LR0Item -> Bool
isLR0Complete item = 
  lr0Position item >= length (right (lr0Production item))
```

#### 2.2 SLR(1)Ëß£ÊûêÂô®

**ÁÆóÊ≥ï 2.4** (SLR(1)Ëß£ÊûêÂô®)

```haskell
-- SLR(1)Ëß£ÊûêÂô®
class SLR1Parser a where
  -- ÊûÑÂª∫SLR(1)Ëß£ÊûêË°®
  buildSLR1ParseTable :: a -> LRParseTable
  
  -- ËÆ°ÁÆóSLR(1)Âä®‰Ωú
  computeSLR1Action :: a -> Set LR0Item -> String -> [Action]

-- ‰∏ä‰∏ãÊñáÊó†ÂÖ≥ÊñáÊ≥ïSLR(1)Ëß£ÊûêÂô®ÂÆû‰æã
instance SLR1Parser CFG where
  buildSLR1ParseTable cfg = 
    let startItem = LR0Item (Production "S'" ["S"]) 0
        initialState = closure0 cfg (Set.singleton startItem)
        states = buildLR0States cfg [initialState]
        actionTable = buildSLR1ActionTable cfg states
        gotoTable = buildLR0GotoTable cfg states
    in LRParseTable actionTable gotoTable
  
  computeSLR1Action cfg state symbol = 
    let firstSets = computeFirst cfg
        followSets = computeFollow cfg firstSets
        shiftActions = [Shift stateId | 
                        item <- Set.toList state,
                        canAdvanceLR0 item symbol]
        reduceActions = [Reduce (lr0Production item) | 
                         item <- Set.toList state,
                         isLR0Complete item,
                         symbol `Set.member` (followSets Map.! left (lr0Production item))]
        acceptActions = [Accept | 
                         item <- Set.toList state,
                         isLR0Complete item,
                         left (lr0Production item) == startSymbol cfg,
                         symbol == "$"]
    in shiftActions ++ reduceActions ++ acceptActions

-- ÊûÑÂª∫SLR(1)Âä®‰ΩúË°®
buildSLR1ActionTable :: CFG -> [Set LR0Item] -> Map (Int, String) Action
buildSLR1ActionTable cfg states = 
  let actions = [(stateId, symbol, action) | 
                 (stateId, state) <- zip [0..] states,
                 symbol <- terminals cfg,
                 action <- computeSLR1Action cfg state symbol]
  in Map.fromList [(key, action) | (key, _, action) <- actions]
```

### 3. ÈîôËØØÊÅ¢Â§çÁÆóÊ≥ï

#### 3.1 ÊÅêÊÖåÊ®°ÂºèÊÅ¢Â§ç

**ÁÆóÊ≥ï 2.5** (ÊÅêÊÖåÊ®°ÂºèÊÅ¢Â§ç)

```haskell
-- ÊÅêÊÖåÊ®°ÂºèÊÅ¢Â§ç
class PanicModeRecovery a where
  -- ÊÅêÊÖåÊ®°ÂºèÊÅ¢Â§ç
  panicModeRecovery :: a -> [String] -> [String] -> Maybe [String]
  
  -- ÂêåÊ≠•ÈõÜÂêà
  syncSet :: a -> Set String
  
  -- Ë∑≥ËøáÂà∞ÂêåÊ≠•ÁÇπ
  skipToSync :: a -> [String] -> [String]

-- ‰∏ä‰∏ãÊñáÊó†ÂÖ≥ÊñáÊ≥ïÊÅêÊÖåÊ®°ÂºèÊÅ¢Â§çÂÆû‰æã
instance PanicModeRecovery CFG where
  panicModeRecovery cfg stack input = 
    let sync = syncSet cfg
        (newStack, newInput) = skipToSync cfg (stack, input)
    in if null newStack
         then Nothing
         else Just newInput
  
  syncSet cfg = 
    Set.fromList (terminals cfg ++ ["$"])
  
  skipToSync cfg (stack, input) = 
    case input of
      [] -> (stack, [])
      (token:tokens) -> 
        if token `Set.member` syncSet cfg
          then (stack, input)
          else skipToSync cfg (stack, tokens)
```

#### 3.2 Áü≠ËØ≠Á∫ßÊÅ¢Â§ç

**ÁÆóÊ≥ï 2.6** (Áü≠ËØ≠Á∫ßÊÅ¢Â§ç)

```haskell
-- Áü≠ËØ≠Á∫ßÊÅ¢Â§ç
class PhraseLevelRecovery a where
  -- Áü≠ËØ≠Á∫ßÊÅ¢Â§ç
  phraseLevelRecovery :: a -> [String] -> [String] -> Maybe [String]
  
  -- ÈîôËØØ‰øÆÂ§çËßÑÂàô
  errorFixRules :: a -> Map String [String]
  
  -- Â∫îÁî®‰øÆÂ§çËßÑÂàô
  applyFixRule :: a -> String -> [String] -> Maybe [String]

-- ‰∏ä‰∏ãÊñáÊó†ÂÖ≥ÊñáÊ≥ïÁü≠ËØ≠Á∫ßÊÅ¢Â§çÂÆû‰æã
instance PhraseLevelRecovery CFG where
  phraseLevelRecovery cfg stack input = 
    case input of
      [] -> Nothing
      (token:tokens) -> 
        case Map.lookup token (errorFixRules cfg) of
          Nothing -> phraseLevelRecovery cfg stack tokens
          Just fix -> 
            case applyFixRule cfg token fix of
              Nothing -> phraseLevelRecovery cfg stack tokens
              Just fixed -> Just (fixed ++ tokens)
  
  errorFixRules cfg = 
    Map.fromList [
      (";", [";"]),
      ("}", ["}"]),
      (")", [")"]),
      ("]", ["]"])
    ]
  
  applyFixRule cfg token fix = 
    Just fix
```

## üìä ÊÄßËÉΩÂàÜÊûê

### 1. Êó∂Èó¥Â§çÊùÇÂ∫¶ÂàÜÊûê

**ÂÆöÁêÜ 2.1** (ÈÄíÂΩí‰∏ãÈôçËß£ÊûêÊó∂Èó¥Â§çÊùÇÂ∫¶)
ÈÄíÂΩí‰∏ãÈôçËß£ÊûêÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ $O(n^2)$ÔºåÂÖ∂‰∏≠ $n$ ÊòØËæìÂÖ•ÈïøÂ∫¶„ÄÇ

**ËØÅÊòé**Ôºö

1. ÊØè‰∏™ÈùûÁªàÁªìÁ¨¶ÁöÑËß£ÊûêÂèØËÉΩÈúÄË¶ÅÂõûÊ∫Ø
2. ÊúÄÂùèÊÉÖÂÜµ‰∏ãÈúÄË¶ÅÂ∞ùËØïÊâÄÊúâÂèØËÉΩÁöÑ‰∫ßÁîüÂºè
3. Âõ†Ê≠§ÊÄªÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ $O(n^2)$

**ÂÆöÁêÜ 2.2** (LRËß£ÊûêÊó∂Èó¥Â§çÊùÇÂ∫¶)
LRËß£ÊûêÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ $O(n)$ÔºåÂÖ∂‰∏≠ $n$ ÊòØËæìÂÖ•ÈïøÂ∫¶„ÄÇ

**ËØÅÊòé**Ôºö

1. LRËß£ÊûêÂô®ÊòØÁ°ÆÂÆöÊÄßÁöÑ
2. ÊØè‰∏™ËæìÂÖ•Á¨¶Âè∑ÊúÄÂ§öË¢´Â§ÑÁêÜ‰∏ÄÊ¨°
3. Âõ†Ê≠§ÊÄªÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ $O(n)$

### 2. Á©∫Èó¥Â§çÊùÇÂ∫¶ÂàÜÊûê

**ÂÆöÁêÜ 2.3** (Ëß£ÊûêÂô®Á©∫Èó¥Â§çÊùÇÂ∫¶)

- ÈÄíÂΩí‰∏ãÈôçËß£ÊûêÔºö$O(n)$ÔºàË∞ÉÁî®Ê†àÊ∑±Â∫¶Ôºâ
- LRËß£ÊûêÔºö$O(n)$ÔºàËß£ÊûêÊ†àÂ§ßÂ∞èÔºâ
- LLËß£ÊûêÔºö$O(n)$ÔºàËß£ÊûêÊ†àÂ§ßÂ∞èÔºâ

## üéØ ‰ºòÂåñÊäÄÊúØ

### 1. ËÆ∞ÂøÜÂåñËß£Êûê

```haskell
-- ËÆ∞ÂøÜÂåñËß£ÊûêÂô®
newtype MemoizedParser a = MemoizedParser { 
  runMemoizedParser :: Map (String, [String]) [(a, [String])] -> [String] -> ([(a, [String])], Map (String, [String]) [(a, [String])])
}

-- ËÆ∞ÂøÜÂåñËß£ÊûêÂô®Á±ªÂûãÁ±ª
class MemoizedParsing p where
  -- Âü∫Êú¨Êìç‰Ωú
  memoizedEmpty :: p a
  memoizedOr :: p a -> p a -> p a
  memoizedAnd :: p (a -> b) -> p a -> p b
  memoizedPure :: a -> p a
  
  -- ËÆ∞ÂøÜÂåñÊìç‰Ωú
  memoize :: String -> p a -> p a
  lookupMemo :: String -> p a -> p a

-- ËÆ∞ÂøÜÂåñËß£ÊûêÂô®ÂÆû‰æã
instance MemoizedParsing MemoizedParser where
  memoizedEmpty = MemoizedParser $ \memo input -> ([], memo)
  
  memoizedOr (MemoizedParser p1) (MemoizedParser p2) = 
    MemoizedParser $ \memo input ->
      let (result1, memo1) = p1 memo input
          (result2, memo2) = p2 memo1 input
      in (result1 ++ result2, memo2)
  
  memoizedAnd (MemoizedParser pf) (MemoizedParser pa) = 
    MemoizedParser $ \memo input ->
      let (fResults, memo1) = pf memo input
          allResults = concatMap (\(f, rest) -> 
            let (aResults, memo2) = pa memo1 rest
            in [(f a, final) | (a, final) <- aResults]) fResults
      in (allResults, memo1)
  
  memoizedPure a = MemoizedParser $ \memo input -> ([(a, input)], memo)
  
  memoize key (MemoizedParser p) = 
    MemoizedParser $ \memo input ->
      case Map.lookup (key, show input) memo of
        Just cached -> (cached, memo)
        Nothing -> 
          let (result, newMemo) = p memo input
          in (result, Map.insert (key, show input) result newMemo)
  
  lookupMemo key (MemoizedParser p) = 
    MemoizedParser $ \memo input ->
      case Map.lookup (key, show input) memo of
        Just cached -> (cached, memo)
        Nothing -> p memo input
```

### 2. Âπ∂Ë°åËß£Êûê

```haskell
-- Âπ∂Ë°åËß£ÊûêÂô®
newtype ParallelParser a = ParallelParser { 
  runParallelParser :: [String] -> [(a, [String])] 
}

-- Âπ∂Ë°åËß£ÊûêÂô®Á±ªÂûãÁ±ª
class ParallelParsing p where
  -- Âü∫Êú¨Êìç‰Ωú
  parallelEmpty :: p a
  parallelOr :: p a -> p a -> p a
  parallelAnd :: p (a -> b) -> p a -> p b
  parallelPure :: a -> p a
  
  -- Âπ∂Ë°åÊìç‰Ωú
  parallel :: [p a] -> p [a]
  parallelMap :: (a -> b) -> p a -> p b

-- Âπ∂Ë°åËß£ÊûêÂô®ÂÆû‰æã
instance ParallelParsing ParallelParser where
  parallelEmpty = ParallelParser $ \_ -> []
  
  parallelOr (ParallelParser p1) (ParallelParser p2) = 
    ParallelParser $ \input ->
      let result1 = p1 input
          result2 = p2 input
      in result1 ++ result2
  
  parallelAnd (ParallelParser pf) (ParallelParser pa) = 
    ParallelParser $ \input ->
      let fResults = pf input
          allResults = concatMap (\(f, rest) -> 
            let aResults = pa rest
            in [(f a, final) | (a, final) <- aResults]) fResults
      in allResults
  
  parallelPure a = ParallelParser $ \input -> [(a, input)]
  
  parallel parsers = 
    ParallelParser $ \input ->
      let results = map (\p -> runParallelParser p input) parsers
          allResults = concat results
      in allResults
  
  parallelMap f (ParallelParser p) = 
    ParallelParser $ \input ->
      let results = p input
      in [(f a, rest) | (a, rest) <- results]
```

## üéØ Â∫îÁî®Á§∫‰æã

### Á§∫‰æã 1ÔºöË°®ËææÂºèËß£ÊûêÂô®ÊÄßËÉΩÊØîËæÉ

```haskell
-- ÊÄßËÉΩÊµãËØï
performanceTest :: IO ()
performanceTest = do
  putStrLn "=== Ëß£ÊûêÂô®ÊÄßËÉΩÊµãËØï ==="
  
  let testInput = replicate 1000 "id" ++ ["+"] ++ replicate 1000 "id"
  
  -- ÈÄíÂΩí‰∏ãÈôçËß£Êûê
  startTime <- getCurrentTime
  let rdResult = runParser parseExpression testInput
  endTime <- getCurrentTime
  putStrLn $ "ÈÄíÂΩí‰∏ãÈôçËß£ÊûêÊó∂Èó¥: " ++ show (diffUTCTime endTime startTime)
  
  -- È¢ÑÊµãËß£Êûê
  startTime2 <- getCurrentTime
  let predResult = parse simpleExprGrammar testInput
  endTime2 <- getCurrentTime
  putStrLn $ "È¢ÑÊµãËß£ÊûêÊó∂Èó¥: " ++ show (diffUTCTime endTime2 startTime2)
  
  -- LRËß£Êûê
  startTime3 <- getCurrentTime
  let lrResult = parse simpleExprGrammar testInput
  endTime3 <- getCurrentTime
  putStrLn $ "LRËß£ÊûêÊó∂Èó¥: " ++ show (diffUTCTime endTime3 startTime3)
```

### Á§∫‰æã 2ÔºöÈîôËØØÊÅ¢Â§çÊµãËØï

```haskell
-- ÈîôËØØÊÅ¢Â§çÊµãËØï
errorRecoveryTest :: IO ()
errorRecoveryTest = do
  putStrLn "=== ÈîôËØØÊÅ¢Â§çÊµãËØï ==="
  
  let correctInput = ["id", "+", "id", ";"]
  let errorInput = ["id", "+", "id", "error", ";"]
  
  -- Ê≠£Á°ÆËæìÂÖ•Ëß£Êûê
  putStrLn "Ê≠£Á°ÆËæìÂÖ•Ëß£ÊûêÔºö"
  case parse simpleExprGrammar correctInput of
    Just tree -> putStrLn $ "Ëß£ÊûêÊàêÂäü: " ++ show tree
    Nothing -> putStrLn "Ëß£ÊûêÂ§±Ë¥•"
  
  -- ÈîôËØØËæìÂÖ•Ëß£ÊûêÔºàÂ∏¶ÊÅ¢Â§çÔºâ
  putStrLn "ÈîôËØØËæìÂÖ•Ëß£ÊûêÔºàÂ∏¶ÊÅ¢Â§çÔºâÔºö"
  case panicModeRecovery simpleExprGrammar [] errorInput of
    Just recovered -> do
      putStrLn $ "ÊÅ¢Â§çÂêéËæìÂÖ•: " ++ show recovered
      case parse simpleExprGrammar recovered of
        Just tree -> putStrLn $ "Ëß£ÊûêÊàêÂäü: " ++ show tree
        Nothing -> putStrLn "Ëß£Êûê‰ªçÁÑ∂Â§±Ë¥•"
    Nothing -> putStrLn "Êó†Ê≥ïÊÅ¢Â§ç"
```

## üîó Áõ∏ÂÖ≥ÈìæÊé•

- [01-Formal-Grammars](./01-Formal-Grammars.md) - ÂΩ¢ÂºèËØ≠Ê≥ïÁêÜËÆ∫
- [02-Parsing-Theory](./02-Parsing-Theory.md) - ËØ≠Ê≥ïÂàÜÊûêÁêÜËÆ∫
- [02-Semantics-Theory](../02-Semantics-Theory/README.md) - ËØ≠‰πâÁêÜËÆ∫
- [03-Type-System-Theory](../03-Type-System-Theory/README.md) - Á±ªÂûãÁ≥ªÁªüÁêÜËÆ∫

## üìö ÂèÇËÄÉÊñáÁåÆ

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools.
2. Grune, D., & Jacobs, C. J. (2008). Parsing Techniques: A Practical Guide.
3. Sipser, M. (2012). Introduction to the Theory of Computation.

---

*Êú¨ÊñáÊ°£ÊòØÂΩ¢ÂºèÂåñÁü•ËØÜ‰ΩìÁ≥ªÁêÜËÆ∫Â±ÇÁöÑ‰∏ÄÈÉ®ÂàÜÔºåÊèê‰æõ‰∫ÜËØ≠Ê≥ïÂàÜÊûêÁÆóÊ≥ïÁöÑÂÆåÊï¥ÂÆûÁé∞ÂíåÊÄßËÉΩÂàÜÊûê„ÄÇ*
