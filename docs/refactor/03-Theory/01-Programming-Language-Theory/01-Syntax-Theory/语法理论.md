# è¯­æ³•ç†è®º

## ðŸ“‹ æ¦‚è¿°

è¯­æ³•ç†è®ºæ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºçš„åŸºç¡€ï¼Œç ”ç©¶è¯­è¨€çš„ç»“æž„å’Œå½¢å¼åŒ–è¡¨ç¤ºã€‚æœ¬æ–‡æ¡£ä»Žå½¢å¼è¯­æ³•ã€æŠ½è±¡è¯­æ³•æ ‘ã€è¯­æ³•åˆ†æžå’ŒHaskellå®žçŽ°å››ä¸ªç»´åº¦æŽ¢è®¨è¯­æ³•ç†è®ºã€‚

## ðŸŽ¯ æ ¸å¿ƒæ¦‚å¿µ

### 1. å½¢å¼è¯­æ³•

#### 1.1 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•

**å®šä¹‰**ï¼šä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯ä¸€ç§å½¢å¼è¯­æ³•ï¼Œç”¨äºŽæè¿°ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•ç»“æž„ã€‚

```haskell
-- ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
data CFG = 
    CFG {
      nonterminals :: [String],      -- éžç»ˆç»“ç¬¦
      terminals :: [String],         -- ç»ˆç»“ç¬¦
      productions :: [Production],   -- äº§ç”Ÿå¼
      startSymbol :: String          -- å¼€å§‹ç¬¦å·
    }
  deriving (Show, Eq)

-- äº§ç”Ÿå¼
data Production = 
    Production {
      left :: String,    -- å·¦éƒ¨
      right :: [String]  -- å³éƒ¨
    }
  deriving (Show, Eq)

-- è¯­æ³•ç±»åž‹ç±»
class Grammar a where
  -- è¯­æ³•æ“ä½œ
  generate :: a -> [String]
  parse :: a -> String -> Bool
  -- è¯­æ³•æ€§è´¨
  isAmbiguous :: a -> Bool
  isLeftRecursive :: a -> Bool
  isRightRecursive :: a -> Bool
  -- è¯­æ³•åˆ†æž
  leftmostDerivation :: a -> String -> [String]
  rightmostDerivation :: a -> String -> [String]

-- ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•å®žä¾‹
instance Grammar CFG where
  generate cfg = generateFrom cfg (startSymbol cfg)
  
  parse cfg input = 
    case parseWithGrammar cfg input of
      Just _ -> True
      Nothing -> False
  
  isAmbiguous cfg = 
    length (allParses cfg "test") > 1
  
  isLeftRecursive cfg = 
    any (\p -> head (right p) == left p) (productions cfg)
  
  isRightRecursive cfg = 
    any (\p -> last (right p) == left p) (productions cfg)
  
  leftmostDerivation cfg input = 
    leftmostDerive cfg [startSymbol cfg] input
  
  rightmostDerivation cfg input = 
    rightmostDerive cfg [startSymbol cfg] input

-- ä»Žéžç»ˆç»“ç¬¦ç”Ÿæˆå­—ç¬¦ä¸²
generateFrom :: CFG -> String -> [String]
generateFrom cfg nt = 
  case findProductions cfg nt of
    [] -> []
    prods -> concatMap (\p -> generateFromProduction cfg p) prods

-- æŸ¥æ‰¾äº§ç”Ÿå¼
findProductions :: CFG -> String -> [Production]
findProductions cfg nt = 
  filter (\p -> left p == nt) (productions cfg)

-- ä»Žäº§ç”Ÿå¼ç”Ÿæˆ
generateFromProduction :: CFG -> Production -> [String]
generateFromProduction cfg prod = 
  case right prod of
    [] -> [""]
    (r:rs) -> 
      let firstGen = generateFrom cfg r
          restGen = generateFromProduction cfg (Production (left prod) rs)
      in [f ++ g | f <- firstGen, g <- restGen]

-- è¯­æ³•åˆ†æž
parseWithGrammar :: CFG -> String -> Maybe ParseTree
parseWithGrammar cfg input = 
  case parseTopDown cfg input of
    [] -> Nothing
    (tree:_) -> Just tree

-- æ‰€æœ‰è§£æž
allParses :: CFG -> String -> [ParseTree]
allParses cfg input = parseTopDown cfg input
```

#### 1.2 æŠ½è±¡è¯­æ³•æ ‘

```haskell
-- æŠ½è±¡è¯­æ³•æ ‘
data AST = 
    Leaf String           -- å¶å­èŠ‚ç‚¹
  | Node String [AST]     -- å†…éƒ¨èŠ‚ç‚¹
  deriving (Show, Eq)

-- ASTç±»åž‹ç±»
class AbstractSyntaxTree a where
  -- ASTæ“ä½œ
  root :: a -> String
  children :: a -> [a]
  isLeaf :: a -> Bool
  isNode :: a -> Bool
  -- ASTéåŽ†
  preorder :: a -> [String]
  inorder :: a -> [String]
  postorder :: a -> [String]
  -- ASTå˜æ¢
  mapAST :: (String -> String) -> a -> a
  foldAST :: (String -> b -> b) -> b -> a -> b

-- ASTå®žä¾‹
instance AbstractSyntaxTree AST where
  root (Leaf s) = s
  root (Node s _) = s
  
  children (Leaf _) = []
  children (Node _ cs) = cs
  
  isLeaf (Leaf _) = True
  isLeaf (Node _ _) = False
  
  isNode (Leaf _) = False
  isNode (Node _ _) = True
  
  preorder (Leaf s) = [s]
  preorder (Node s cs) = s : concatMap preorder cs
  
  inorder (Leaf s) = [s]
  inorder (Node s cs) = 
    case cs of
      [] -> [s]
      (c:cs') -> inorder c ++ [s] ++ concatMap inorder cs'
  
  postorder (Leaf s) = [s]
  postorder (Node s cs) = concatMap postorder cs ++ [s]
  
  mapAST f (Leaf s) = Leaf (f s)
  mapAST f (Node s cs) = Node (f s) (map (mapAST f) cs)
  
  foldAST f acc (Leaf s) = f s acc
  foldAST f acc (Node s cs) = 
    foldr (\c acc' -> foldAST f acc' c) (f s acc) cs

-- è§£æžæ ‘
data ParseTree = 
    ParseTree {
      symbol :: String,
      children :: [ParseTree],
      value :: Maybe String
    }
  deriving (Show, Eq)

-- è§£æžæ ‘æ“ä½œ
class ParseTreeOperations a where
  -- åŸºæœ¬æ“ä½œ
  getSymbol :: a -> String
  getChildren :: a -> [a]
  getValue :: a -> Maybe String
  -- æ ‘æ“ä½œ
  addChild :: a -> a -> a
  removeChild :: a -> Int -> a
  replaceChild :: a -> Int -> a -> a
  -- æ ‘åˆ†æž
  height :: a -> Int
  size :: a -> Int
  depth :: a -> Int

-- è§£æžæ ‘å®žä¾‹
instance ParseTreeOperations ParseTree where
  getSymbol = symbol
  getChildren = children
  getValue = value
  
  addChild parent child = 
    parent { children = children parent ++ [child] }
  
  removeChild parent index = 
    parent { children = take index (children parent) ++ drop (index + 1) (children parent) }
  
  replaceChild parent index newChild = 
    parent { children = take index (children parent) ++ [newChild] ++ drop (index + 1) (children parent) }
  
  height (ParseTree _ [] _) = 0
  height (ParseTree _ cs _) = 1 + maximum (map height cs)
  
  size (ParseTree _ cs _) = 1 + sum (map size cs)
  
  depth tree = depthFromRoot tree 0

-- ä»Žæ ¹è®¡ç®—æ·±åº¦
depthFromRoot :: ParseTree -> Int -> Int
depthFromRoot (ParseTree _ [] _) d = d
depthFromRoot (ParseTree _ cs _) d = 
  maximum (map (\c -> depthFromRoot c (d + 1)) cs)
```

### 2. è¯­æ³•åˆ†æž

#### 2.1 é€’å½’ä¸‹é™åˆ†æž

```haskell
-- é€’å½’ä¸‹é™åˆ†æžå™¨
class RecursiveDescentParser a where
  -- åˆ†æžæ“ä½œ
  parse :: a -> String -> Maybe ParseTree
  -- é¢„æµ‹åˆ†æž
  predict :: a -> String -> String -> Bool
  -- é”™è¯¯æ¢å¤
  errorRecovery :: a -> String -> ParseError -> Maybe ParseTree
  -- åˆ†æžè¡¨
  parseTable :: a -> ParseTable

-- åˆ†æžè¡¨
data ParseTable = 
    ParseTable {
      table :: [(String, String, [String])],
      conflicts :: [ParseConflict]
    }
  deriving (Show, Eq)

-- åˆ†æžå†²çª
data ParseConflict = 
    ShiftReduceConflict String String
  | ReduceReduceConflict String String
  deriving (Show, Eq)

-- åˆ†æžé”™è¯¯
data ParseError = 
    UnexpectedToken String String
  | MissingToken String
  | ExtraToken String
  deriving (Show, Eq)

-- é€’å½’ä¸‹é™åˆ†æžå™¨å®žä¾‹
instance RecursiveDescentParser CFG where
  parse cfg input = 
    case parseTopDown cfg input of
      [] -> Nothing
      (tree:_) -> Just tree
  
  predict cfg nt token = 
    any (\p -> left p == nt && canStartWith cfg (right p) token) (productions cfg)
  
  errorRecovery cfg input error = 
    case error of
      UnexpectedToken expected found -> 
        recoverFromUnexpected cfg input expected found
      MissingToken token -> 
        recoverFromMissing cfg input token
      ExtraToken token -> 
        recoverFromExtra cfg input token
  
  parseTable cfg = 
    ParseTable {
      table = buildParseTable cfg,
      conflicts = findConflicts cfg
    }

-- è‡ªé¡¶å‘ä¸‹åˆ†æž
parseTopDown :: CFG -> String -> [ParseTree]
parseTopDown cfg input = 
  parseFromSymbol cfg (startSymbol cfg) input

-- ä»Žç¬¦å·å¼€å§‹åˆ†æž
parseFromSymbol :: CFG -> String -> [ParseTree]
parseFromSymbol cfg symbol input = 
  case findProductions cfg symbol of
    [] -> []
    prods -> concatMap (\p -> parseFromProduction cfg p input) prods

-- ä»Žäº§ç”Ÿå¼åˆ†æž
parseFromProduction :: CFG -> Production -> String -> [ParseTree]
parseFromProduction cfg prod input = 
  case right prod of
    [] -> [ParseTree { symbol = left prod, children = [], value = Just input }]
    (r:rs) -> 
      let firstParses = parseFromSymbol cfg r input
      in concatMap (\first -> parseFromProductionRest cfg prod rs first input) firstParses

-- åˆ†æžäº§ç”Ÿå¼å‰©ä½™éƒ¨åˆ†
parseFromProductionRest :: CFG -> Production -> [String] -> ParseTree -> String -> [ParseTree]
parseFromProductionRest cfg prod [] first input = 
  [ParseTree { symbol = left prod, children = [first], value = Just input }]
parseFromProductionRest cfg prod (r:rs) first input = 
  let restParses = parseFromSymbol cfg r input
  in concatMap (\rest -> parseFromProductionRest cfg prod rs rest input) restParses

-- æž„å»ºåˆ†æžè¡¨
buildParseTable :: CFG -> [(String, String, [String])]
buildParseTable cfg = 
  concatMap (\nt -> 
    map (\token -> (nt, token, findProductionForToken cfg nt token)) 
        (firstSet cfg nt)) 
    (nonterminals cfg)

-- æŸ¥æ‰¾äº§ç”Ÿå¼
findProductionForToken :: CFG -> String -> String -> [String]
findProductionForToken cfg nt token = 
  case find (\p -> left p == nt && canStartWith cfg (right p) token) (productions cfg) of
    Just prod -> right prod
    Nothing -> []

-- é¦–ç¬¦é›†
firstSet :: CFG -> String -> [String]
firstSet cfg nt = 
  case findProductions cfg nt of
    [] -> []
    prods -> nub (concatMap (\p -> firstSetOfSequence cfg (right p)) prods)

-- åºåˆ—é¦–ç¬¦é›†
firstSetOfSequence :: CFG -> [String] -> [String]
firstSetOfSequence cfg [] = [""]
firstSetOfSequence cfg (s:ss) = 
  let firstOfS = firstSet cfg s
      firstOfRest = firstSetOfSequence cfg ss
  in if "" `elem` firstOfS 
     then nub (firstOfS ++ firstOfRest)
     else firstOfS

-- æ£€æŸ¥åºåˆ—æ˜¯å¦ä»¥ç¬¦å·å¼€å§‹
canStartWith :: CFG -> [String] -> String -> Bool
canStartWith cfg sequence token = 
  token `elem` firstSetOfSequence cfg sequence
```

#### 2.2 LRåˆ†æž

```haskell
-- LRåˆ†æžå™¨
class LRParser a where
  -- LRåˆ†æž
  lrParse :: a -> String -> Maybe ParseTree
  -- çŠ¶æ€æœº
  stateMachine :: a -> LRStateMachine
  -- åŠ¨ä½œè¡¨
  actionTable :: a -> ActionTable
  -- è½¬ç§»è¡¨
  gotoTable :: a -> GotoTable

-- LRçŠ¶æ€æœº
data LRStateMachine = 
    LRStateMachine {
      states :: [LRState],
      transitions :: [LRTransition],
      initialState :: LRState
    }
  deriving (Show, Eq)

-- LRçŠ¶æ€
data LRState = 
    LRState {
      stateId :: Int,
      items :: [LRItem],
      actions :: [LRAction]
    }
  deriving (Show, Eq)

-- LRé¡¹ç›®
data LRItem = 
    LRItem {
      production :: Production,
      position :: Int,
      lookahead :: [String]
    }
  deriving (Show, Eq)

-- LRåŠ¨ä½œ
data LRAction = 
    Shift Int
  | Reduce Production
  | Accept
  | Error
  deriving (Show, Eq)

-- LRè½¬ç§»
data LRTransition = 
    LRTransition {
      fromState :: Int,
      symbol :: String,
      toState :: Int
    }
  deriving (Show, Eq)

-- åŠ¨ä½œè¡¨
data ActionTable = 
    ActionTable {
      actions :: [(Int, String, LRAction)]
    }
  deriving (Show, Eq)

-- è½¬ç§»è¡¨
data GotoTable = 
    GotoTable {
      gotos :: [(Int, String, Int)]
    }
  deriving (Show, Eq)

-- LRåˆ†æžå™¨å®žä¾‹
instance LRParser CFG where
  lrParse cfg input = 
    case lrParseWithTables cfg input (actionTable cfg) (gotoTable cfg) of
      [] -> Nothing
      (tree:_) -> Just tree
  
  stateMachine cfg = 
    buildLRStateMachine cfg
  
  actionTable cfg = 
    buildActionTable cfg
  
  gotoTable cfg = 
    buildGotoTable cfg

-- LRåˆ†æžå®žçŽ°
lrParseWithTables :: CFG -> String -> ActionTable -> GotoTable -> [ParseTree]
lrParseWithTables cfg input actionTable gotoTable = 
  lrParseWithStack cfg input [] [0] actionTable gotoTable

-- å¸¦æ ˆçš„LRåˆ†æž
lrParseWithStack :: CFG -> String -> [ParseTree] -> [Int] -> ActionTable -> GotoTable -> [ParseTree]
lrParseWithStack cfg input trees states actionTable gotoTable = 
  case (input, states) of
    ([], [0]) -> trees
    ([], _) -> []
    ((c:cs), (s:ss)) -> 
      case findAction actionTable s [c] of
        Shift nextState -> 
          lrParseWithStack cfg cs (trees ++ [leaf c]) (nextState:s:ss) actionTable gotoTable
        Reduce prod -> 
          let newTree = node prod (take (length (right prod)) trees)
              newTrees = drop (length (right prod)) trees
              newStates = drop (length (right prod)) (s:ss)
          in case findGoto gotoTable (head newStates) (left prod) of
               Just gotoState -> 
                 lrParseWithStack cfg input (newTrees ++ [newTree]) (gotoState:newStates) actionTable gotoTable
               Nothing -> []
        Accept -> trees
        Error -> []

-- æŸ¥æ‰¾åŠ¨ä½œ
findAction :: ActionTable -> Int -> String -> LRAction
findAction table state symbol = 
  case find (\(s, sym, _) -> s == state && sym == symbol) (actions table) of
    Just (_, _, action) -> action
    Nothing -> Error

-- æŸ¥æ‰¾è½¬ç§»
findGoto :: GotoTable -> Int -> String -> Maybe Int
findGoto table state symbol = 
  case find (\(s, sym, _) -> s == state && sym == symbol) (gotos table) of
    Just (_, _, gotoState) -> Just gotoState
    Nothing -> Nothing

-- æž„å»ºå¶å­èŠ‚ç‚¹
leaf :: Char -> ParseTree
leaf c = ParseTree { symbol = [c], children = [], value = Just [c] }

-- æž„å»ºå†…éƒ¨èŠ‚ç‚¹
node :: Production -> [ParseTree] -> ParseTree
node prod children = 
  ParseTree { symbol = left prod, children = children, value = Nothing }
```

### 3. è¯­æ³•å˜æ¢

#### 3.1 è¯­æ³•è§„èŒƒåŒ–

```haskell
-- è¯­æ³•è§„èŒƒåŒ–
class GrammarNormalization a where
  -- æ¶ˆé™¤å·¦é€’å½’
  eliminateLeftRecursion :: a -> a
  -- æå–å·¦å…¬å› å­
  extractLeftFactors :: a -> a
  -- è½¬æ¢ä¸ºCNF
  toCNF :: a -> a
  -- è½¬æ¢ä¸ºGNF
  toGNF :: a -> a

-- è¯­æ³•è§„èŒƒåŒ–å®žä¾‹
instance GrammarNormalization CFG where
  eliminateLeftRecursion cfg = 
    foldl eliminateLeftRecursionForSymbol cfg (nonterminals cfg)
  
  extractLeftFactors cfg = 
    foldl extractLeftFactorsForSymbol cfg (nonterminals cfg)
  
  toCNF cfg = 
    let cfg1 = eliminateLeftRecursion cfg
        cfg2 = extractLeftFactors cfg1
        cfg3 = eliminateUnitProductions cfg2
        cfg4 = eliminateEpsilonProductions cfg3
    in convertToCNF cfg4
  
  toGNF cfg = 
    let cfg1 = eliminateLeftRecursion cfg
        cfg2 = extractLeftFactors cfg1
    in convertToGNF cfg2

-- æ¶ˆé™¤ç‰¹å®šç¬¦å·çš„å·¦é€’å½’
eliminateLeftRecursionForSymbol :: CFG -> String -> CFG
eliminateLeftRecursionForSymbol cfg nt = 
  let prods = findProductions cfg nt
      (recursive, nonRecursive) = partition isLeftRecursive prod
  in case recursive of
       [] -> cfg
       _ -> 
         let newNT = nt ++ "'"
             newProds = map (\p -> Production newNT (tail (right p) ++ [newNT])) recursive
             newProds' = map (\p -> Production newNT (right p)) nonRecursive
             newProds'' = map (\p -> Production nt (right p ++ [newNT])) nonRecursive
         in cfg { 
           nonterminals = nonterminals cfg ++ [newNT],
           productions = filter (\p -> left p /= nt) (productions cfg) ++ newProds ++ newProds' ++ newProds''
         }

-- æ£€æŸ¥äº§ç”Ÿå¼æ˜¯å¦å·¦é€’å½’
isLeftRecursive :: Production -> Bool
isLeftRecursive prod = 
  not (null (right prod)) && head (right prod) == left prod

-- æå–ç‰¹å®šç¬¦å·çš„å·¦å…¬å› å­
extractLeftFactorsForSymbol :: CFG -> String -> CFG
extractLeftFactorsForSymbol cfg nt = 
  let prods = findProductions cfg nt
      commonPrefixes = findCommonPrefixes (map right prods)
  in foldl extractCommonPrefix cfg commonPrefixes

-- æŸ¥æ‰¾å…¬å…±å‰ç¼€
findCommonPrefixes :: [[String]] -> [[String]]
findCommonPrefixes sequences = 
  let allPrefixes = concatMap (\seq -> take (length seq) (inits seq)) sequences
      prefixCounts = countOccurrences allPrefixes
  in filter (\prefix -> countOccurrences allPrefixes prefix > 1) allPrefixes

-- æå–å…¬å…±å‰ç¼€
extractCommonPrefix :: CFG -> [String] -> CFG
extractCommonPrefix cfg prefix = 
  let newNT = "NEW_" ++ show (length (nonterminals cfg))
      prodsWithPrefix = filter (\p -> isPrefixOf prefix (right p)) (productions cfg)
      newProds = map (\p -> Production newNT (drop (length prefix) (right p))) prodsWithPrefix
      newProd = Production (left (head prodsWithPrefix)) (prefix ++ [newNT])
  in cfg {
    nonterminals = nonterminals cfg ++ [newNT],
    productions = filter (\p -> not (p `elem` prodsWithPrefix)) (productions cfg) ++ [newProd] ++ newProds
  }

-- æ£€æŸ¥æ˜¯å¦ä¸ºå‰ç¼€
isPrefixOf :: [String] -> [String] -> Bool
isPrefixOf [] _ = True
isPrefixOf _ [] = False
isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys

-- æ¶ˆé™¤å•ä½äº§ç”Ÿå¼
eliminateUnitProductions :: CFG -> CFG
eliminateUnitProductions cfg = 
  let unitProds = filter (\p -> length (right p) == 1 && head (right p) `elem` nonterminals cfg) (productions cfg)
      nonUnitProds = filter (\p -> not (p `elem` unitProds)) (productions cfg)
      newProds = concatMap (expandUnitProduction cfg) unitProds
  in cfg { productions = nonUnitProds ++ newProds }

-- å±•å¼€å•ä½äº§ç”Ÿå¼
expandUnitProduction :: CFG -> Production -> [Production]
expandUnitProduction cfg prod = 
  let targetNT = head (right prod)
      targetProds = findProductions cfg targetNT
  in map (\p -> Production (left prod) (right p)) targetProds

-- æ¶ˆé™¤Îµäº§ç”Ÿå¼
eliminateEpsilonProductions :: CFG -> CFG
eliminateEpsilonProductions cfg = 
  let epsilonProds = filter (\p -> right p == []) (productions cfg)
      nullableNTs = findNullableNonterminals cfg
      newProds = concatMap (expandEpsilonProduction nullableNTs) (productions cfg)
  in cfg { productions = newProds }

-- æŸ¥æ‰¾å¯ç©ºéžç»ˆç»“ç¬¦
findNullableNonterminals :: CFG -> [String]
findNullableNonterminals cfg = 
  let nullable = filter (\nt -> hasEpsilonProduction cfg nt) (nonterminals cfg)
  in fix (\f nts -> 
    let newNullable = filter (\nt -> canDeriveEpsilon cfg nt nts) (nonterminals cfg)
    in if newNullable == nts then nts else f newNullable) nullable

-- æ£€æŸ¥æ˜¯å¦æœ‰Îµäº§ç”Ÿå¼
hasEpsilonProduction :: CFG -> String -> Bool
hasEpsilonProduction cfg nt = 
  any (\p -> left p == nt && right p == []) (productions cfg)

-- æ£€æŸ¥æ˜¯å¦èƒ½æŽ¨å¯¼å‡ºÎµ
canDeriveEpsilon :: CFG -> String -> [String] -> Bool
canDeriveEpsilon cfg nt nullable = 
  any (\p -> left p == nt && all (`elem` nullable) (right p)) (productions cfg)

-- å±•å¼€Îµäº§ç”Ÿå¼
expandEpsilonProduction :: [String] -> Production -> [Production]
expandEpsilonProduction nullable prod = 
  let nullablePositions = findIndices (`elem` nullable) (right prod)
      combinations = subsequences nullablePositions
  in map (\pos -> Production (left prod) (removeAtPositions (right prod) pos)) combinations

-- ç§»é™¤æŒ‡å®šä½ç½®çš„å…ƒç´ 
removeAtPositions :: [a] -> [Int] -> [a]
removeAtPositions xs positions = 
  [x | (i, x) <- zip [0..] xs, i `notElem` positions]

-- è½¬æ¢ä¸ºCNF
convertToCNF :: CFG -> CFG
convertToCNF cfg = 
  let cfg1 = eliminateLongProductions cfg
      cfg2 = eliminateTerminalProductions cfg1
  in cfg2

-- æ¶ˆé™¤é•¿äº§ç”Ÿå¼
eliminateLongProductions :: CFG -> CFG
eliminateLongProductions cfg = 
  foldl eliminateLongProduction cfg (filter (\p -> length (right p) > 2) (productions cfg))

-- æ¶ˆé™¤å•ä¸ªé•¿äº§ç”Ÿå¼
eliminateLongProduction :: CFG -> Production -> CFG
eliminateLongProduction cfg prod = 
  let newNTs = map (\i -> left prod ++ "_" ++ show i) [1..length (right prod) - 2]
      newProds = zipWith (\nt rhs -> Production nt rhs) 
                         (init newNTs) 
                         (map (\i -> [right prod !! i, newNTs !! (i + 1)]) [0..length newNTs - 1])
      finalProd = Production (left prod) [right prod !! 0, head newNTs]
  in cfg {
    nonterminals = nonterminals cfg ++ newNTs,
    productions = filter (/= prod) (productions cfg) ++ newProds ++ [finalProd]
  }

-- æ¶ˆé™¤ç»ˆç»“ç¬¦äº§ç”Ÿå¼
eliminateTerminalProductions :: CFG -> CFG
eliminateTerminalProductions cfg = 
  let terminalProds = filter (\p -> length (right p) == 1 && head (right p) `elem` terminals cfg) (productions cfg)
      newNTs = map (\t -> "T_" ++ t) (nub (map (head . right) terminalProds))
      newProds = zipWith (\nt t -> Production nt [t]) newNTs (nub (map (head . right) terminalProds))
      updatedProds = map (replaceTerminals newNTs) (productions cfg)
  in cfg {
    nonterminals = nonterminals cfg ++ newNTs,
    productions = updatedProds ++ newProds
  }

-- æ›¿æ¢äº§ç”Ÿå¼ä¸­çš„ç»ˆç»“ç¬¦
replaceTerminals :: [String] -> Production -> Production
replaceTerminals newNTs prod = 
  Production (left prod) (map (\s -> 
    if s `elem` map (drop 2) newNTs 
    then "T_" ++ s 
    else s) (right prod))
```

## ðŸ”¬ å½¢å¼åŒ–ç†è®º

### 1. è¯­æ³•ç­‰ä»·æ€§

```haskell
-- è¯­æ³•ç­‰ä»·æ€§
class GrammarEquivalence a where
  -- å¼±ç­‰ä»·
  weakEquivalence :: a -> a -> Bool
  -- å¼ºç­‰ä»·
  strongEquivalence :: a -> a -> Bool
  -- ç­‰ä»·æ€§è¯æ˜Ž
  equivalenceProof :: a -> a -> Proof
  -- ç­‰ä»·æ€§æµ‹è¯•
  equivalenceTest :: a -> a -> [String] -> Bool

-- è¯­æ³•ç­‰ä»·æ€§å®žä¾‹
instance GrammarEquivalence CFG where
  weakEquivalence cfg1 cfg2 = 
    let lang1 = generate cfg1
        lang2 = generate cfg2
    in lang1 == lang2
  
  strongEquivalence cfg1 cfg2 = 
    weakEquivalence cfg1 cfg2 && 
    isAmbiguous cfg1 == isAmbiguous cfg2
  
  equivalenceProof cfg1 cfg2 = 
    Proof {
      method = "è¯­è¨€ç­‰ä»·æ€§è¯æ˜Ž",
      steps = [
        "è¯æ˜ŽL(G1) âŠ† L(G2)",
        "è¯æ˜ŽL(G2) âŠ† L(G1)",
        "è¯æ˜Žæ­§ä¹‰æ€§ç­‰ä»·"
      ],
      conclusion = "è¯­æ³•ç­‰ä»·"
    }
  
  equivalenceTest cfg1 cfg2 testStrings = 
    all (\s -> parse cfg1 s == parse cfg2 s) testStrings
```

### 2. è¯­æ³•å¤æ‚æ€§

```haskell
-- è¯­æ³•å¤æ‚æ€§
class GrammarComplexity a where
  -- è¯­æ³•å¤§å°
  grammarSize :: a -> Int
  -- è¯­æ³•æ·±åº¦
  grammarDepth :: a -> Int
  -- è¯­æ³•å®½åº¦
  grammarWidth :: a -> Int
  -- å¤æ‚åº¦åˆ†æž
  complexityAnalysis :: a -> ComplexityAnalysis

-- å¤æ‚åº¦åˆ†æž
data ComplexityAnalysis = 
    ComplexityAnalysis {
      size :: Int,
      depth :: Int,
      width :: Int,
      ambiguity :: Bool,
      leftRecursion :: Bool,
      rightRecursion :: Bool
    }
  deriving (Show, Eq)

-- è¯­æ³•å¤æ‚æ€§å®žä¾‹
instance GrammarComplexity CFG where
  grammarSize cfg = 
    length (productions cfg)
  
  grammarDepth cfg = 
    maximum (map productionDepth (productions cfg))
  
  grammarWidth cfg = 
    maximum (map (length . right) (productions cfg))
  
  complexityAnalysis cfg = 
    ComplexityAnalysis {
      size = grammarSize cfg,
      depth = grammarDepth cfg,
      width = grammarWidth cfg,
      ambiguity = isAmbiguous cfg,
      leftRecursion = isLeftRecursive cfg,
      rightRecursion = isRightRecursive cfg
    }

-- äº§ç”Ÿå¼æ·±åº¦
productionDepth :: Production -> Int
productionDepth prod = 
  maximum (map symbolDepth (right prod))

-- ç¬¦å·æ·±åº¦
symbolDepth :: String -> Int
symbolDepth s = 
  if isNonTerminal s then 1 else 0

-- æ£€æŸ¥æ˜¯å¦éžç»ˆç»“ç¬¦
isNonTerminal :: String -> Bool
isNonTerminal s = 
  isUpper (head s) && all isAlpha s
```

## ðŸ§® æ•°å­¦è¯æ˜Ž

### 1. åŸºæœ¬å®šç†è¯æ˜Ž

#### 1.1 è¯­æ³•ç­‰ä»·æ€§å®šç†

```haskell
-- è¯­æ³•ç­‰ä»·æ€§å®šç†
class GrammarEquivalenceTheorem a where
  -- ç­‰ä»·æ€§å®šç†
  equivalenceTheorem :: a -> a -> Bool
  -- è¯æ˜Ž
  equivalenceProof :: Proof
  -- åº”ç”¨
  equivalenceApplication :: [a] -> [a] -> Bool

-- è¯­æ³•ç­‰ä»·æ€§å®šç†å®žä¾‹
instance GrammarEquivalenceTheorem CFG where
  equivalenceTheorem cfg1 cfg2 = 
    let lang1 = setFromList (generate cfg1)
        lang2 = setFromList (generate cfg2)
    in lang1 == lang2
  
  equivalenceProof = 
    Proof {
      method = "åŒå‘åŒ…å«è¯æ˜Ž",
      steps = [
        "è¯æ˜ŽL(G1) âŠ† L(G2)",
        "è¯æ˜ŽL(G2) âŠ† L(G1)",
        "åº”ç”¨é›†åˆç›¸ç­‰æ€§"
      ],
      conclusion = "è¯­æ³•ç­‰ä»·"
    }
  
  equivalenceApplication cfgs1 cfgs2 = 
    length cfgs1 == length cfgs2 && 
    all (\(cfg1, cfg2) -> equivalenceTheorem cfg1 cfg2) (zip cfgs1 cfgs2)

-- ä»Žåˆ—è¡¨æž„é€ é›†åˆ
setFromList :: [a] -> [a]
setFromList = nub
```

#### 1.2 è¯­æ³•è§„èŒƒåŒ–å®šç†

```haskell
-- è¯­æ³•è§„èŒƒåŒ–å®šç†
class GrammarNormalizationTheorem a where
  -- è§„èŒƒåŒ–å®šç†
  normalizationTheorem :: a -> a -> Bool
  -- è¯æ˜Ž
  normalizationProof :: Proof
  -- åº”ç”¨
  normalizationApplication :: a -> a

-- è¯­æ³•è§„èŒƒåŒ–å®šç†å®žä¾‹
instance GrammarNormalizationTheorem CFG where
  normalizationTheorem original normalized = 
    weakEquivalence original normalized && 
    isInNormalForm normalized
  
  normalizationProof = 
    Proof {
      method = "æž„é€ æ€§è¯æ˜Ž",
      steps = [
        "æž„é€ è§„èŒƒåŒ–ç®—æ³•",
        "è¯æ˜Žç®—æ³•ç»ˆæ­¢æ€§",
        "è¯æ˜Žè¯­è¨€ä¿æŒæ€§"
      ],
      conclusion = "è§„èŒƒåŒ–å®šç†æˆç«‹"
    }
  
  normalizationApplication cfg = 
    toCNF cfg

-- æ£€æŸ¥æ˜¯å¦è§„èŒƒå½¢å¼
isInNormalForm :: CFG -> Bool
isInNormalForm cfg = 
  all (\p -> length (right p) <= 2) (productions cfg) &&
  all (\p -> length (right p) == 1 || 
             (length (right p) == 2 && 
              all isNonTerminal (right p))) (productions cfg)
```

### 2. é«˜çº§å®šç†è¯æ˜Ž

#### 2.1 è¯­æ³•åˆ†æžå®šç†

```haskell
-- è¯­æ³•åˆ†æžå®šç†
class GrammarParsingTheorem a where
  -- åˆ†æžå®šç†
  parsingTheorem :: a -> String -> Bool
  -- è¯æ˜Ž
  parsingProof :: Proof
  -- åº”ç”¨
  parsingApplication :: a -> [String] -> [ParseTree]

-- è¯­æ³•åˆ†æžå®šç†å®žä¾‹
instance GrammarParsingTheorem CFG where
  parsingTheorem cfg input = 
    case parse cfg input of
      Just _ -> True
      Nothing -> False
  
  parsingProof = 
    Proof {
      method = "ç®—æ³•æ­£ç¡®æ€§è¯æ˜Ž",
      steps = [
        "è¯æ˜Žç®—æ³•ç»ˆæ­¢æ€§",
        "è¯æ˜Žç®—æ³•æ­£ç¡®æ€§",
        "è¯æ˜Žç®—æ³•å®Œå¤‡æ€§"
      ],
      conclusion = "åˆ†æžå®šç†æˆç«‹"
    }
  
  parsingApplication cfg inputs = 
    catMaybes (map (parse cfg) inputs)

-- å¯èƒ½ä¸ºç©ºçš„åˆ—è¡¨
catMaybes :: [Maybe a] -> [a]
catMaybes [] = []
catMaybes (Just x:xs) = x : catMaybes xs
catMaybes (Nothing:xs) = catMaybes xs
```

#### 2.2 è¯­æ³•å˜æ¢å®šç†

```haskell
-- è¯­æ³•å˜æ¢å®šç†
class GrammarTransformationTheorem a where
  -- å˜æ¢å®šç†
  transformationTheorem :: a -> a -> Bool
  -- è¯æ˜Ž
  transformationProof :: Proof
  -- åº”ç”¨
  transformationApplication :: a -> a

-- è¯­æ³•å˜æ¢å®šç†å®žä¾‹
instance GrammarTransformationTheorem CFG where
  transformationTheorem original transformed = 
    weakEquivalence original transformed &&
    isTransformationValid original transformed
  
  transformationProof = 
    Proof {
      method = "å˜æ¢ä¿æŒæ€§è¯æ˜Ž",
      steps = [
        "è¯æ˜Žå˜æ¢ç»ˆæ­¢æ€§",
        "è¯æ˜Žè¯­è¨€ä¿æŒæ€§",
        "è¯æ˜Žæ€§è´¨ä¿æŒæ€§"
      ],
      conclusion = "å˜æ¢å®šç†æˆç«‹"
    }
  
  transformationApplication cfg = 
    eliminateLeftRecursion cfg

-- æ£€æŸ¥å˜æ¢æœ‰æ•ˆæ€§
isTransformationValid :: CFG -> CFG -> Bool
isTransformationValid original transformed = 
  not (isLeftRecursive transformed) &&
  not (isAmbiguous transformed) &&
  grammarSize transformed <= grammarSize original * 2
```

## ðŸ”— äº¤å‰å¼•ç”¨

- [è¯­ä¹‰ç†è®º](../02-Semantics-Theory/è¯­ä¹‰ç†è®º.md)
- [ç±»åž‹ç†è®º](../03-Type-Theory/ç±»åž‹ç†è®º.md)
- [ç¼–è¯‘åŽŸç†](../04-Compilation-Theory/ç¼–è¯‘åŽŸç†.md)
- [è¯­è¨€è®¾è®¡](../05-Language-Design/è¯­è¨€è®¾è®¡.md)

## ðŸ“š å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.
3. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.
4. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
5. Kozen, D. C. (2006). *Automata and Computability*. Springer.

---

*æœ¬æ–‡æ¡£æ˜¯è¯­æ³•ç†è®ºçš„å®Œæ•´å½¢å¼åŒ–è¡¨è¾¾ï¼Œç»“åˆäº†å½¢å¼è¯­æ³•ã€è¯­æ³•åˆ†æžã€è¯­æ³•å˜æ¢å’ŒHaskellå®žçŽ°ï¼Œä¸ºç†è§£ç¼–ç¨‹è¯­è¨€è¯­æ³•æä¾›äº†å¤šç»´åº¦è§†è§’ã€‚*
