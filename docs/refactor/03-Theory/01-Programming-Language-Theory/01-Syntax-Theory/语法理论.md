# 语法理论

## 📋 概述

语法理论是编程语言理论的基础，研究语言的结构和形式化表示。本文档从形式语法、抽象语法树、语法分析和Haskell实现四个维度探讨语法理论。

## 🎯 核心概念

### 1. 形式语法

#### 1.1 上下文无关文法

**定义**：上下文无关文法是一种形式语法，用于描述编程语言的语法结构。

```haskell
-- 上下文无关文法
data CFG = 
    CFG {
      nonterminals :: [String],      -- 非终结符
      terminals :: [String],         -- 终结符
      productions :: [Production],   -- 产生式
      startSymbol :: String          -- 开始符号
    }
  deriving (Show, Eq)

-- 产生式
data Production = 
    Production {
      left :: String,    -- 左部
      right :: [String]  -- 右部
    }
  deriving (Show, Eq)

-- 语法类型类
class Grammar a where
  -- 语法操作
  generate :: a -> [String]
  parse :: a -> String -> Bool
  -- 语法性质
  isAmbiguous :: a -> Bool
  isLeftRecursive :: a -> Bool
  isRightRecursive :: a -> Bool
  -- 语法分析
  leftmostDerivation :: a -> String -> [String]
  rightmostDerivation :: a -> String -> [String]

-- 上下文无关文法实例
instance Grammar CFG where
  generate cfg = generateFrom cfg (startSymbol cfg)
  
  parse cfg input = 
    case parseWithGrammar cfg input of
      Just _ -> True
      Nothing -> False
  
  isAmbiguous cfg = 
    length (allParses cfg "test") > 1
  
  isLeftRecursive cfg = 
    any (\p -> head (right p) == left p) (productions cfg)
  
  isRightRecursive cfg = 
    any (\p -> last (right p) == left p) (productions cfg)
  
  leftmostDerivation cfg input = 
    leftmostDerive cfg [startSymbol cfg] input
  
  rightmostDerivation cfg input = 
    rightmostDerive cfg [startSymbol cfg] input

-- 从非终结符生成字符串
generateFrom :: CFG -> String -> [String]
generateFrom cfg nt = 
  case findProductions cfg nt of
    [] -> []
    prods -> concatMap (\p -> generateFromProduction cfg p) prods

-- 查找产生式
findProductions :: CFG -> String -> [Production]
findProductions cfg nt = 
  filter (\p -> left p == nt) (productions cfg)

-- 从产生式生成
generateFromProduction :: CFG -> Production -> [String]
generateFromProduction cfg prod = 
  case right prod of
    [] -> [""]
    (r:rs) -> 
      let firstGen = generateFrom cfg r
          restGen = generateFromProduction cfg (Production (left prod) rs)
      in [f ++ g | f <- firstGen, g <- restGen]

-- 语法分析
parseWithGrammar :: CFG -> String -> Maybe ParseTree
parseWithGrammar cfg input = 
  case parseTopDown cfg input of
    [] -> Nothing
    (tree:_) -> Just tree

-- 所有解析
allParses :: CFG -> String -> [ParseTree]
allParses cfg input = parseTopDown cfg input
```

#### 1.2 抽象语法树

```haskell
-- 抽象语法树
data AST = 
    Leaf String           -- 叶子节点
  | Node String [AST]     -- 内部节点
  deriving (Show, Eq)

-- AST类型类
class AbstractSyntaxTree a where
  -- AST操作
  root :: a -> String
  children :: a -> [a]
  isLeaf :: a -> Bool
  isNode :: a -> Bool
  -- AST遍历
  preorder :: a -> [String]
  inorder :: a -> [String]
  postorder :: a -> [String]
  -- AST变换
  mapAST :: (String -> String) -> a -> a
  foldAST :: (String -> b -> b) -> b -> a -> b

-- AST实例
instance AbstractSyntaxTree AST where
  root (Leaf s) = s
  root (Node s _) = s
  
  children (Leaf _) = []
  children (Node _ cs) = cs
  
  isLeaf (Leaf _) = True
  isLeaf (Node _ _) = False
  
  isNode (Leaf _) = False
  isNode (Node _ _) = True
  
  preorder (Leaf s) = [s]
  preorder (Node s cs) = s : concatMap preorder cs
  
  inorder (Leaf s) = [s]
  inorder (Node s cs) = 
    case cs of
      [] -> [s]
      (c:cs') -> inorder c ++ [s] ++ concatMap inorder cs'
  
  postorder (Leaf s) = [s]
  postorder (Node s cs) = concatMap postorder cs ++ [s]
  
  mapAST f (Leaf s) = Leaf (f s)
  mapAST f (Node s cs) = Node (f s) (map (mapAST f) cs)
  
  foldAST f acc (Leaf s) = f s acc
  foldAST f acc (Node s cs) = 
    foldr (\c acc' -> foldAST f acc' c) (f s acc) cs

-- 解析树
data ParseTree = 
    ParseTree {
      symbol :: String,
      children :: [ParseTree],
      value :: Maybe String
    }
  deriving (Show, Eq)

-- 解析树操作
class ParseTreeOperations a where
  -- 基本操作
  getSymbol :: a -> String
  getChildren :: a -> [a]
  getValue :: a -> Maybe String
  -- 树操作
  addChild :: a -> a -> a
  removeChild :: a -> Int -> a
  replaceChild :: a -> Int -> a -> a
  -- 树分析
  height :: a -> Int
  size :: a -> Int
  depth :: a -> Int

-- 解析树实例
instance ParseTreeOperations ParseTree where
  getSymbol = symbol
  getChildren = children
  getValue = value
  
  addChild parent child = 
    parent { children = children parent ++ [child] }
  
  removeChild parent index = 
    parent { children = take index (children parent) ++ drop (index + 1) (children parent) }
  
  replaceChild parent index newChild = 
    parent { children = take index (children parent) ++ [newChild] ++ drop (index + 1) (children parent) }
  
  height (ParseTree _ [] _) = 0
  height (ParseTree _ cs _) = 1 + maximum (map height cs)
  
  size (ParseTree _ cs _) = 1 + sum (map size cs)
  
  depth tree = depthFromRoot tree 0

-- 从根计算深度
depthFromRoot :: ParseTree -> Int -> Int
depthFromRoot (ParseTree _ [] _) d = d
depthFromRoot (ParseTree _ cs _) d = 
  maximum (map (\c -> depthFromRoot c (d + 1)) cs)
```

### 2. 语法分析

#### 2.1 递归下降分析

```haskell
-- 递归下降分析器
class RecursiveDescentParser a where
  -- 分析操作
  parse :: a -> String -> Maybe ParseTree
  -- 预测分析
  predict :: a -> String -> String -> Bool
  -- 错误恢复
  errorRecovery :: a -> String -> ParseError -> Maybe ParseTree
  -- 分析表
  parseTable :: a -> ParseTable

-- 分析表
data ParseTable = 
    ParseTable {
      table :: [(String, String, [String])],
      conflicts :: [ParseConflict]
    }
  deriving (Show, Eq)

-- 分析冲突
data ParseConflict = 
    ShiftReduceConflict String String
  | ReduceReduceConflict String String
  deriving (Show, Eq)

-- 分析错误
data ParseError = 
    UnexpectedToken String String
  | MissingToken String
  | ExtraToken String
  deriving (Show, Eq)

-- 递归下降分析器实例
instance RecursiveDescentParser CFG where
  parse cfg input = 
    case parseTopDown cfg input of
      [] -> Nothing
      (tree:_) -> Just tree
  
  predict cfg nt token = 
    any (\p -> left p == nt && canStartWith cfg (right p) token) (productions cfg)
  
  errorRecovery cfg input error = 
    case error of
      UnexpectedToken expected found -> 
        recoverFromUnexpected cfg input expected found
      MissingToken token -> 
        recoverFromMissing cfg input token
      ExtraToken token -> 
        recoverFromExtra cfg input token
  
  parseTable cfg = 
    ParseTable {
      table = buildParseTable cfg,
      conflicts = findConflicts cfg
    }

-- 自顶向下分析
parseTopDown :: CFG -> String -> [ParseTree]
parseTopDown cfg input = 
  parseFromSymbol cfg (startSymbol cfg) input

-- 从符号开始分析
parseFromSymbol :: CFG -> String -> [ParseTree]
parseFromSymbol cfg symbol input = 
  case findProductions cfg symbol of
    [] -> []
    prods -> concatMap (\p -> parseFromProduction cfg p input) prods

-- 从产生式分析
parseFromProduction :: CFG -> Production -> String -> [ParseTree]
parseFromProduction cfg prod input = 
  case right prod of
    [] -> [ParseTree { symbol = left prod, children = [], value = Just input }]
    (r:rs) -> 
      let firstParses = parseFromSymbol cfg r input
      in concatMap (\first -> parseFromProductionRest cfg prod rs first input) firstParses

-- 分析产生式剩余部分
parseFromProductionRest :: CFG -> Production -> [String] -> ParseTree -> String -> [ParseTree]
parseFromProductionRest cfg prod [] first input = 
  [ParseTree { symbol = left prod, children = [first], value = Just input }]
parseFromProductionRest cfg prod (r:rs) first input = 
  let restParses = parseFromSymbol cfg r input
  in concatMap (\rest -> parseFromProductionRest cfg prod rs rest input) restParses

-- 构建分析表
buildParseTable :: CFG -> [(String, String, [String])]
buildParseTable cfg = 
  concatMap (\nt -> 
    map (\token -> (nt, token, findProductionForToken cfg nt token)) 
        (firstSet cfg nt)) 
    (nonterminals cfg)

-- 查找产生式
findProductionForToken :: CFG -> String -> String -> [String]
findProductionForToken cfg nt token = 
  case find (\p -> left p == nt && canStartWith cfg (right p) token) (productions cfg) of
    Just prod -> right prod
    Nothing -> []

-- 首符集
firstSet :: CFG -> String -> [String]
firstSet cfg nt = 
  case findProductions cfg nt of
    [] -> []
    prods -> nub (concatMap (\p -> firstSetOfSequence cfg (right p)) prods)

-- 序列首符集
firstSetOfSequence :: CFG -> [String] -> [String]
firstSetOfSequence cfg [] = [""]
firstSetOfSequence cfg (s:ss) = 
  let firstOfS = firstSet cfg s
      firstOfRest = firstSetOfSequence cfg ss
  in if "" `elem` firstOfS 
     then nub (firstOfS ++ firstOfRest)
     else firstOfS

-- 检查序列是否以符号开始
canStartWith :: CFG -> [String] -> String -> Bool
canStartWith cfg sequence token = 
  token `elem` firstSetOfSequence cfg sequence
```

#### 2.2 LR分析

```haskell
-- LR分析器
class LRParser a where
  -- LR分析
  lrParse :: a -> String -> Maybe ParseTree
  -- 状态机
  stateMachine :: a -> LRStateMachine
  -- 动作表
  actionTable :: a -> ActionTable
  -- 转移表
  gotoTable :: a -> GotoTable

-- LR状态机
data LRStateMachine = 
    LRStateMachine {
      states :: [LRState],
      transitions :: [LRTransition],
      initialState :: LRState
    }
  deriving (Show, Eq)

-- LR状态
data LRState = 
    LRState {
      stateId :: Int,
      items :: [LRItem],
      actions :: [LRAction]
    }
  deriving (Show, Eq)

-- LR项目
data LRItem = 
    LRItem {
      production :: Production,
      position :: Int,
      lookahead :: [String]
    }
  deriving (Show, Eq)

-- LR动作
data LRAction = 
    Shift Int
  | Reduce Production
  | Accept
  | Error
  deriving (Show, Eq)

-- LR转移
data LRTransition = 
    LRTransition {
      fromState :: Int,
      symbol :: String,
      toState :: Int
    }
  deriving (Show, Eq)

-- 动作表
data ActionTable = 
    ActionTable {
      actions :: [(Int, String, LRAction)]
    }
  deriving (Show, Eq)

-- 转移表
data GotoTable = 
    GotoTable {
      gotos :: [(Int, String, Int)]
    }
  deriving (Show, Eq)

-- LR分析器实例
instance LRParser CFG where
  lrParse cfg input = 
    case lrParseWithTables cfg input (actionTable cfg) (gotoTable cfg) of
      [] -> Nothing
      (tree:_) -> Just tree
  
  stateMachine cfg = 
    buildLRStateMachine cfg
  
  actionTable cfg = 
    buildActionTable cfg
  
  gotoTable cfg = 
    buildGotoTable cfg

-- LR分析实现
lrParseWithTables :: CFG -> String -> ActionTable -> GotoTable -> [ParseTree]
lrParseWithTables cfg input actionTable gotoTable = 
  lrParseWithStack cfg input [] [0] actionTable gotoTable

-- 带栈的LR分析
lrParseWithStack :: CFG -> String -> [ParseTree] -> [Int] -> ActionTable -> GotoTable -> [ParseTree]
lrParseWithStack cfg input trees states actionTable gotoTable = 
  case (input, states) of
    ([], [0]) -> trees
    ([], _) -> []
    ((c:cs), (s:ss)) -> 
      case findAction actionTable s [c] of
        Shift nextState -> 
          lrParseWithStack cfg cs (trees ++ [leaf c]) (nextState:s:ss) actionTable gotoTable
        Reduce prod -> 
          let newTree = node prod (take (length (right prod)) trees)
              newTrees = drop (length (right prod)) trees
              newStates = drop (length (right prod)) (s:ss)
          in case findGoto gotoTable (head newStates) (left prod) of
               Just gotoState -> 
                 lrParseWithStack cfg input (newTrees ++ [newTree]) (gotoState:newStates) actionTable gotoTable
               Nothing -> []
        Accept -> trees
        Error -> []

-- 查找动作
findAction :: ActionTable -> Int -> String -> LRAction
findAction table state symbol = 
  case find (\(s, sym, _) -> s == state && sym == symbol) (actions table) of
    Just (_, _, action) -> action
    Nothing -> Error

-- 查找转移
findGoto :: GotoTable -> Int -> String -> Maybe Int
findGoto table state symbol = 
  case find (\(s, sym, _) -> s == state && sym == symbol) (gotos table) of
    Just (_, _, gotoState) -> Just gotoState
    Nothing -> Nothing

-- 构建叶子节点
leaf :: Char -> ParseTree
leaf c = ParseTree { symbol = [c], children = [], value = Just [c] }

-- 构建内部节点
node :: Production -> [ParseTree] -> ParseTree
node prod children = 
  ParseTree { symbol = left prod, children = children, value = Nothing }
```

### 3. 语法变换

#### 3.1 语法规范化

```haskell
-- 语法规范化
class GrammarNormalization a where
  -- 消除左递归
  eliminateLeftRecursion :: a -> a
  -- 提取左公因子
  extractLeftFactors :: a -> a
  -- 转换为CNF
  toCNF :: a -> a
  -- 转换为GNF
  toGNF :: a -> a

-- 语法规范化实例
instance GrammarNormalization CFG where
  eliminateLeftRecursion cfg = 
    foldl eliminateLeftRecursionForSymbol cfg (nonterminals cfg)
  
  extractLeftFactors cfg = 
    foldl extractLeftFactorsForSymbol cfg (nonterminals cfg)
  
  toCNF cfg = 
    let cfg1 = eliminateLeftRecursion cfg
        cfg2 = extractLeftFactors cfg1
        cfg3 = eliminateUnitProductions cfg2
        cfg4 = eliminateEpsilonProductions cfg3
    in convertToCNF cfg4
  
  toGNF cfg = 
    let cfg1 = eliminateLeftRecursion cfg
        cfg2 = extractLeftFactors cfg1
    in convertToGNF cfg2

-- 消除特定符号的左递归
eliminateLeftRecursionForSymbol :: CFG -> String -> CFG
eliminateLeftRecursionForSymbol cfg nt = 
  let prods = findProductions cfg nt
      (recursive, nonRecursive) = partition isLeftRecursive prod
  in case recursive of
       [] -> cfg
       _ -> 
         let newNT = nt ++ "'"
             newProds = map (\p -> Production newNT (tail (right p) ++ [newNT])) recursive
             newProds' = map (\p -> Production newNT (right p)) nonRecursive
             newProds'' = map (\p -> Production nt (right p ++ [newNT])) nonRecursive
         in cfg { 
           nonterminals = nonterminals cfg ++ [newNT],
           productions = filter (\p -> left p /= nt) (productions cfg) ++ newProds ++ newProds' ++ newProds''
         }

-- 检查产生式是否左递归
isLeftRecursive :: Production -> Bool
isLeftRecursive prod = 
  not (null (right prod)) && head (right prod) == left prod

-- 提取特定符号的左公因子
extractLeftFactorsForSymbol :: CFG -> String -> CFG
extractLeftFactorsForSymbol cfg nt = 
  let prods = findProductions cfg nt
      commonPrefixes = findCommonPrefixes (map right prods)
  in foldl extractCommonPrefix cfg commonPrefixes

-- 查找公共前缀
findCommonPrefixes :: [[String]] -> [[String]]
findCommonPrefixes sequences = 
  let allPrefixes = concatMap (\seq -> take (length seq) (inits seq)) sequences
      prefixCounts = countOccurrences allPrefixes
  in filter (\prefix -> countOccurrences allPrefixes prefix > 1) allPrefixes

-- 提取公共前缀
extractCommonPrefix :: CFG -> [String] -> CFG
extractCommonPrefix cfg prefix = 
  let newNT = "NEW_" ++ show (length (nonterminals cfg))
      prodsWithPrefix = filter (\p -> isPrefixOf prefix (right p)) (productions cfg)
      newProds = map (\p -> Production newNT (drop (length prefix) (right p))) prodsWithPrefix
      newProd = Production (left (head prodsWithPrefix)) (prefix ++ [newNT])
  in cfg {
    nonterminals = nonterminals cfg ++ [newNT],
    productions = filter (\p -> not (p `elem` prodsWithPrefix)) (productions cfg) ++ [newProd] ++ newProds
  }

-- 检查是否为前缀
isPrefixOf :: [String] -> [String] -> Bool
isPrefixOf [] _ = True
isPrefixOf _ [] = False
isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys

-- 消除单位产生式
eliminateUnitProductions :: CFG -> CFG
eliminateUnitProductions cfg = 
  let unitProds = filter (\p -> length (right p) == 1 && head (right p) `elem` nonterminals cfg) (productions cfg)
      nonUnitProds = filter (\p -> not (p `elem` unitProds)) (productions cfg)
      newProds = concatMap (expandUnitProduction cfg) unitProds
  in cfg { productions = nonUnitProds ++ newProds }

-- 展开单位产生式
expandUnitProduction :: CFG -> Production -> [Production]
expandUnitProduction cfg prod = 
  let targetNT = head (right prod)
      targetProds = findProductions cfg targetNT
  in map (\p -> Production (left prod) (right p)) targetProds

-- 消除ε产生式
eliminateEpsilonProductions :: CFG -> CFG
eliminateEpsilonProductions cfg = 
  let epsilonProds = filter (\p -> right p == []) (productions cfg)
      nullableNTs = findNullableNonterminals cfg
      newProds = concatMap (expandEpsilonProduction nullableNTs) (productions cfg)
  in cfg { productions = newProds }

-- 查找可空非终结符
findNullableNonterminals :: CFG -> [String]
findNullableNonterminals cfg = 
  let nullable = filter (\nt -> hasEpsilonProduction cfg nt) (nonterminals cfg)
  in fix (\f nts -> 
    let newNullable = filter (\nt -> canDeriveEpsilon cfg nt nts) (nonterminals cfg)
    in if newNullable == nts then nts else f newNullable) nullable

-- 检查是否有ε产生式
hasEpsilonProduction :: CFG -> String -> Bool
hasEpsilonProduction cfg nt = 
  any (\p -> left p == nt && right p == []) (productions cfg)

-- 检查是否能推导出ε
canDeriveEpsilon :: CFG -> String -> [String] -> Bool
canDeriveEpsilon cfg nt nullable = 
  any (\p -> left p == nt && all (`elem` nullable) (right p)) (productions cfg)

-- 展开ε产生式
expandEpsilonProduction :: [String] -> Production -> [Production]
expandEpsilonProduction nullable prod = 
  let nullablePositions = findIndices (`elem` nullable) (right prod)
      combinations = subsequences nullablePositions
  in map (\pos -> Production (left prod) (removeAtPositions (right prod) pos)) combinations

-- 移除指定位置的元素
removeAtPositions :: [a] -> [Int] -> [a]
removeAtPositions xs positions = 
  [x | (i, x) <- zip [0..] xs, i `notElem` positions]

-- 转换为CNF
convertToCNF :: CFG -> CFG
convertToCNF cfg = 
  let cfg1 = eliminateLongProductions cfg
      cfg2 = eliminateTerminalProductions cfg1
  in cfg2

-- 消除长产生式
eliminateLongProductions :: CFG -> CFG
eliminateLongProductions cfg = 
  foldl eliminateLongProduction cfg (filter (\p -> length (right p) > 2) (productions cfg))

-- 消除单个长产生式
eliminateLongProduction :: CFG -> Production -> CFG
eliminateLongProduction cfg prod = 
  let newNTs = map (\i -> left prod ++ "_" ++ show i) [1..length (right prod) - 2]
      newProds = zipWith (\nt rhs -> Production nt rhs) 
                         (init newNTs) 
                         (map (\i -> [right prod !! i, newNTs !! (i + 1)]) [0..length newNTs - 1])
      finalProd = Production (left prod) [right prod !! 0, head newNTs]
  in cfg {
    nonterminals = nonterminals cfg ++ newNTs,
    productions = filter (/= prod) (productions cfg) ++ newProds ++ [finalProd]
  }

-- 消除终结符产生式
eliminateTerminalProductions :: CFG -> CFG
eliminateTerminalProductions cfg = 
  let terminalProds = filter (\p -> length (right p) == 1 && head (right p) `elem` terminals cfg) (productions cfg)
      newNTs = map (\t -> "T_" ++ t) (nub (map (head . right) terminalProds))
      newProds = zipWith (\nt t -> Production nt [t]) newNTs (nub (map (head . right) terminalProds))
      updatedProds = map (replaceTerminals newNTs) (productions cfg)
  in cfg {
    nonterminals = nonterminals cfg ++ newNTs,
    productions = updatedProds ++ newProds
  }

-- 替换产生式中的终结符
replaceTerminals :: [String] -> Production -> Production
replaceTerminals newNTs prod = 
  Production (left prod) (map (\s -> 
    if s `elem` map (drop 2) newNTs 
    then "T_" ++ s 
    else s) (right prod))
```

## 🔬 形式化理论

### 1. 语法等价性

```haskell
-- 语法等价性
class GrammarEquivalence a where
  -- 弱等价
  weakEquivalence :: a -> a -> Bool
  -- 强等价
  strongEquivalence :: a -> a -> Bool
  -- 等价性证明
  equivalenceProof :: a -> a -> Proof
  -- 等价性测试
  equivalenceTest :: a -> a -> [String] -> Bool

-- 语法等价性实例
instance GrammarEquivalence CFG where
  weakEquivalence cfg1 cfg2 = 
    let lang1 = generate cfg1
        lang2 = generate cfg2
    in lang1 == lang2
  
  strongEquivalence cfg1 cfg2 = 
    weakEquivalence cfg1 cfg2 && 
    isAmbiguous cfg1 == isAmbiguous cfg2
  
  equivalenceProof cfg1 cfg2 = 
    Proof {
      method = "语言等价性证明",
      steps = [
        "证明L(G1) ⊆ L(G2)",
        "证明L(G2) ⊆ L(G1)",
        "证明歧义性等价"
      ],
      conclusion = "语法等价"
    }
  
  equivalenceTest cfg1 cfg2 testStrings = 
    all (\s -> parse cfg1 s == parse cfg2 s) testStrings
```

### 2. 语法复杂性

```haskell
-- 语法复杂性
class GrammarComplexity a where
  -- 语法大小
  grammarSize :: a -> Int
  -- 语法深度
  grammarDepth :: a -> Int
  -- 语法宽度
  grammarWidth :: a -> Int
  -- 复杂度分析
  complexityAnalysis :: a -> ComplexityAnalysis

-- 复杂度分析
data ComplexityAnalysis = 
    ComplexityAnalysis {
      size :: Int,
      depth :: Int,
      width :: Int,
      ambiguity :: Bool,
      leftRecursion :: Bool,
      rightRecursion :: Bool
    }
  deriving (Show, Eq)

-- 语法复杂性实例
instance GrammarComplexity CFG where
  grammarSize cfg = 
    length (productions cfg)
  
  grammarDepth cfg = 
    maximum (map productionDepth (productions cfg))
  
  grammarWidth cfg = 
    maximum (map (length . right) (productions cfg))
  
  complexityAnalysis cfg = 
    ComplexityAnalysis {
      size = grammarSize cfg,
      depth = grammarDepth cfg,
      width = grammarWidth cfg,
      ambiguity = isAmbiguous cfg,
      leftRecursion = isLeftRecursive cfg,
      rightRecursion = isRightRecursive cfg
    }

-- 产生式深度
productionDepth :: Production -> Int
productionDepth prod = 
  maximum (map symbolDepth (right prod))

-- 符号深度
symbolDepth :: String -> Int
symbolDepth s = 
  if isNonTerminal s then 1 else 0

-- 检查是否非终结符
isNonTerminal :: String -> Bool
isNonTerminal s = 
  isUpper (head s) && all isAlpha s
```

## 🧮 数学证明

### 1. 基本定理证明

#### 1.1 语法等价性定理

```haskell
-- 语法等价性定理
class GrammarEquivalenceTheorem a where
  -- 等价性定理
  equivalenceTheorem :: a -> a -> Bool
  -- 证明
  equivalenceProof :: Proof
  -- 应用
  equivalenceApplication :: [a] -> [a] -> Bool

-- 语法等价性定理实例
instance GrammarEquivalenceTheorem CFG where
  equivalenceTheorem cfg1 cfg2 = 
    let lang1 = setFromList (generate cfg1)
        lang2 = setFromList (generate cfg2)
    in lang1 == lang2
  
  equivalenceProof = 
    Proof {
      method = "双向包含证明",
      steps = [
        "证明L(G1) ⊆ L(G2)",
        "证明L(G2) ⊆ L(G1)",
        "应用集合相等性"
      ],
      conclusion = "语法等价"
    }
  
  equivalenceApplication cfgs1 cfgs2 = 
    length cfgs1 == length cfgs2 && 
    all (\(cfg1, cfg2) -> equivalenceTheorem cfg1 cfg2) (zip cfgs1 cfgs2)

-- 从列表构造集合
setFromList :: [a] -> [a]
setFromList = nub
```

#### 1.2 语法规范化定理

```haskell
-- 语法规范化定理
class GrammarNormalizationTheorem a where
  -- 规范化定理
  normalizationTheorem :: a -> a -> Bool
  -- 证明
  normalizationProof :: Proof
  -- 应用
  normalizationApplication :: a -> a

-- 语法规范化定理实例
instance GrammarNormalizationTheorem CFG where
  normalizationTheorem original normalized = 
    weakEquivalence original normalized && 
    isInNormalForm normalized
  
  normalizationProof = 
    Proof {
      method = "构造性证明",
      steps = [
        "构造规范化算法",
        "证明算法终止性",
        "证明语言保持性"
      ],
      conclusion = "规范化定理成立"
    }
  
  normalizationApplication cfg = 
    toCNF cfg

-- 检查是否规范形式
isInNormalForm :: CFG -> Bool
isInNormalForm cfg = 
  all (\p -> length (right p) <= 2) (productions cfg) &&
  all (\p -> length (right p) == 1 || 
             (length (right p) == 2 && 
              all isNonTerminal (right p))) (productions cfg)
```

### 2. 高级定理证明

#### 2.1 语法分析定理

```haskell
-- 语法分析定理
class GrammarParsingTheorem a where
  -- 分析定理
  parsingTheorem :: a -> String -> Bool
  -- 证明
  parsingProof :: Proof
  -- 应用
  parsingApplication :: a -> [String] -> [ParseTree]

-- 语法分析定理实例
instance GrammarParsingTheorem CFG where
  parsingTheorem cfg input = 
    case parse cfg input of
      Just _ -> True
      Nothing -> False
  
  parsingProof = 
    Proof {
      method = "算法正确性证明",
      steps = [
        "证明算法终止性",
        "证明算法正确性",
        "证明算法完备性"
      ],
      conclusion = "分析定理成立"
    }
  
  parsingApplication cfg inputs = 
    catMaybes (map (parse cfg) inputs)

-- 可能为空的列表
catMaybes :: [Maybe a] -> [a]
catMaybes [] = []
catMaybes (Just x:xs) = x : catMaybes xs
catMaybes (Nothing:xs) = catMaybes xs
```

#### 2.2 语法变换定理

```haskell
-- 语法变换定理
class GrammarTransformationTheorem a where
  -- 变换定理
  transformationTheorem :: a -> a -> Bool
  -- 证明
  transformationProof :: Proof
  -- 应用
  transformationApplication :: a -> a

-- 语法变换定理实例
instance GrammarTransformationTheorem CFG where
  transformationTheorem original transformed = 
    weakEquivalence original transformed &&
    isTransformationValid original transformed
  
  transformationProof = 
    Proof {
      method = "变换保持性证明",
      steps = [
        "证明变换终止性",
        "证明语言保持性",
        "证明性质保持性"
      ],
      conclusion = "变换定理成立"
    }
  
  transformationApplication cfg = 
    eliminateLeftRecursion cfg

-- 检查变换有效性
isTransformationValid :: CFG -> CFG -> Bool
isTransformationValid original transformed = 
  not (isLeftRecursive transformed) &&
  not (isAmbiguous transformed) &&
  grammarSize transformed <= grammarSize original * 2
```

## 🔗 交叉引用

- [语义理论](../02-Semantics-Theory/语义理论.md)
- [类型理论](../03-Type-Theory/类型理论.md)
- [编译原理](../04-Compilation-Theory/编译原理.md)
- [语言设计](../05-Language-Design/语言设计.md)

## 📚 参考文献

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.
3. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.
4. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
5. Kozen, D. C. (2006). *Automata and Computability*. Springer.

---

*本文档是语法理论的完整形式化表达，结合了形式语法、语法分析、语法变换和Haskell实现，为理解编程语言语法提供了多维度视角。*
