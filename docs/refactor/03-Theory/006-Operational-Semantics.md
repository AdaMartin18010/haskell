# Êìç‰ΩúËØ≠‰πâ (Operational Semantics)

## üìö Ê¶ÇËø∞

Êìç‰ΩúËØ≠‰πâÈÄöËøáÊèèËø∞Á®ãÂ∫èÊâßË°åÁöÑËÆ°ÁÆóÊ≠•È™§Êù•ÂÆö‰πâÁ®ãÂ∫èËØ≠Ë®ÄÁöÑËØ≠‰πâ„ÄÇÂÆÉÂÖ≥Ê≥®Á®ãÂ∫èÂ¶Ç‰Ωï‰ªéÂàùÂßãÁä∂ÊÄÅËΩ¨Êç¢Âà∞ÊúÄÁªàÁä∂ÊÄÅÔºåÊèê‰æõ‰∫ÜÁ®ãÂ∫èË°å‰∏∫ÁöÑÁ≤æÁ°ÆÊèèËø∞„ÄÇÊú¨ÊñáÊ°£Êèê‰æõ‰∫ÜÊìç‰ΩúËØ≠‰πâÁöÑÂÆåÊï¥Êï∞Â≠¶ÂΩ¢ÂºèÂåñÔºåÂåÖÊã¨Â∞èÊ≠•ËØ≠‰πâ„ÄÅÂ§ßÊ≠•ËØ≠‰πâ„ÄÅËá™ÁÑ∂ËØ≠‰πâÁ≠âÊ†∏ÂøÉÊ¶ÇÂøµÔºå‰ª•ÂèäÂÆåÊï¥ÁöÑ Haskell ÂÆûÁé∞„ÄÇ

**Áõ∏ÂÖ≥ÊñáÊ°£Ôºö**

- [[001-Linear-Type-Theory]] - Á∫øÊÄßÁ±ªÂûãÁêÜËÆ∫
- [[002-Affine-Type-Theory]] - ‰ªøÂ∞ÑÁ±ªÂûãÁêÜËÆ∫
- [[003-Temporal-Type-Theory]] - Êó∂ÊÄÅÁ±ªÂûãÁêÜËÆ∫
- [[004-Quantum-Type-Theory]] - ÈáèÂ≠êÁ±ªÂûãÁêÜËÆ∫
- [[005-Denotational-Semantics]] - ÊåáÁß∞ËØ≠‰πâ
- [[007-Axiomatic-Semantics]] - ÂÖ¨ÁêÜËØ≠‰πâ
- [[008-Category-Semantics]] - ËåÉÁï¥ËØ≠‰πâ
- [[haskell/02-Type-System]] - Haskell Á±ªÂûãÁ≥ªÁªü

## 1. Êìç‰ΩúËØ≠‰πâÂü∫Á°Ä

### 1.1 ÈÖçÁΩÆ‰∏éËΩ¨Êç¢ÂÖ≥Á≥ª

**ÂÆö‰πâ 1.1 (ÈÖçÁΩÆ)**
ÈÖçÁΩÆ $\langle e, \sigma \rangle$ ÊòØË°®ËææÂºè $e$ ÂíåÁä∂ÊÄÅ $\sigma$ ÁöÑÊúâÂ∫èÂØπÔºåË°®Á§∫Á®ãÂ∫èÊâßË°åÁöÑÁû¨Êó∂Áä∂ÊÄÅ„ÄÇ

**ÂÆö‰πâ 1.2 (ËΩ¨Êç¢ÂÖ≥Á≥ª)**
ËΩ¨Êç¢ÂÖ≥Á≥ª $\rightarrow$ ÊòØÈÖçÁΩÆÈõÜÂêà‰∏äÁöÑ‰∫åÂÖÉÂÖ≥Á≥ªÔºåË°®Á§∫Á®ãÂ∫èÊâßË°åÁöÑ‰∏ÄÊ≠•ËΩ¨Êç¢Ôºö
$$\langle e, \sigma \rangle \rightarrow \langle e', \sigma' \rangle$$

**ÂÆö‰πâ 1.3 (Â§öÊ≠•ËΩ¨Êç¢)**
Â§öÊ≠•ËΩ¨Êç¢ $\rightarrow^*$ ÊòØËΩ¨Êç¢ÂÖ≥Á≥ªÁöÑËá™Âèç‰º†ÈÄíÈó≠ÂåÖÔºö
$$\langle e, \sigma \rangle \rightarrow^* \langle e', \sigma' \rangle$$

**ÂÆöÁêÜ 1.1 (ËΩ¨Êç¢ÂÖ≥Á≥ªÁöÑÊÄßË¥®)**
ËΩ¨Êç¢ÂÖ≥Á≥ªÊª°Ë∂≥Ôºö

1. **Á°ÆÂÆöÊÄß**Ôºö$\langle e, \sigma \rangle \rightarrow \langle e_1, \sigma_1 \rangle$ ‰∏î $\langle e, \sigma \rangle \rightarrow \langle e_2, \sigma_2 \rangle$ Ëï¥Âê´ $e_1 = e_2$ ‰∏î $\sigma_1 = \sigma_2$
2. **ÁªàÊ≠¢ÊÄß**ÔºöÂ≠òÂú®ÈÖçÁΩÆ $\langle e', \sigma' \rangle$ ‰ΩøÂæó $\langle e, \sigma \rangle \rightarrow^* \langle e', \sigma' \rangle$ ‰∏î‰∏çÂ≠òÂú® $\langle e'', \sigma'' \rangle$ ‰ΩøÂæó $\langle e', \sigma' \rangle \rightarrow \langle e'', \sigma'' \rangle$

### 1.2 Haskell ÂÆûÁé∞ÔºöÊìç‰ΩúËØ≠‰πâÂü∫Á°Ä

```haskell
-- ÈÖçÁΩÆ
data Configuration = Config Expression State
  deriving (Eq, Show)

-- ËΩ¨Êç¢ÂÖ≥Á≥ª
type TransitionRelation = Configuration -> Maybe Configuration

-- Â§öÊ≠•ËΩ¨Êç¢
type MultiStepTransition = Configuration -> [Configuration]

-- Áä∂ÊÄÅ
type State = [(String, Value)]

-- ÂÄº
data Value = 
  IntVal Integer |
  BoolVal Bool |
  FuncVal String Expression Environment |
  UnitVal |
  Error String
  deriving (Eq, Show)

-- Ë°®ËææÂºè
data Expression = 
  Var String |
  LitInt Integer |
  LitBool Bool |
  Add Expression Expression |
  Sub Expression Expression |
  Mul Expression Expression |
  Div Expression Expression |
  And Expression Expression |
  Or Expression Expression |
  Not Expression |
  If Expression Expression Expression |
  Lambda String Expression |
  App Expression Expression |
  Let String Expression Expression |
  Seq Expression Expression |
  While Expression Expression |
  Assign String Expression |
  Skip
  deriving (Eq, Show)

-- ÁéØÂ¢É
type Environment = [(String, Value)]

-- Âü∫Á°ÄËΩ¨Êç¢ÂÖ≥Á≥ª
basicTransition :: TransitionRelation
basicTransition (Config expr state) = case expr of
  -- ÂèòÈáèÊü•Êâæ
  Var x -> 
    case lookup x state of
      Just v -> Just (Config (LitInt 0) state)  -- ÁÆÄÂåñÔºöËøîÂõûÂçï‰ΩçÂÄº
      Nothing -> Just (Config (Error "Undefined variable") state)
  
  -- Â≠óÈù¢Èáè
  LitInt n -> Just (Config (LitInt n) state)
  LitBool b -> Just (Config (LitBool b) state)
  
  -- ÁÆóÊúØËøêÁÆó
  Add (LitInt n1) (LitInt n2) -> 
    Just (Config (LitInt (n1 + n2)) state)
  
  Sub (LitInt n1) (LitInt n2) -> 
    Just (Config (LitInt (n1 - n2)) state)
  
  Mul (LitInt n1) (LitInt n2) -> 
    Just (Config (LitInt (n1 * n2)) state)
  
  Div (LitInt n1) (LitInt n2) -> 
    if n2 == 0 
    then Just (Config (Error "Division by zero") state)
    else Just (Config (LitInt (n1 `div` n2)) state)
  
  -- ÈÄªËæëËøêÁÆó
  And (LitBool b1) (LitBool b2) -> 
    Just (Config (LitBool (b1 && b2)) state)
  
  Or (LitBool b1) (LitBool b2) -> 
    Just (Config (LitBool (b1 || b2)) state)
  
  Not (LitBool b) -> 
    Just (Config (LitBool (not b)) state)
  
  -- Êù°‰ª∂ËØ≠Âè•
  If (LitBool True) e1 _ -> 
    Just (Config e1 state)
  
  If (LitBool False) _ e2 -> 
    Just (Config e2 state)
  
  -- ÂÖ∂‰ªñÊÉÖÂÜµ‰∏çËΩ¨Êç¢
  _ -> Nothing

-- Â§öÊ≠•ËΩ¨Êç¢
multiStepTransition :: TransitionRelation -> MultiStepTransition
multiStepTransition trans config = 
  let step config' = 
        case trans config' of
          Just next -> config' : step next
          Nothing -> [config']
  in step config

-- ËΩ¨Êç¢Âà∞ÊúÄÁªàÁä∂ÊÄÅ
transitionToFinal :: TransitionRelation -> Configuration -> Maybe Configuration
transitionToFinal trans config = 
  let steps = multiStepTransition trans config
      finalSteps = filter (\c -> trans c == Nothing) steps
  in case finalSteps of
       (final:_) -> Just final
       [] -> Nothing
```

## 2. Â∞èÊ≠•ËØ≠‰πâ (Small-Step Semantics)

### 2.1 Â∞èÊ≠•ËØ≠‰πâÂÆö‰πâ

**ÂÆö‰πâ 2.1 (Â∞èÊ≠•ËØ≠‰πâ)**
Â∞èÊ≠•ËØ≠‰πâÈÄöËøá‰∏ÄÁ≥ªÂàóÂ∞èÁöÑËÆ°ÁÆóÊ≠•È™§Êù•ÊèèËø∞Á®ãÂ∫èÊâßË°åÔºö
$$\frac{\langle e_1, \sigma_1 \rangle \rightarrow \langle e_2, \sigma_2 \rangle}{\langle e_1, \sigma_1 \rangle \rightarrow \langle e_2, \sigma_2 \rangle}$$

**ÂÆö‰πâ 2.2 (Ê±ÇÂÄº‰∏ä‰∏ãÊñá)**
Ê±ÇÂÄº‰∏ä‰∏ãÊñá $E$ ÊòØÂåÖÂê´‰∏Ä‰∏™Ê¥ûÁöÑË°®ËææÂºèÔºö
$$E ::= [\cdot] \mid E + e \mid e + E \mid \text{if } E \text{ then } e_1 \text{ else } e_2$$

**ÂÆö‰πâ 2.3 (Â∞èÊ≠•ËßÑÂàô)**
Â∞èÊ≠•ËßÑÂàôÂÆö‰πâÂü∫Êú¨ËÆ°ÁÆóÊ≠•È™§Ôºö

1. **ÁÆóÊúØËøêÁÆó**Ôºö
   $$\frac{\langle n_1 + n_2, \sigma \rangle \rightarrow \langle n_1 + n_2, \sigma \rangle}$$

2. **Êù°‰ª∂ËØ≠Âè•**Ôºö
   $$\frac{\langle \text{if true then } e_1 \text{ else } e_2, \sigma \rangle \rightarrow \langle e_1, \sigma \rangle}$$
   $$\frac{\langle \text{if false then } e_1 \text{ else } e_2, \sigma \rangle \rightarrow \langle e_2, \sigma \rangle}$$

3. **ÂèòÈáèÊü•Êâæ**Ôºö
   $$\frac{\sigma(x) = v}{\langle x, \sigma \rangle \rightarrow \langle v, \sigma \rangle}$$

### 2.2 Haskell ÂÆûÁé∞ÔºöÂ∞èÊ≠•ËØ≠‰πâ

```haskell
-- Ê±ÇÂÄº‰∏ä‰∏ãÊñá
data EvaluationContext = 
  Hole |
  AddLeft EvaluationContext Expression |
  AddRight Expression EvaluationContext |
  SubLeft EvaluationContext Expression |
  SubRight Expression EvaluationContext |
  MulLeft EvaluationContext Expression |
  MulRight Expression EvaluationContext |
  DivLeft EvaluationContext Expression |
  DivRight Expression EvaluationContext |
  IfContext EvaluationContext Expression Expression |
  AppLeft EvaluationContext Expression |
  AppRight Expression EvaluationContext |
  LetContext String EvaluationContext Expression

-- ‰∏ä‰∏ãÊñáÂ°´ÂÖÖ
fillContext :: EvaluationContext -> Expression -> Expression
fillContext Hole e = e
fillContext (AddLeft ctx e2) e1 = Add (fillContext ctx e1) e2
fillContext (AddRight e1 ctx) e2 = Add e1 (fillContext ctx e2)
fillContext (SubLeft ctx e2) e1 = Sub (fillContext ctx e1) e2
fillContext (SubRight e1 ctx) e2 = Sub e1 (fillContext ctx e2)
fillContext (MulLeft ctx e2) e1 = Mul (fillContext ctx e1) e2
fillContext (MulRight e1 ctx) e2 = Mul e1 (fillContext ctx e2)
fillContext (DivLeft ctx e2) e1 = Div (fillContext ctx e1) e2
fillContext (DivRight e1 ctx) e2 = Div e1 (fillContext ctx e2)
fillContext (IfContext ctx e1 e2) cond = If (fillContext ctx cond) e1 e2
fillContext (AppLeft ctx e2) e1 = App (fillContext ctx e1) e2
fillContext (AppRight e1 ctx) e2 = App e1 (fillContext ctx e2)
fillContext (LetContext x ctx e2) e1 = Let x (fillContext ctx e1) e2

-- Â∞èÊ≠•ËØ≠‰πâ
smallStepSemantics :: TransitionRelation
smallStepSemantics (Config expr state) = case expr of
  -- ÂèòÈáèÊü•Êâæ
  Var x -> 
    case lookup x state of
      Just (IntVal n) -> Just (Config (LitInt n) state)
      Just (BoolVal b) -> Just (Config (LitBool b) state)
      Just (FuncVal x body env) -> Just (Config (Lambda x body) state)
      _ -> Just (Config (Error "Invalid value") state)
  
  -- ÁÆóÊúØËøêÁÆó
  Add (LitInt n1) (LitInt n2) -> 
    Just (Config (LitInt (n1 + n2)) state)
  
  Sub (LitInt n1) (LitInt n2) -> 
    Just (Config (LitInt (n1 - n2)) state)
  
  Mul (LitInt n1) (LitInt n2) -> 
    Just (Config (LitInt (n1 * n2)) state)
  
  Div (LitInt n1) (LitInt n2) -> 
    if n2 == 0 
    then Just (Config (Error "Division by zero") state)
    else Just (Config (LitInt (n1 `div` n2)) state)
  
  -- ÈÄªËæëËøêÁÆó
  And (LitBool b1) (LitBool b2) -> 
    Just (Config (LitBool (b1 && b2)) state)
  
  Or (LitBool b1) (LitBool b2) -> 
    Just (Config (LitBool (b1 || b2)) state)
  
  Not (LitBool b) -> 
    Just (Config (LitBool (not b)) state)
  
  -- Êù°‰ª∂ËØ≠Âè•
  If (LitBool True) e1 _ -> 
    Just (Config e1 state)
  
  If (LitBool False) _ e2 -> 
    Just (Config e2 state)
  
  -- ÂáΩÊï∞Â∫îÁî®
  App (Lambda x body) arg -> 
    Just (Config body ((x, valueOf arg state) : state))
  
  -- ÂèòÈáèÁªëÂÆö
  Let x e1 e2 -> 
    Just (Config e2 ((x, valueOf e1 state) : state))
  
  -- Â∫èÂàó
  Seq Skip e2 -> 
    Just (Config e2 state)
  
  -- ËµãÂÄº
  Assign x (LitInt n) -> 
    Just (Config Skip (updateState state x (IntVal n)))
  
  Assign x (LitBool b) -> 
    Just (Config Skip (updateState state x (BoolVal b)))
  
  -- Âæ™ÁéØ
  While cond body -> 
    Just (Config (If cond (Seq body (While cond body)) Skip) state)
  
  -- ÂÖ∂‰ªñÊÉÖÂÜµ‰∏çËΩ¨Êç¢
  _ -> Nothing

-- ËæÖÂä©ÂáΩÊï∞
valueOf :: Expression -> State -> Value
valueOf (LitInt n) _ = IntVal n
valueOf (LitBool b) _ = BoolVal b
valueOf (Var x) state = 
  case lookup x state of
    Just v -> v
    Nothing -> Error "Undefined variable"
valueOf _ _ = Error "Cannot evaluate"

updateState :: State -> String -> Value -> State
updateState state x v = (x, v) : filter ((/= x) . fst) state

-- Â∞èÊ≠•ËØ≠‰πâÊâßË°å
executeSmallStep :: Expression -> State -> [Configuration]
executeSmallStep expr state = 
  multiStepTransition smallStepSemantics (Config expr state)

-- Â∞èÊ≠•ËØ≠‰πâÁ§∫‰æã
smallStepExample :: IO ()
smallStepExample = do
  let expr = Add (LitInt 3) (Mul (LitInt 4) (LitInt 5))
      state = []
      steps = executeSmallStep expr state
  
  putStrLn "Small-step execution:"
  mapM_ print steps
```

## 3. Â§ßÊ≠•ËØ≠‰πâ (Big-Step Semantics)

### 3.1 Â§ßÊ≠•ËØ≠‰πâÂÆö‰πâ

**ÂÆö‰πâ 3.1 (Â§ßÊ≠•ËØ≠‰πâ)**
Â§ßÊ≠•ËØ≠‰πâÁõ¥Êé•ÊèèËø∞Ë°®ËææÂºèÂà∞ÊúÄÁªàÂÄºÁöÑÊ±ÇÂÄºÔºö
$$\langle e, \sigma \rangle \Downarrow v$$

**ÂÆö‰πâ 3.2 (Â§ßÊ≠•ËßÑÂàô)**
Â§ßÊ≠•ËßÑÂàôÂÆö‰πâÂÆåÊï¥Ê±ÇÂÄºËøáÁ®ãÔºö

1. **Â≠óÈù¢Èáè**Ôºö
   $$\frac{}{\langle n, \sigma \rangle \Downarrow n}$$

2. **ÂèòÈáè**Ôºö
   $$\frac{\sigma(x) = v}{\langle x, \sigma \rangle \Downarrow v}$$

3. **ÁÆóÊúØËøêÁÆó**Ôºö
   $$\frac{\langle e_1, \sigma \rangle \Downarrow n_1 \quad \langle e_2, \sigma \rangle \Downarrow n_2}{\langle e_1 + e_2, \sigma \rangle \Downarrow n_1 + n_2}$$

4. **Êù°‰ª∂ËØ≠Âè•**Ôºö
   $$\frac{\langle e_1, \sigma \rangle \Downarrow \text{true} \quad \langle e_2, \sigma \rangle \Downarrow v}{\langle \text{if } e_1 \text{ then } e_2 \text{ else } e_3, \sigma \rangle \Downarrow v}$$

### 3.2 Haskell ÂÆûÁé∞ÔºöÂ§ßÊ≠•ËØ≠‰πâ

```haskell
-- Â§ßÊ≠•ËØ≠‰πâÂÖ≥Á≥ª
type BigStepRelation = Expression -> State -> Maybe Value

-- Â§ßÊ≠•ËØ≠‰πâ
bigStepSemantics :: BigStepRelation
bigStepSemantics expr state = case expr of
  -- Â≠óÈù¢Èáè
  LitInt n -> Just (IntVal n)
  LitBool b -> Just (BoolVal b)
  
  -- ÂèòÈáè
  Var x -> lookup x state
  
  -- ÁÆóÊúØËøêÁÆó
  Add e1 e2 -> do
    IntVal n1 <- bigStepSemantics e1 state
    IntVal n2 <- bigStepSemantics e2 state
    return (IntVal (n1 + n2))
  
  Sub e1 e2 -> do
    IntVal n1 <- bigStepSemantics e1 state
    IntVal n2 <- bigStepSemantics e2 state
    return (IntVal (n1 - n2))
  
  Mul e1 e2 -> do
    IntVal n1 <- bigStepSemantics e1 state
    IntVal n2 <- bigStepSemantics e2 state
    return (IntVal (n1 * n2))
  
  Div e1 e2 -> do
    IntVal n1 <- bigStepSemantics e1 state
    IntVal n2 <- bigStepSemantics e2 state
    if n2 == 0 
    then Nothing
    else return (IntVal (n1 `div` n2))
  
  -- ÈÄªËæëËøêÁÆó
  And e1 e2 -> do
    BoolVal b1 <- bigStepSemantics e1 state
    BoolVal b2 <- bigStepSemantics e2 state
    return (BoolVal (b1 && b2))
  
  Or e1 e2 -> do
    BoolVal b1 <- bigStepSemantics e1 state
    BoolVal b2 <- bigStepSemantics e2 state
    return (BoolVal (b1 || b2))
  
  Not e1 -> do
    BoolVal b <- bigStepSemantics e1 state
    return (BoolVal (not b))
  
  -- Êù°‰ª∂ËØ≠Âè•
  If cond e1 e2 -> do
    BoolVal b <- bigStepSemantics cond state
    if b 
    then bigStepSemantics e1 state
    else bigStepSemantics e2 state
  
  -- ÂáΩÊï∞ÊäΩË±°
  Lambda x body -> 
    Just (FuncVal x body state)
  
  -- ÂáΩÊï∞Â∫îÁî®
  App func arg -> do
    FuncVal x body env <- bigStepSemantics func state
    argVal <- bigStepSemantics arg state
    bigStepSemantics body ((x, argVal) : env)
  
  -- ÂèòÈáèÁªëÂÆö
  Let x e1 e2 -> do
    v1 <- bigStepSemantics e1 state
    bigStepSemantics e2 ((x, v1) : state)
  
  -- Â∫èÂàó
  Seq e1 e2 -> do
    _ <- bigStepSemantics e1 state
    bigStepSemantics e2 state
  
  -- ËµãÂÄº
  Assign x e1 -> do
    v <- bigStepSemantics e1 state
    return UnitVal  -- ËµãÂÄºËøîÂõûÂçï‰ΩçÂÄº
  
  -- Ë∑≥Ëøá
  Skip -> Just UnitVal
  
  -- Âæ™ÁéØ
  While cond body -> 
    case bigStepSemantics cond state of
      Just (BoolVal True) -> do
        _ <- bigStepSemantics body state
        bigStepSemantics (While cond body) state
      Just (BoolVal False) -> Just UnitVal
      _ -> Nothing

-- Â§ßÊ≠•ËØ≠‰πâÊâßË°å
executeBigStep :: Expression -> State -> Maybe Value
executeBigStep = bigStepSemantics

-- Â§ßÊ≠•ËØ≠‰πâÁ§∫‰æã
bigStepExample :: IO ()
bigStepExample = do
  let expr = Add (LitInt 3) (Mul (LitInt 4) (LitInt 5))
      state = []
      result = executeBigStep expr state
  
  putStrLn "Big-step execution:"
  case result of
    Just v -> print v
    Nothing -> putStrLn "Error: Cannot evaluate"
```

## 4. Ëá™ÁÑ∂ËØ≠‰πâ (Natural Semantics)

### 4.1 Ëá™ÁÑ∂ËØ≠‰πâÂÆö‰πâ

**ÂÆö‰πâ 4.1 (Ëá™ÁÑ∂ËØ≠‰πâ)**
Ëá™ÁÑ∂ËØ≠‰πâÊòØÁªìÊûÑÂåñÊìç‰ΩúËØ≠‰πâÁöÑ‰∏ÄÁßçÂΩ¢ÂºèÔºå‰ΩøÁî®Êé®ÁêÜËßÑÂàôÊù•ÊèèËø∞Á®ãÂ∫èÊâßË°åÔºö
$$\frac{\text{premises}}{\text{conclusion}}$$

**ÂÆö‰πâ 4.2 (Êé®ÁêÜËßÑÂàô)**
Êé®ÁêÜËßÑÂàôÂåÖÊã¨Ôºö

1. **ÂÖ¨ÁêÜËßÑÂàô**ÔºöÊó†ÂâçÊèêÁöÑËßÑÂàô
2. **Êé®ÁêÜËßÑÂàô**ÔºöÊúâÂâçÊèêÁöÑËßÑÂàô
3. **ÂΩíÁ∫≥ËßÑÂàô**ÔºöÈÄíÂΩíÂÆö‰πâÁöÑËßÑÂàô

**ÂÆö‰πâ 4.3 (ËØÅÊòéÊ†ë)**
ËØÅÊòéÊ†ëÊòØÊé®ÁêÜËßÑÂàôÁöÑÊ†ëÂΩ¢ÁªìÊûÑÔºåË°®Á§∫ËØ≠‰πâÊé®ÂØºËøáÁ®ã„ÄÇ

### 4.2 Haskell ÂÆûÁé∞ÔºöËá™ÁÑ∂ËØ≠‰πâ

```haskell
-- Êé®ÁêÜËßÑÂàô
data InferenceRule = 
  Axiom String |
  Rule String [InferenceRule]

-- ËØÅÊòéÊ†ë
data ProofTree = 
  Leaf String |
  Node String [ProofTree]

-- Ëá™ÁÑ∂ËØ≠‰πâËßÑÂàô
naturalSemantics :: Expression -> State -> Maybe (Value, ProofTree)
naturalSemantics expr state = case expr of
  -- ÂÖ¨ÁêÜËßÑÂàô
  LitInt n -> 
    Just (IntVal n, Leaf "LitInt")
  
  LitBool b -> 
    Just (BoolVal b, Leaf "LitBool")
  
  Var x -> 
    case lookup x state of
      Just v -> Just (v, Leaf "Var")
      Nothing -> Nothing
  
  -- Êé®ÁêÜËßÑÂàô
  Add e1 e2 -> do
    (IntVal n1, proof1) <- naturalSemantics e1 state
    (IntVal n2, proof2) <- naturalSemantics e2 state
    let proof = Node "Add" [proof1, proof2]
    return (IntVal (n1 + n2), proof)
  
  Sub e1 e2 -> do
    (IntVal n1, proof1) <- naturalSemantics e1 state
    (IntVal n2, proof2) <- naturalSemantics e2 state
    let proof = Node "Sub" [proof1, proof2]
    return (IntVal (n1 - n2), proof)
  
  Mul e1 e2 -> do
    (IntVal n1, proof1) <- naturalSemantics e1 state
    (IntVal n2, proof2) <- naturalSemantics e2 state
    let proof = Node "Mul" [proof1, proof2]
    return (IntVal (n1 * n2), proof)
  
  Div e1 e2 -> do
    (IntVal n1, proof1) <- naturalSemantics e1 state
    (IntVal n2, proof2) <- naturalSemantics e2 state
    if n2 == 0 
    then Nothing
    else do
      let proof = Node "Div" [proof1, proof2]
      return (IntVal (n1 `div` n2), proof)
  
  And e1 e2 -> do
    (BoolVal b1, proof1) <- naturalSemantics e1 state
    (BoolVal b2, proof2) <- naturalSemantics e2 state
    let proof = Node "And" [proof1, proof2]
    return (BoolVal (b1 && b2), proof)
  
  Or e1 e2 -> do
    (BoolVal b1, proof1) <- naturalSemantics e1 state
    (BoolVal b2, proof2) <- naturalSemantics e2 state
    let proof = Node "Or" [proof1, proof2]
    return (BoolVal (b1 || b2), proof)
  
  Not e1 -> do
    (BoolVal b, proof1) <- naturalSemantics e1 state
    let proof = Node "Not" [proof1]
    return (BoolVal (not b), proof)
  
  If cond e1 e2 -> do
    (BoolVal b, proofCond) <- naturalSemantics cond state
    if b 
    then do
      (v, proof1) <- naturalSemantics e1 state
      let proof = Node "If-True" [proofCond, proof1]
      return (v, proof)
    else do
      (v, proof2) <- naturalSemantics e2 state
      let proof = Node "If-False" [proofCond, proof2]
      return (v, proof)
  
  Lambda x body -> 
    let proof = Leaf "Lambda"
    in Just (FuncVal x body state, proof)
  
  App func arg -> do
    (FuncVal x body env, proofFunc) <- naturalSemantics func state
    (argVal, proofArg) <- naturalSemantics arg state
    (result, proofBody) <- naturalSemantics body ((x, argVal) : env)
    let proof = Node "App" [proofFunc, proofArg, proofBody]
    return (result, proof)
  
  Let x e1 e2 -> do
    (v1, proof1) <- naturalSemantics e1 state
    (v2, proof2) <- naturalSemantics e2 ((x, v1) : state)
    let proof = Node "Let" [proof1, proof2]
    return (v2, proof)
  
  Seq e1 e2 -> do
    (_, proof1) <- naturalSemantics e1 state
    (v2, proof2) <- naturalSemantics e2 state
    let proof = Node "Seq" [proof1, proof2]
    return (v2, proof)
  
  Assign x e1 -> do
    (v, proof1) <- naturalSemantics e1 state
    let proof = Node "Assign" [proof1]
    return (UnitVal, proof)
  
  Skip -> 
    Just (UnitVal, Leaf "Skip")
  
  While cond body -> 
    case naturalSemantics cond state of
      Just (BoolVal True, proofCond) -> do
        (_, proofBody) <- naturalSemantics body state
        (result, proofWhile) <- naturalSemantics (While cond body) state
        let proof = Node "While-True" [proofCond, proofBody, proofWhile]
        return (result, proof)
      Just (BoolVal False, proofCond) -> 
        let proof = Node "While-False" [proofCond]
        in Just (UnitVal, proof)
      _ -> Nothing

-- ËØÅÊòéÊ†ëÊâìÂç∞
printProofTree :: ProofTree -> String
printProofTree (Leaf rule) = rule
printProofTree (Node rule children) = 
  rule ++ "(" ++ intercalate ", " (map printProofTree children) ++ ")"

-- Ëá™ÁÑ∂ËØ≠‰πâÁ§∫‰æã
naturalSemanticsExample :: IO ()
naturalSemanticsExample = do
  let expr = Add (LitInt 3) (Mul (LitInt 4) (LitInt 5))
      state = []
      result = naturalSemantics expr state
  
  putStrLn "Natural semantics execution:"
  case result of
    Just (v, proof) -> do
      putStrLn $ "Result: " ++ show v
      putStrLn $ "Proof: " ++ printProofTree proof
    Nothing -> putStrLn "Error: Cannot evaluate"
```

## 5. ÊäΩË±°Êú∫Âô®ËØ≠‰πâ

### 5.1 ÊäΩË±°Êú∫Âô®

**ÂÆö‰πâ 5.1 (ÊäΩË±°Êú∫Âô®)**
ÊäΩË±°Êú∫Âô®ÊòØÁ®ãÂ∫èÊâßË°åÁöÑÂΩ¢ÂºèÂåñÊ®°ÂûãÔºåÂåÖÂê´Ôºö

1. **Áä∂ÊÄÅ**ÔºöÊú∫Âô®ÂΩìÂâçÁä∂ÊÄÅ
2. **Êåá‰ª§**ÔºöÊâßË°åÁöÑÂü∫Êú¨Êìç‰Ωú
3. **ËΩ¨Êç¢ÂáΩÊï∞**ÔºöÁä∂ÊÄÅËΩ¨Êç¢ËßÑÂàô

**ÂÆö‰πâ 5.2 (Ê†àÊú∫Âô®)**
Ê†àÊú∫Âô®‰ΩøÁî®Ê†àÊù•Â≠òÂÇ®‰∏≠Èó¥ÁªìÊûúÔºö
$$\langle \text{code}, \text{stack}, \text{env} \rangle \rightarrow \langle \text{code}', \text{stack}', \text{env}' \rangle$$

**ÂÆö‰πâ 5.3 (ÂØÑÂ≠òÂô®Êú∫Âô®)**
ÂØÑÂ≠òÂô®Êú∫Âô®‰ΩøÁî®ÂØÑÂ≠òÂô®Êù•Â≠òÂÇ®ÂÄºÔºö
$$\langle \text{code}, \text{registers}, \text{memory} \rangle \rightarrow \langle \text{code}', \text{registers}', \text{memory}' \rangle$$

### 5.2 Haskell ÂÆûÁé∞ÔºöÊäΩË±°Êú∫Âô®ËØ≠‰πâ

```haskell
-- Êåá‰ª§
data Instruction = 
  PushInt Integer |
  PushBool Bool |
  Load String |
  Store String |
  Add |
  Sub |
  Mul |
  Div |
  And |
  Or |
  Not |
  Jump Integer |
  JumpIfTrue Integer |
  JumpIfFalse Integer |
  Call |
  Return |
  Halt

-- Ê†àÊú∫Âô®Áä∂ÊÄÅ
data StackMachineState = StackState {
  code :: [Instruction],
  stack :: [Value],
  environment :: Environment,
  programCounter :: Integer
}

-- Ê†àÊú∫Âô®ËØ≠‰πâ
stackMachineSemantics :: StackMachineState -> Maybe StackMachineState
stackMachineSemantics (StackState code stack env pc) = case code of
  [] -> Nothing
  
  (PushInt n : rest) -> 
    Just (StackState rest (IntVal n : stack) env (pc + 1))
  
  (PushBool b : rest) -> 
    Just (StackState rest (BoolVal b : stack) env (pc + 1))
  
  (Load x : rest) -> 
    case lookup x env of
      Just v -> Just (StackState rest (v : stack) env (pc + 1))
      Nothing -> Nothing
  
  (Store x : rest) -> 
    case stack of
      (v : restStack) -> 
        Just (StackState rest restStack ((x, v) : env) (pc + 1))
      [] -> Nothing
  
  (Add : rest) -> 
    case stack of
      (IntVal n2 : IntVal n1 : restStack) -> 
        Just (StackState rest (IntVal (n1 + n2) : restStack) env (pc + 1))
      _ -> Nothing
  
  (Sub : rest) -> 
    case stack of
      (IntVal n2 : IntVal n1 : restStack) -> 
        Just (StackState rest (IntVal (n1 - n2) : restStack) env (pc + 1))
      _ -> Nothing
  
  (Mul : rest) -> 
    case stack of
      (IntVal n2 : IntVal n1 : restStack) -> 
        Just (StackState rest (IntVal (n1 * n2) : restStack) env (pc + 1))
      _ -> Nothing
  
  (Div : rest) -> 
    case stack of
      (IntVal n2 : IntVal n1 : restStack) -> 
        if n2 == 0 
        then Nothing
        else Just (StackState rest (IntVal (n1 `div` n2) : restStack) env (pc + 1))
      _ -> Nothing
  
  (And : rest) -> 
    case stack of
      (BoolVal b2 : BoolVal b1 : restStack) -> 
        Just (StackState rest (BoolVal (b1 && b2) : restStack) env (pc + 1))
      _ -> Nothing
  
  (Or : rest) -> 
    case stack of
      (BoolVal b2 : BoolVal b1 : restStack) -> 
        Just (StackState rest (BoolVal (b1 || b2) : restStack) env (pc + 1))
      _ -> Nothing
  
  (Not : rest) -> 
    case stack of
      (BoolVal b : restStack) -> 
        Just (StackState rest (BoolVal (not b) : restStack) env (pc + 1))
      _ -> Nothing
  
  (Jump offset : rest) -> 
    Just (StackState rest stack env (pc + offset))
  
  (JumpIfTrue offset : rest) -> 
    case stack of
      (BoolVal True : restStack) -> 
        Just (StackState rest restStack env (pc + offset))
      (BoolVal False : restStack) -> 
        Just (StackState rest restStack env (pc + 1))
      _ -> Nothing
  
  (JumpIfFalse offset : rest) -> 
    case stack of
      (BoolVal False : restStack) -> 
        Just (StackState rest restStack env (pc + offset))
      (BoolVal True : restStack) -> 
        Just (StackState rest restStack env (pc + 1))
      _ -> Nothing
  
  (Halt : _) -> 
    Nothing

-- Ê†àÊú∫Âô®ÊâßË°å
executeStackMachine :: [Instruction] -> Environment -> [StackMachineState]
executeStackMachine code env = 
  let initialState = StackState code [] env 0
      step state = 
        case stackMachineSemantics state of
          Just next -> state : step next
          Nothing -> [state]
  in step initialState

-- Ë°®ËææÂºèÂà∞Êåá‰ª§ÁºñËØë
compileExpression :: Expression -> [Instruction]
compileExpression expr = case expr of
  LitInt n -> [PushInt n]
  LitBool b -> [PushBool b]
  Var x -> [Load x]
  Add e1 e2 -> compileExpression e1 ++ compileExpression e2 ++ [Add]
  Sub e1 e2 -> compileExpression e1 ++ compileExpression e2 ++ [Sub]
  Mul e1 e2 -> compileExpression e1 ++ compileExpression e2 ++ [Mul]
  Div e1 e2 -> compileExpression e1 ++ compileExpression e2 ++ [Div]
  And e1 e2 -> compileExpression e1 ++ compileExpression e2 ++ [And]
  Or e1 e2 -> compileExpression e1 ++ compileExpression e2 ++ [Or]
  Not e1 -> compileExpression e1 ++ [Not]
  If cond e1 e2 -> 
    let condCode = compileExpression cond
        e1Code = compileExpression e1
        e2Code = compileExpression e2
        jumpOverE1 = [JumpIfFalse (fromIntegral (length e1Code + 1))]
        jumpOverE2 = [Jump (fromIntegral (length e2Code))]
    in condCode ++ jumpOverE1 ++ e1Code ++ jumpOverE2 ++ e2Code
  _ -> [Halt]  -- ÁÆÄÂåñÂÆûÁé∞

-- ÊäΩË±°Êú∫Âô®Á§∫‰æã
abstractMachineExample :: IO ()
abstractMachineExample = do
  let expr = Add (LitInt 3) (Mul (LitInt 4) (LitInt 5))
      code = compileExpression expr
      env = []
      states = executeStackMachine code env
  
  putStrLn "Abstract machine execution:"
  mapM_ print states
```

## 6. Âπ∂ÂèëÊìç‰ΩúËØ≠‰πâ

### 6.1 Âπ∂ÂèëÈÖçÁΩÆ

**ÂÆö‰πâ 6.1 (Âπ∂ÂèëÈÖçÁΩÆ)**
Âπ∂ÂèëÈÖçÁΩÆÂåÖÂê´Â§ö‰∏™ËøõÁ®ãÁöÑÁä∂ÊÄÅÔºö
$$\langle P_1 \parallel P_2 \parallel \cdots \parallel P_n, \sigma \rangle$$

**ÂÆö‰πâ 6.2 (Âπ∂ÂèëËΩ¨Êç¢)**
Âπ∂ÂèëËΩ¨Êç¢ÂÖÅËÆ∏‰ªªÊÑèËøõÁ®ãÊâßË°åÔºö
$$\frac{\langle P_i, \sigma \rangle \rightarrow \langle P_i', \sigma' \rangle}{\langle P_1 \parallel \cdots \parallel P_i \parallel \cdots \parallel P_n, \sigma \rangle \rightarrow \langle P_1 \parallel \cdots \parallel P_i' \parallel \cdots \parallel P_n, \sigma' \rangle}$$

**ÂÆö‰πâ 6.3 (ÂêåÊ≠•ÈÄö‰ø°)**
ÂêåÊ≠•ÈÄö‰ø°ÈÄöËøáÊ∂àÊÅØ‰º†ÈÄíÂÆûÁé∞Ôºö
$$\frac{\langle P_1, \sigma \rangle \rightarrow \langle P_1', \sigma' \rangle \quad \langle P_2, \sigma \rangle \rightarrow \langle P_2', \sigma' \rangle}{\langle P_1 \parallel P_2, \sigma \rangle \rightarrow \langle P_1' \parallel P_2', \sigma' \rangle}$$

### 6.2 Haskell ÂÆûÁé∞ÔºöÂπ∂ÂèëÊìç‰ΩúËØ≠‰πâ

```haskell
-- ËøõÁ®ã
data Process = 
  ProcessSkip |
  ProcessAssign String Expression |
  ProcessSeq Process Process |
  ProcessPar Process Process |
  ProcessIf Expression Process Process |
  ProcessWhile Expression Process |
  ProcessSend ProcessId ProcessId Expression |
  ProcessReceive ProcessId ProcessId String

-- ËøõÁ®ãÊ†áËØÜÁ¨¶
type ProcessId = Integer

-- Âπ∂ÂèëÈÖçÁΩÆ
data ConcurrentConfiguration = ConcurrentConfig {
  processes :: [(ProcessId, Process)],
  sharedState :: State,
  messages :: [(ProcessId, ProcessId, Value)]
}

-- Âπ∂ÂèëÊìç‰ΩúËØ≠‰πâ
concurrentOperationalSemantics :: ConcurrentConfiguration -> Maybe ConcurrentConfiguration
concurrentOperationalSemantics config = 
  let processSteps = concatMap (stepProcess config) (processes config)
  in case processSteps of
       (step:_) -> Just step
       [] -> Nothing

-- ËøõÁ®ãÊ≠•È™§
stepProcess :: ConcurrentConfiguration -> (ProcessId, Process) -> [ConcurrentConfiguration]
stepProcess config (pid, proc) = case proc of
  ProcessSkip -> []
  
  ProcessAssign x e -> 
    case bigStepSemantics e (sharedState config) of
      Just v -> 
        let newState = updateState (sharedState config) x v
            newProcesses = updateProcess pid ProcessSkip (processes config)
        in [config { processes = newProcesses, sharedState = newState }]
      Nothing -> []
  
  ProcessSeq p1 p2 -> 
    case p1 of
      ProcessSkip -> 
        let newProcesses = updateProcess pid p2 (processes config)
        in [config { processes = newProcesses }]
      _ -> 
        let p1Steps = stepProcess config (pid, p1)
        in map (\c -> c { processes = updateProcess pid (ProcessSeq (getProcess pid c) p2) (processes c) }) p1Steps
  
  ProcessPar p1 p2 -> 
    let p1Steps = stepProcess config (pid, p1)
        p2Steps = stepProcess config (pid, p2)
    in p1Steps ++ p2Steps
  
  ProcessIf cond p1 p2 -> 
    case bigStepSemantics cond (sharedState config) of
      Just (BoolVal True) -> 
        let newProcesses = updateProcess pid p1 (processes config)
        in [config { processes = newProcesses }]
      Just (BoolVal False) -> 
        let newProcesses = updateProcess pid p2 (processes config)
        in [config { processes = newProcesses }]
      _ -> []
  
  ProcessWhile cond body -> 
    case bigStepSemantics cond (sharedState config) of
      Just (BoolVal True) -> 
        let newProcesses = updateProcess pid (ProcessSeq body (ProcessWhile cond body)) (processes config)
        in [config { processes = newProcesses }]
      Just (BoolVal False) -> 
        let newProcesses = updateProcess pid ProcessSkip (processes config)
        in [config { processes = newProcesses }]
      _ -> []
  
  ProcessSend fromPid toPid e -> 
    case bigStepSemantics e (sharedState config) of
      Just v -> 
        let newMessages = (fromPid, toPid, v) : messages config
            newProcesses = updateProcess pid ProcessSkip (processes config)
        in [config { processes = newProcesses, messages = newMessages }]
      Nothing -> []
  
  ProcessReceive fromPid toPid x -> 
    let matchingMessages = filter (\(f, t, _) -> f == fromPid && t == toPid) (messages config)
    in case matchingMessages of
         ((_, _, v) : _) -> 
           let newState = updateState (sharedState config) x v
               newMessages = filter (/= head matchingMessages) (messages config)
               newProcesses = updateProcess pid ProcessSkip (processes config)
           in [config { processes = newProcesses, sharedState = newState, messages = newMessages }]
         [] -> []

-- ËæÖÂä©ÂáΩÊï∞
updateProcess :: ProcessId -> Process -> [(ProcessId, Process)] -> [(ProcessId, Process)]
updateProcess pid proc procs = 
  (pid, proc) : filter ((/= pid) . fst) procs

getProcess :: ProcessId -> ConcurrentConfiguration -> Process
getProcess pid config = 
  case lookup pid (processes config) of
    Just proc -> proc
    Nothing -> ProcessSkip

-- Âπ∂ÂèëÊâßË°å
executeConcurrent :: ConcurrentConfiguration -> [ConcurrentConfiguration]
executeConcurrent config = 
  let step config' = 
        case concurrentOperationalSemantics config' of
          Just next -> config' : step next
          Nothing -> [config']
  in step config

-- Âπ∂ÂèëÁ§∫‰æã
concurrentExample :: IO ()
concurrentExample = do
  let proc1 = ProcessAssign "x" (LitInt 5)
      proc2 = ProcessAssign "y" (LitInt 10)
      config = ConcurrentConfig {
        processes = [(1, proc1), (2, proc2)],
        sharedState = [],
        messages = []
      }
      states = executeConcurrent config
  
  putStrLn "Concurrent execution:"
  mapM_ print states
```

## 7. È´òÁ∫ß‰∏ªÈ¢ò

### 7.1 Êìç‰ΩúËØ≠‰πâ‰∏éÊåáÁß∞ËØ≠‰πâÁöÑÂÖ≥Á≥ª

**ÂÆöÁêÜ 7.1 (ËØ≠‰πâÁ≠â‰ª∑ÊÄß)**
ÂØπ‰∫éÁ°ÆÂÆöÊÄßÁ®ãÂ∫èÔºåÊìç‰ΩúËØ≠‰πâÂíåÊåáÁß∞ËØ≠‰πâÊòØÁ≠â‰ª∑ÁöÑÔºö
$$\langle e, \sigma \rangle \rightarrow^* \langle v, \sigma' \rangle \Leftrightarrow \llbracket e \rrbracket \sigma = v$$

**ËØÅÊòéÔºö** ÈÄöËøáÁªìÊûÑÂΩíÁ∫≥Ôºö

1. **Âü∫Á°ÄÊÉÖÂÜµ**ÔºöÂ≠óÈù¢ÈáèÂíåÂèòÈáè
2. **ÂΩíÁ∫≥Ê≠•È™§**ÔºöÂ§çÂêàË°®ËææÂºè
3. **ÁªàÊ≠¢ÊÄß**ÔºöÁ°Æ‰øùËØ≠‰πâÂÆö‰πâÁöÑ‰∏ÄËá¥ÊÄß

### 7.2 Êìç‰ΩúËØ≠‰πâ‰∏éÁ±ªÂûãÁ≥ªÁªü

**ÂÆö‰πâ 7.1 (Á±ªÂûãÂåñÊìç‰ΩúËØ≠‰πâ)**
Á±ªÂûãÂåñÊìç‰ΩúËØ≠‰πâÁªìÂêàÁ±ªÂûãÊ£ÄÊü•ÂíåÊìç‰ΩúËØ≠‰πâÔºö
$$\frac{\Gamma \vdash e : \tau \quad \langle e, \sigma \rangle \rightarrow \langle e', \sigma' \rangle}{\Gamma \vdash e' : \tau}$$

**ÂÆöÁêÜ 7.2 (Á±ªÂûã‰øùÊåÅ)**
Êìç‰ΩúËØ≠‰πâ‰øùÊåÅÁ±ªÂûãÔºö
Â¶ÇÊûú $\Gamma \vdash e : \tau$ ‰∏î $\langle e, \sigma \rangle \rightarrow^* \langle v, \sigma' \rangle$ÔºåÂàô $\Gamma \vdash v : \tau$„ÄÇ

```haskell
-- Á±ªÂûãÂåñÊìç‰ΩúËØ≠‰πâ
typedOperationalSemantics :: Expression -> Type -> State -> Maybe (Value, State)
typedOperationalSemantics expr typ state = do
  -- Á±ªÂûãÊ£ÄÊü•
  guard (typeCheck expr typ)
  
  -- Êìç‰ΩúËØ≠‰πâÊâßË°å
  case bigStepSemantics expr state of
    Just v -> 
      -- Á±ªÂûãÈ™åËØÅ
      guard (typeCompatible v typ)
      return (v, state)
    Nothing -> Nothing

-- Á±ªÂûãÊ£ÄÊü•
typeCheck :: Expression -> Type -> Bool
typeCheck (LitInt _) IntType = True
typeCheck (LitBool _) BoolType = True
typeCheck (Var x) typ = True  -- ÁÆÄÂåñÔºöÂÅáËÆæÊâÄÊúâÂèòÈáèÈÉΩÊúâÊ≠£Á°ÆÁ±ªÂûã
typeCheck (Add e1 e2) IntType = 
  typeCheck e1 IntType && typeCheck e2 IntType
typeCheck (Sub e1 e2) IntType = 
  typeCheck e1 IntType && typeCheck e2 IntType
typeCheck (Mul e1 e2) IntType = 
  typeCheck e1 IntType && typeCheck e2 IntType
typeCheck (Div e1 e2) IntType = 
  typeCheck e1 IntType && typeCheck e2 IntType
typeCheck (And e1 e2) BoolType = 
  typeCheck e1 BoolType && typeCheck e2 BoolType
typeCheck (Or e1 e2) BoolType = 
  typeCheck e1 BoolType && typeCheck e2 BoolType
typeCheck (Not e1) BoolType = 
  typeCheck e1 BoolType
typeCheck (If cond e1 e2) typ = 
  typeCheck cond BoolType && typeCheck e1 typ && typeCheck e2 typ
typeCheck _ _ = False

-- Á±ªÂûãÂÖºÂÆπÊÄß
typeCompatible :: Value -> Type -> Bool
typeCompatible (IntVal _) IntType = True
typeCompatible (BoolVal _) BoolType = True
typeCompatible (FuncVal _ _ _) (FunctionType _ _) = True
typeCompatible _ _ = False
```

## 8. ÊÄªÁªì

Êìç‰ΩúËØ≠‰πâ‰∏∫Á®ãÂ∫èËØ≠Ë®ÄÊèê‰æõ‰∫ÜÊâßË°åË°å‰∏∫ÁöÑÁ≤æÁ°ÆÊèèËø∞„ÄÇÈÄöËøá‰∏çÂêåÁöÑËØ≠‰πâÈ£éÊ†ºÔºàÂ∞èÊ≠•„ÄÅÂ§ßÊ≠•„ÄÅËá™ÁÑ∂ËØ≠‰πâÔºâÔºåÂÆÉËÉΩÂ§üÔºö

1. **Á≤æÁ°ÆÊèèËø∞**ÔºöÁ®ãÂ∫èÊâßË°åÁöÑÊØè‰∏™Ê≠•È™§
2. **ÂΩ¢ÂºèÂåñÂàÜÊûê**ÔºöÁ®ãÂ∫èË°å‰∏∫ÁöÑÊï∞Â≠¶ÊÄßË¥®
3. **ÂÆûÁé∞ÊåáÂØº**Ôºö‰∏∫Ëß£ÈáäÂô®ÂíåÁºñËØëÂô®Êèê‰æõËßÑËåÉ
4. **È™åËØÅÂü∫Á°Ä**ÔºöÁ®ãÂ∫èÊ≠£Á°ÆÊÄßËØÅÊòéÁöÑÂü∫Á°Ä

Êìç‰ΩúËØ≠‰πâÂú®Á®ãÂ∫èËØ≠Ë®ÄÁêÜËÆ∫„ÄÅÁºñËØëÂô®ËÆæËÆ°„ÄÅÁ®ãÂ∫èÈ™åËØÅÁ≠âÈ¢ÜÂüüÂæóÂà∞‰∫ÜÂπøÊ≥õÂ∫îÁî®Ôºå‰∏∫ÊûÑÂª∫ÂèØÈù†ÁöÑËΩØ‰ª∂Á≥ªÁªüÊèê‰æõ‰∫ÜÁêÜËÆ∫Âü∫Á°Ä„ÄÇ

---

**Áõ∏ÂÖ≥ÊñáÊ°£Ôºö**

- [[001-Linear-Type-Theory]] - Á∫øÊÄßÁ±ªÂûãÁêÜËÆ∫
- [[002-Affine-Type-Theory]] - ‰ªøÂ∞ÑÁ±ªÂûãÁêÜËÆ∫
- [[003-Temporal-Type-Theory]] - Êó∂ÊÄÅÁ±ªÂûãÁêÜËÆ∫
- [[004-Quantum-Type-Theory]] - ÈáèÂ≠êÁ±ªÂûãÁêÜËÆ∫
- [[005-Denotational-Semantics]] - ÊåáÁß∞ËØ≠‰πâ
- [[007-Axiomatic-Semantics]] - ÂÖ¨ÁêÜËØ≠‰πâ
- [[008-Category-Semantics]] - ËåÉÁï¥ËØ≠‰πâ
- [[haskell/02-Type-System]] - Haskell Á±ªÂûãÁ≥ªÁªü

**ÂèÇËÄÉÊñáÁåÆÔºö**

1. Plotkin, G. D. (1981). A structural approach to operational semantics. Technical report, DAIMI FN-19, Computer Science Department, Aarhus University.
2. Kahn, G. (1987). Natural semantics. In International Symposium on Theoretical Aspects of Computer Software (pp. 22-39). Springer.
3. Milner, R. (1989). Communication and concurrency. Prentice-Hall.
4. Pierce, B. C. (2002). Types and programming languages. MIT press.
