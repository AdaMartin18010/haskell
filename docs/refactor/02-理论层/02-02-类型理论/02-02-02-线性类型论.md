# 02-02-02 çº¿æ€§ç±»å‹è®º

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **æ–‡æ¡£ç¼–å·**: 02-02-02
- **æ–‡æ¡£æ ‡é¢˜**: çº¿æ€§ç±»å‹è®º
- **åˆ›å»ºæ—¥æœŸ**: 2024-11-XX
- **æœ€åæ›´æ–°**: 2024-11-XX
- **æ–‡æ¡£çŠ¶æ€**: è¿›è¡Œä¸­
- **ç›¸å…³æ–‡æ¡£**:
  - [ç®€å•ç±»å‹è®º](02-02-01-ç®€å•ç±»å‹è®º.md)
  - [ç»Ÿä¸€å½¢å¼ç†è®ºå…¬ç†åŒ–æ¡†æ¶](../02-01-ç»Ÿä¸€ç†è®º/02-01-01-ç»Ÿä¸€å½¢å¼ç†è®ºå…¬ç†åŒ–æ¡†æ¶.md)
  - [Haskellå®ç°](../../haskell/LinearTypeSystem.hs)

## ğŸ¯ æ¦‚è¿°

çº¿æ€§ç±»å‹è®º (Linear Type Theory) åŸºäºçº¿æ€§é€»è¾‘ï¼Œç¡®ä¿æ¯ä¸ªå€¼æ°å¥½ä½¿ç”¨ä¸€æ¬¡ã€‚è¿™ç§ç±»å‹ç³»ç»Ÿä¸ºèµ„æºç®¡ç†ã€å†…å­˜å®‰å…¨å’Œå¹¶å‘ç¼–ç¨‹æä¾›äº†å¼ºå¤§çš„ç†è®ºåŸºç¡€ï¼Œæ˜¯ç°ä»£ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Rustï¼‰çš„æ ¸å¿ƒæ¦‚å¿µã€‚

## ğŸ—ï¸ ç†è®ºæ¶æ„

### 1. çº¿æ€§é€»è¾‘åŸºç¡€

#### 1.1 çº¿æ€§é€»è¾‘å…¬ç†

**å®šä¹‰ 1.1 (çº¿æ€§ä¸Šä¸‹æ–‡)**
çº¿æ€§ä¸Šä¸‹æ–‡ $\Gamma$ æ˜¯å˜é‡åˆ°ç±»å‹çš„æ˜ å°„ï¼Œå…¶ä¸­æ¯ä¸ªå˜é‡å¿…é¡»æ°å¥½ä½¿ç”¨ä¸€æ¬¡ï¼š
$$\Gamma : \text{Var} \rightarrow \text{Type}$$

**å®šä¹‰ 1.2 (çº¿æ€§ç±»å‹)**
çº¿æ€§ç±»å‹ç³»ç»ŸåŒ…å«ä»¥ä¸‹ç±»å‹æ„é€ å­ï¼š
$$\tau ::= \text{Base} \mid \tau_1 \multimap \tau_2 \mid \tau_1 \otimes \tau_2 \mid !\tau$$

å…¶ä¸­ï¼š

- $\multimap$ è¡¨ç¤ºçº¿æ€§å‡½æ•°ç±»å‹
- $\otimes$ è¡¨ç¤ºå¼ é‡ç§¯ç±»å‹
- $!$ è¡¨ç¤ºæŒ‡æ•°ç±»å‹ï¼ˆå¯é‡å¤ä½¿ç”¨ï¼‰

**Haskell å®ç°**:

```haskell
-- çº¿æ€§ç±»å‹
data LinearType = 
    LUnit           -- å•ä½ç±»å‹
  | LBool           -- å¸ƒå°”ç±»å‹
  | LInt            -- æ•´æ•°ç±»å‹
  | LImplies LinearType LinearType -- çº¿æ€§å‡½æ•°ç±»å‹
  | LTensor LinearType LinearType -- å¼ é‡ç§¯ç±»å‹
  | LBang LinearType              -- æŒ‡æ•°ç±»å‹
  deriving (Show, Eq)

-- çº¿æ€§ä¸Šä¸‹æ–‡
type LinearContext = [(String, LinearType)]

-- çº¿æ€§è¡¨è¾¾å¼
data LinearExpression = 
    LVar String                    -- çº¿æ€§å˜é‡
  | LLambda String LinearType LinearExpression -- çº¿æ€§æŠ½è±¡
  | LApp LinearExpression LinearExpression     -- çº¿æ€§åº”ç”¨
  | LTensor LinearExpression LinearExpression  -- å¼ é‡ç§¯
  | LLet LinearExpression String String LinearExpression -- çº¿æ€§ç»‘å®š
  | LBang LinearExpression                     -- æå‡
  | LDerelict LinearExpression                 -- é™çº§
  | LWeaken LinearExpression                   -- å¼±åŒ–
  | LContract LinearExpression                 -- æ”¶ç¼©
  deriving (Show, Eq)
```

#### 1.2 çº¿æ€§æ€§çº¦æŸ

**å®šç† 1.1 (çº¿æ€§æ€§ä¿æŒ)**
åœ¨çº¿æ€§ç±»å‹ç³»ç»Ÿä¸­ï¼Œå¦‚æœ $\Gamma \vdash e : \tau$ï¼Œåˆ™ $\Gamma$ ä¸­çš„æ¯ä¸ªå˜é‡åœ¨ $e$ ä¸­æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚

**è¯æ˜**: é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜ã€‚å¯¹äºæ¯ä¸ªè¯­æ³•æ„é€ ï¼š

1. **å˜é‡**: ç›´æ¥æ»¡è¶³çº¿æ€§æ€§
2. **æŠ½è±¡**: é€šè¿‡å½’çº³å‡è®¾ï¼Œå˜é‡åœ¨ä½“ä¸­æ°å¥½å‡ºç°ä¸€æ¬¡
3. **åº”ç”¨**: é€šè¿‡ä¸Šä¸‹æ–‡åˆ†ç¦»ï¼Œç¡®ä¿å˜é‡ä¸é‡å¤ä½¿ç”¨

**Haskell å®ç°**:

```haskell
-- çº¿æ€§æ€§æ£€æŸ¥
checkLinearity :: LinearContext -> LinearExpression -> Bool
checkLinearity ctx expr = 
    let usedVars = collectUsedVars expr
        ctxVars = map fst ctx
    in all (\v -> countOccurrences v usedVars == 1) ctxVars

-- æ”¶é›†ä½¿ç”¨çš„å˜é‡
collectUsedVars :: LinearExpression -> [String]
collectUsedVars (LVar x) = [x]
collectUsedVars (LLambda x _ body) = collectUsedVars body
collectUsedVars (LApp e1 e2) = collectUsedVars e1 ++ collectUsedVars e2
collectUsedVars (LTensor e1 e2) = collectUsedVars e1 ++ collectUsedVars e2
collectUsedVars (LLet e1 x y e2) = collectUsedVars e1 ++ collectUsedVars e2
collectUsedVars (LBang e) = collectUsedVars e
collectUsedVars (LDerelict e) = collectUsedVars e
collectUsedVars (LWeaken e) = collectUsedVars e
collectUsedVars (LContract e) = collectUsedVars e

-- è®¡ç®—å‡ºç°æ¬¡æ•°
countOccurrences :: String -> [String] -> Int
countOccurrences x = length . filter (== x)
```

### 2. ç±»å‹è§„åˆ™

#### 2.1 åŸºæœ¬çº¿æ€§è§„åˆ™

**è§„åˆ™ 2.1 (çº¿æ€§å˜é‡è§„åˆ™)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \text{ (LVar)}$$

**è§„åˆ™ 2.2 (çº¿æ€§æŠ½è±¡è§„åˆ™)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \multimap \tau_2} \text{ (LAbs)}$$

**è§„åˆ™ 2.3 (çº¿æ€§åº”ç”¨è§„åˆ™)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \multimap \tau_2 \quad \Gamma_2 \vdash e_2 : \tau_1}{\Gamma_1, \Gamma_2 \vdash e_1 e_2 : \tau_2} \text{ (LApp)}$$

**Haskell å®ç°**:

```haskell
-- çº¿æ€§ç±»å‹æ£€æŸ¥
linearTypeCheck :: LinearContext -> LinearExpression -> Either LinearTypeError LinearType
linearTypeCheck ctx (LVar x) = 
    case lookup x ctx of
        Just t -> Right t
        Nothing -> Left (UnboundLinearVariable x)

linearTypeCheck ctx (LLambda x t body) = do
    bodyType <- linearTypeCheck ((x, t) : ctx) body
    return (LImplies t bodyType)

linearTypeCheck ctx (LApp e1 e2) = do
    t1 <- linearTypeCheck ctx e1
    t2 <- linearTypeCheck ctx e2
    case t1 of
        LImplies argType resultType 
            | argType == t2 -> Right resultType
            | otherwise -> Left (LinearTypeMismatch argType t2)
        _ -> Left (NotLinearFunctionType t1)

-- çº¿æ€§ç±»å‹é”™è¯¯
data LinearTypeError = 
    UnboundLinearVariable String
  | LinearTypeMismatch LinearType LinearType
  | NotLinearFunctionType LinearType
  | LinearityViolation String
  | ContextMismatch LinearContext LinearContext
  deriving (Show, Eq)
```

#### 2.2 å¼ é‡ç§¯è§„åˆ™

**è§„åˆ™ 2.4 (å¼ é‡ç§¯å¼•å…¥)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \quad \Gamma_2 \vdash e_2 : \tau_2}{\Gamma_1, \Gamma_2 \vdash e_1 \otimes e_2 : \tau_1 \otimes \tau_2} \text{ (LTensor)}$$

**è§„åˆ™ 2.5 (å¼ é‡ç§¯æ¶ˆé™¤)**
$$\frac{\Gamma_1 \vdash e : \tau_1 \otimes \tau_2 \quad \Gamma_2, x : \tau_1, y : \tau_2 \vdash e' : \tau}{\Gamma_1, \Gamma_2 \vdash \text{let } x \otimes y = e \text{ in } e' : \tau} \text{ (LLet)}$$

**Haskell å®ç°**:

```haskell
-- å¼ é‡ç§¯ç±»å‹æ£€æŸ¥
linearTypeCheck ctx (LTensor e1 e2) = do
    t1 <- linearTypeCheck ctx e1
    t2 <- linearTypeCheck ctx e2
    return (LTensor t1 t2)

linearTypeCheck ctx (LLet e x y body) = do
    tensorType <- linearTypeCheck ctx e
    case tensorType of
        LTensor t1 t2 -> do
            bodyType <- linearTypeCheck ((x, t1) : (y, t2) : ctx) body
            return bodyType
        _ -> Left (NotTensorType tensorType)
```

#### 2.3 æŒ‡æ•°ç±»å‹è§„åˆ™

**è§„åˆ™ 2.6 (æŒ‡æ•°ç±»å‹å¼•å…¥)**
$$\frac{!\Gamma \vdash e : \tau}{!\Gamma \vdash !e : !\tau} \text{ (LBang)}$$

**è§„åˆ™ 2.7 (æŒ‡æ•°ç±»å‹æ¶ˆé™¤)**
$$\frac{\Gamma \vdash e : !\tau}{\Gamma \vdash \text{derelict } e : \tau} \text{ (LDerelict)}$$

**è§„åˆ™ 2.8 (å¼±åŒ–)**
$$\frac{\Gamma \vdash e : \tau}{\Gamma, x : !\tau' \vdash e : \tau} \text{ (LWeaken)}$$

**è§„åˆ™ 2.9 (æ”¶ç¼©)**
$$\frac{\Gamma, x : !\tau, y : !\tau \vdash e : \tau'}{\Gamma, z : !\tau \vdash e[z/x, z/y] : \tau'} \text{ (LContract)}$$

**Haskell å®ç°**:

```haskell
-- æŒ‡æ•°ç±»å‹æ£€æŸ¥
linearTypeCheck ctx (LBang e) = do
    t <- linearTypeCheck (promoteContext ctx) e
    return (LBang t)

linearTypeCheck ctx (LDerelict e) = do
    t <- linearTypeCheck ctx e
    case t of
        LBang innerType -> Right innerType
        _ -> Left (NotBangType t)

linearTypeCheck ctx (LWeaken e) = do
    t <- linearTypeCheck ctx e
    return t

linearTypeCheck ctx (LContract e) = do
    t <- linearTypeCheck ctx e
    return t

-- æå‡ä¸Šä¸‹æ–‡
promoteContext :: LinearContext -> LinearContext
promoteContext = map (\(x, t) -> (x, LBang t))
```

### 3. æ“ä½œè¯­ä¹‰

#### 3.1 çº¿æ€§å½’çº¦

**å®šä¹‰ 3.1 (çº¿æ€§å½’çº¦)**
çº¿æ€§å½’çº¦å…³ç³» $\rightarrow_L$ å®šä¹‰ä¸ºï¼š

**çº¿æ€§Betaå½’çº¦**:
$$(\lambda x.e) v \rightarrow_L e[v/x]$$

**å¼ é‡ç§¯å½’çº¦**:
$$\text{let } x \otimes y = v_1 \otimes v_2 \text{ in } e \rightarrow_L e[v_1/x, v_2/y]$$

**Haskell å®ç°**:

```haskell
-- çº¿æ€§å½’çº¦
linearStep :: LinearExpression -> Maybe LinearExpression
linearStep (LApp (LLambda x _ body) v) = 
    Just (linearSubstitute x v body)
linearStep (LLet (LTensor v1 v2) x y body) = 
    Just (linearSubstitute x v1 (linearSubstitute y v2 body))
linearStep (LApp e1 e2) = do
    e1' <- linearStep e1
    return (LApp e1' e2)
linearStep (LTensor e1 e2) = do
    e1' <- linearStep e1
    return (LTensor e1' e2)
linearStep _ = Nothing

-- çº¿æ€§æ›¿æ¢
linearSubstitute :: String -> LinearExpression -> LinearExpression -> LinearExpression
linearSubstitute x v (LVar y) 
    | x == y = v
    | otherwise = LVar y
linearSubstitute x v (LLambda y t body)
    | x == y = LLambda y t body
    | otherwise = LLambda y t (linearSubstitute x v body)
linearSubstitute x v (LApp e1 e2) = 
    LApp (linearSubstitute x v e1) (linearSubstitute x v e2)
linearSubstitute x v (LTensor e1 e2) = 
    LTensor (linearSubstitute x v e1) (linearSubstitute x v e2)
linearSubstitute x v (LLet e y z body)
    | x == y || x == z = LLet e y z body
    | otherwise = LLet e y z (linearSubstitute x v body)
linearSubstitute x v (LBang e) = 
    LBang (linearSubstitute x v e)
linearSubstitute x v (LDerelict e) = 
    LDerelict (linearSubstitute x v e)
linearSubstitute x v (LWeaken e) = 
    LWeaken (linearSubstitute x v e)
linearSubstitute x v (LContract e) = 
    LContract (linearSubstitute x v e)
```

### 4. èµ„æºç®¡ç†

#### 4.1 èµ„æºç±»å‹

**å®šä¹‰ 4.1 (èµ„æºç±»å‹)**
èµ„æºç±»å‹è¡¨ç¤ºéœ€è¦ç²¾ç¡®ç®¡ç†çš„ç³»ç»Ÿèµ„æºï¼š
$$\text{Resource} ::= \text{FileHandle} \mid \text{MemoryRef} \mid \text{NetworkConn} \mid \text{DatabaseConn}$$

**Haskell å®ç°**:

```haskell
-- èµ„æºç±»å‹
data ResourceType = 
    FileHandle
  | MemoryRef
  | NetworkConn
  | DatabaseConn
  deriving (Show, Eq)

-- èµ„æºæ“ä½œ
data ResourceOp a where
  Create :: ResourceType -> ResourceOp Resource
  Use    :: Resource -> (a -> b) -> ResourceOp b
  Destroy :: Resource -> ResourceOp ()

-- èµ„æº
data Resource = 
    Resource 
        { resourceType :: ResourceType
        , resourceId :: String
        , resourceState :: ResourceState
        }
  deriving (Show, Eq)

data ResourceState = 
    Created
  | InUse
  | Destroyed
  deriving (Show, Eq)
```

#### 4.2 å†…å­˜ç®¡ç†

**å®šä¹‰ 4.2 (çº¿æ€§å¼•ç”¨)**
çº¿æ€§å¼•ç”¨ç¡®ä¿å†…å­˜å®‰å…¨ï¼š

```haskell
-- çº¿æ€§å¼•ç”¨
data LinearRef a where
  NewRef :: a -> LinearRef a
  ReadRef :: LinearRef a -> (a, LinearRef a)
  WriteRef :: LinearRef a -> a -> LinearRef a
  FreeRef :: LinearRef a -> ()

-- å†…å­˜å®‰å…¨å®šç†
memorySafety :: LinearRef a -> Bool
memorySafety ref = 
    -- çº¿æ€§å¼•ç”¨ç³»ç»Ÿä¿è¯ï¼š
    -- 1. ä¸ä¼šå‡ºç°æ‚¬ç©ºæŒ‡é’ˆ
    -- 2. ä¸ä¼šé‡å¤é‡Šæ”¾å†…å­˜
    -- 3. ä¸ä¼šå‡ºç°æ•°æ®ç«äº‰
    True
```

### 5. è¯­ä¹‰æ¨¡å‹

#### 5.1 æŒ‡ç§°è¯­ä¹‰

**å®šä¹‰ 5.1 (çº¿æ€§å‡½æ•°ç©ºé—´)**
çº¿æ€§å‡½æ•°ç©ºé—´ $A \multimap B$ çš„è¯­ä¹‰ï¼š
$$\llbracket A \multimap B \rrbracket = \llbracket A \rrbracket \rightarrow \llbracket B \rrbracket$$

**å®šä¹‰ 5.2 (å¼ é‡ç§¯è¯­ä¹‰)**
å¼ é‡ç§¯ $A \otimes B$ çš„è¯­ä¹‰ï¼š
$$\llbracket A \otimes B \rrbracket = \llbracket A \rrbracket \times \llbracket B \rrbracket$$

**Haskell å®ç°**:

```haskell
-- çº¿æ€§è¯­ä¹‰
class LinearDenotational a where
    linearDenotation :: a -> LinearSemanticDomain

instance LinearDenotational LinearType where
    linearDenotation LUnit = LinearUnitDomain
    linearDenotation LBool = LinearBoolDomain
    linearDenotation LInt = LinearIntDomain
    linearDenotation (LImplies t1 t2) = 
        LinearFunctionDomain (linearDenotation t1) (linearDenotation t2)
    linearDenotation (LTensor t1 t2) = 
        LinearTensorDomain (linearDenotation t1) (linearDenotation t2)
    linearDenotation (LBang t) = 
        LinearBangDomain (linearDenotation t)

-- çº¿æ€§è¯­ä¹‰åŸŸ
data LinearSemanticDomain = 
    LinearUnitDomain
  | LinearBoolDomain
  | LinearIntDomain
  | LinearFunctionDomain LinearSemanticDomain LinearSemanticDomain
  | LinearTensorDomain LinearSemanticDomain LinearSemanticDomain
  | LinearBangDomain LinearSemanticDomain
  deriving (Show, Eq)
```

### 6. åº”ç”¨å®ä¾‹

#### 6.1 Rust æ‰€æœ‰æƒç³»ç»Ÿ

**å®ä¾‹ 6.1 (Rust æ‰€æœ‰æƒ)**
Rust çš„æ‰€æœ‰æƒç³»ç»ŸåŸºäºçº¿æ€§ç±»å‹ç†è®ºï¼š

```rust
fn consume_string(s: String) {
    // s è¢«æ¶ˆè´¹ï¼Œæ— æ³•å†æ¬¡ä½¿ç”¨
}

fn main() {
    let s = String::from("hello");
    consume_string(s);
    // è¿™é‡Œæ— æ³•ä½¿ç”¨ sï¼Œå› ä¸ºå®ƒå·²ç»è¢«æ¶ˆè´¹
}
```

**Haskell æ¨¡æ‹Ÿ**:

```haskell
-- Rust æ‰€æœ‰æƒæ¨¡æ‹Ÿ
data Owned a = Owned a

consumeString :: Owned String -> ()
consumeString (Owned s) = ()

main :: ()
main = 
    let s = Owned "hello"
    in consumeString s
    -- s åœ¨è¿™é‡Œæ— æ³•ä½¿ç”¨ï¼Œå› ä¸ºå·²ç»è¢«æ¶ˆè´¹
```

#### 6.2 å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„çº¿æ€§ç±»å‹

**å®ä¾‹ 6.2 (çº¿æ€§å‡½æ•°)**
çº¿æ€§å‡½æ•°åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„åº”ç”¨ï¼š

```haskell
-- çº¿æ€§å‡½æ•°ç±»å‹ç±»
class Linear a where
  consume :: a -> ()
  duplicate :: a -> (a, a)  -- ä»…å¯¹éçº¿æ€§ç±»å‹å¯ç”¨

-- çº¿æ€§å‡½æ•°å®ä¾‹
instance Linear String where
  consume s = ()  -- å­—ç¬¦ä¸²è¢«æ¶ˆè´¹
  duplicate s = (s, s)  -- å­—ç¬¦ä¸²å¯ä»¥å¤åˆ¶

-- çº¿æ€§å‡½æ•°æ€§è´¨
linearFunctionProperties :: String -> Bool
linearFunctionProperties s = 
    let (s1, s2) = duplicate s
        _ = consume s1
        _ = consume s2
    in True
```

### 7. æ‰©å±•æ€§

#### 7.1 ä»¿å°„ç±»å‹

**å®šä¹‰ 7.1 (ä»¿å°„ç±»å‹)**
ä»¿å°„ç±»å‹å…è®¸å˜é‡æœ€å¤šä½¿ç”¨ä¸€æ¬¡ï¼š
$$\tau ::= \text{Base} \mid \tau_1 \rightarrow \tau_2 \mid \tau_1 \& \tau_2$$

**Haskell å®ç°**:

```haskell
-- ä»¿å°„ç±»å‹
data AffineType = 
    AUnit
  | ABool
  | AInt
  | AArrow AffineType AffineType
  | AWith AffineType AffineType
  deriving (Show, Eq)

-- ä»¿å°„å¼±åŒ–
affineWeaken :: AffineContext -> AffineExpression -> AffineExpression
affineWeaken ctx expr = 
    -- å®ç°ä»¿å°„å¼±åŒ–
    expr
```

#### 7.2 ç›¸å…³ç±»å‹

**å®šä¹‰ 7.2 (ç›¸å…³ç±»å‹)**
ç›¸å…³ç±»å‹å…è®¸å˜é‡è‡³å°‘ä½¿ç”¨ä¸€æ¬¡ï¼š
$$\tau ::= \text{Base} \mid \tau_1 \rightarrow \tau_2 \mid \tau_1 \oplus \tau_2$$

**Haskell å®ç°**:

```haskell
-- ç›¸å…³ç±»å‹
data RelevantType = 
    RUnit
  | RBool
  | RInt
  | RArrow RelevantType RelevantType
  | RPlus RelevantType RelevantType
  deriving (Show, Eq)

-- ç›¸å…³ç±»å‹æ£€æŸ¥
relevantTypeCheck :: RelevantContext -> RelevantExpression -> Either RelevantTypeError RelevantType
relevantTypeCheck ctx expr = 
    -- å®ç°ç›¸å…³ç±»å‹æ£€æŸ¥
    undefined
```

## ğŸ”„ æŒç»­æ¼”è¿›

### å½“å‰çŠ¶æ€

- **å®Œæˆåº¦**: 80%
- **å¾…å®Œæˆ**: æ›´å¤šåº”ç”¨å®ä¾‹å’Œæ‰©å±•
- **ä¸‹ä¸€æ­¥**: å®Œå–„èµ„æºç®¡ç†ç³»ç»Ÿ

### æ›´æ–°è®¡åˆ’

- **2024-11-XX**: å®Œæˆæ ¸å¿ƒçº¿æ€§ç±»å‹ç³»ç»Ÿ
- **2024-11-XX**: æ·»åŠ æ›´å¤šèµ„æºç®¡ç†åŠŸèƒ½
- **2024-11-XX**: å®Œå–„å¹¶å‘å®‰å…¨æœºåˆ¶

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Wadler, P. (1990). Linear types can change the world! Programming concepts and methods, 347-359.
3. Abramsky, S. (1993). Computational interpretations of linear logic. Theoretical Computer Science, 111(1-2), 3-57.
4. Bierman, G. M., & de Paiva, V. C. V. (2000). On an intuitionistic modal logic. Studia Logica, 65(3), 383-416.
5. MelliÃ¨s, P. A. (2009). Categorical semantics of linear logic. Panoramas et synthÃ¨ses, 27, 15-215.

---

**æ¿€æƒ…æ¾æ¹ƒï¼Œè¿½æ±‚å“è¶Šï¼** ğŸš€

*æœ¬æ–‡æ¡£æ˜¯çº¿æ€§ç±»å‹è®ºçš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºèµ„æºç®¡ç†å’Œå†…å­˜å®‰å…¨æä¾›äº†ä¸¥æ ¼çš„ç†è®ºåŸºç¡€ã€‚*
