# 02-02-01 ç®€å•ç±»å‹è®º

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **æ–‡æ¡£ç¼–å·**: 02-02-01
- **æ–‡æ¡£æ ‡é¢˜**: ç®€å•ç±»å‹è®º
- **åˆ›å»ºæ—¥æœŸ**: 2024-11-XX
- **æœ€åæ›´æ–°**: 2024-11-XX
- **æ–‡æ¡£çŠ¶æ€**: è¿›è¡Œä¸­
- **ç›¸å…³æ–‡æ¡£**:
  - [ç»Ÿä¸€å½¢å¼ç†è®ºå…¬ç†åŒ–æ¡†æ¶](../02-01-ç»Ÿä¸€ç†è®º/02-01-01-ç»Ÿä¸€å½¢å¼ç†è®ºå…¬ç†åŒ–æ¡†æ¶.md)
  - [çº¿æ€§ç±»å‹è®º](02-02-02-çº¿æ€§ç±»å‹è®º.md)
  - [ä¾èµ–ç±»å‹è®º](02-02-03-ä¾èµ–ç±»å‹è®º.md)
  - [Haskellå®ç°](../../haskell/TypeSystem.hs)

## ğŸ¯ æ¦‚è¿°

ç®€å•ç±»å‹è®º (Simply Typed Lambda Calculus, STLC) æ˜¯ç±»å‹ç†è®ºçš„åŸºç¡€ï¼Œä¸ºå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€æä¾›äº†ä¸¥æ ¼çš„æ•°å­¦åŸºç¡€ã€‚å®ƒé€šè¿‡ç±»å‹ç³»ç»Ÿç¡®ä¿ç¨‹åºçš„å®‰å…¨æ€§å’Œæ­£ç¡®æ€§ï¼Œæ˜¯ç°ä»£ç¼–ç¨‹è¯­è¨€è®¾è®¡çš„æ ¸å¿ƒç†è®ºã€‚

## ğŸ—ï¸ ç†è®ºæ¶æ„

### 1. è¯­æ³•å®šä¹‰

#### 1.1 ç±»å‹è¯­æ³•

**å®šä¹‰ 1.1 (ç±»å‹è¯­æ³•)**
ç®€å•ç±»å‹è®ºçš„ç±»å‹è¯­æ³•å®šä¹‰ä¸ºï¼š
$$\tau ::= \text{Base} \mid \tau_1 \rightarrow \tau_2$$

å…¶ä¸­ï¼š

- $\text{Base}$ è¡¨ç¤ºåŸºç¡€ç±»å‹ï¼ˆå¦‚ $\text{Bool}$, $\text{Int}$, $\text{Unit}$ï¼‰
- $\tau_1 \rightarrow \tau_2$ è¡¨ç¤ºå‡½æ•°ç±»å‹

**Haskell å®ç°**:

```haskell
-- ç±»å‹è¯­æ³•
data Type = 
    TUnit           -- å•ä½ç±»å‹
  | TBool           -- å¸ƒå°”ç±»å‹
  | TInt            -- æ•´æ•°ç±»å‹
  | TFloat          -- æµ®ç‚¹ç±»å‹
  | TString         -- å­—ç¬¦ä¸²ç±»å‹
  | TArrow Type Type -- å‡½æ•°ç±»å‹
  | TProduct Type Type -- ç§¯ç±»å‹
  | TSum Type Type     -- å’Œç±»å‹
  deriving (Show, Eq)

-- ç±»å‹ä¸Šä¸‹æ–‡
type Context = [(String, Type)]

-- ç±»å‹åˆ¤æ–­
data TypeJudgment = 
    TypeJudgment 
        { context :: Context
        , expression :: Expression
        , type_ :: Type
        }
  deriving (Show, Eq)
```

#### 1.2 è¡¨è¾¾å¼è¯­æ³•

**å®šä¹‰ 1.2 (è¡¨è¾¾å¼è¯­æ³•)**
ç®€å•ç±»å‹è®ºçš„è¡¨è¾¾å¼è¯­æ³•å®šä¹‰ä¸ºï¼š
$$e ::= x \mid \lambda x : \tau.e \mid e_1 e_2 \mid c$$

å…¶ä¸­ï¼š

- $x$ è¡¨ç¤ºå˜é‡
- $\lambda x : \tau.e$ è¡¨ç¤ºç±»å‹åŒ–æŠ½è±¡
- $e_1 e_2$ è¡¨ç¤ºå‡½æ•°åº”ç”¨
- $c$ è¡¨ç¤ºå¸¸é‡

**Haskell å®ç°**:

```haskell
-- è¡¨è¾¾å¼è¯­æ³•
data Expression = 
    Var String                    -- å˜é‡
  | Lambda String Type Expression -- ç±»å‹åŒ–æŠ½è±¡
  | App Expression Expression     -- å‡½æ•°åº”ç”¨
  | Unit                          -- å•ä½å€¼
  | Bool Bool                     -- å¸ƒå°”å€¼
  | Int Int                       -- æ•´æ•°å€¼
  | Float Float                   -- æµ®ç‚¹å€¼
  | String String                 -- å­—ç¬¦ä¸²å€¼
  | Pair Expression Expression    -- åºå¯¹
  | Fst Expression                -- ç¬¬ä¸€æŠ•å½±
  | Snd Expression                -- ç¬¬äºŒæŠ•å½±
  | Inl Expression                -- å·¦æ³¨å…¥
  | Inr Expression                -- å³æ³¨å…¥
  | Case Expression String Expression String Expression -- æ¨¡å¼åŒ¹é…
  | If Expression Expression Expression -- æ¡ä»¶è¡¨è¾¾å¼
  deriving (Show, Eq)

-- å€¼
data Value = 
    VUnit
  | VBool Bool
  | VInt Int
  | VFloat Float
  | VString String
  | VPair Value Value
  | VInl Value
  | VInr Value
  | VClosure String Expression Context
  deriving (Show, Eq)
```

### 2. ç±»å‹è§„åˆ™

#### 2.1 åŸºæœ¬ç±»å‹è§„åˆ™

**è§„åˆ™ 2.1 (å˜é‡è§„åˆ™)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \text{ (Var)}$$

**è§„åˆ™ 2.2 (æŠ½è±¡è§„åˆ™)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x : \tau_1.e : \tau_1 \rightarrow \tau_2} \text{ (Abs)}$$

**è§„åˆ™ 2.3 (åº”ç”¨è§„åˆ™)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2} \text{ (App)}$$

**Haskell å®ç°**:

```haskell
-- ç±»å‹æ£€æŸ¥
typeCheck :: Context -> Expression -> Either TypeError Type
typeCheck ctx (Var x) = 
    case lookup x ctx of
        Just t -> Right t
        Nothing -> Left (UnboundVariable x)

typeCheck ctx (Lambda x t body) = do
    bodyType <- typeCheck ((x, t) : ctx) body
    return (TArrow t bodyType)

typeCheck ctx (App e1 e2) = do
    t1 <- typeCheck ctx e1
    t2 <- typeCheck ctx e2
    case t1 of
        TArrow argType resultType 
            | argType == t2 -> Right resultType
            | otherwise -> Left (TypeMismatch argType t2)
        _ -> Left (NotFunctionType t1)

-- ç±»å‹é”™è¯¯
data TypeError = 
    UnboundVariable String
  | TypeMismatch Type Type
  | NotFunctionType Type
  | InvalidOperation String
  deriving (Show, Eq)
```

#### 2.2 ç§¯ç±»å‹è§„åˆ™

**è§„åˆ™ 2.4 (ç§¯ç±»å‹å¼•å…¥)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2}{\Gamma \vdash (e_1, e_2) : \tau_1 \times \tau_2} \text{ (Pair)}$$

**è§„åˆ™ 2.5 (ç§¯ç±»å‹æ¶ˆé™¤)**
$$\frac{\Gamma \vdash e : \tau_1 \times \tau_2}{\Gamma \vdash \text{fst } e : \tau_1} \text{ (Fst)}$$

$$\frac{\Gamma \vdash e : \tau_1 \times \tau_2}{\Gamma \vdash \text{snd } e : \tau_2} \text{ (Snd)}$$

**Haskell å®ç°**:

```haskell
-- ç§¯ç±»å‹æ£€æŸ¥
typeCheck ctx (Pair e1 e2) = do
    t1 <- typeCheck ctx e1
    t2 <- typeCheck ctx e2
    return (TProduct t1 t2)

typeCheck ctx (Fst e) = do
    t <- typeCheck ctx e
    case t of
        TProduct t1 _ -> Right t1
        _ -> Left (NotProductType t)

typeCheck ctx (Snd e) = do
    t <- typeCheck ctx e
    case t of
        TProduct _ t2 -> Right t2
        _ -> Left (NotProductType t)
```

#### 2.3 å’Œç±»å‹è§„åˆ™

**è§„åˆ™ 2.6 (å’Œç±»å‹å¼•å…¥)**
$$\frac{\Gamma \vdash e : \tau_1}{\Gamma \vdash \text{inl } e : \tau_1 + \tau_2} \text{ (Inl)}$$

$$\frac{\Gamma \vdash e : \tau_2}{\Gamma \vdash \text{inr } e : \tau_1 + \tau_2} \text{ (Inr)}$$

**è§„åˆ™ 2.7 (å’Œç±»å‹æ¶ˆé™¤)**
$$\frac{\Gamma \vdash e : \tau_1 + \tau_2 \quad \Gamma, x : \tau_1 \vdash e_1 : \tau \quad \Gamma, y : \tau_2 \vdash e_2 : \tau}{\Gamma \vdash \text{case } e \text{ of inl } x \Rightarrow e_1 \text{ | inr } y \Rightarrow e_2 : \tau} \text{ (Case)}$$

**Haskell å®ç°**:

```haskell
-- å’Œç±»å‹æ£€æŸ¥
typeCheck ctx (Inl e) = do
    t <- typeCheck ctx e
    -- è¿™é‡Œéœ€è¦ç±»å‹æ³¨è§£æˆ–ç±»å‹æ¨æ–­æ¥ç¡®å®šå®Œæ•´çš„å’Œç±»å‹
    return (TSum t (TUnit)) -- ç®€åŒ–å¤„ç†

typeCheck ctx (Inr e) = do
    t <- typeCheck ctx e
    return (TSum (TUnit) t) -- ç®€åŒ–å¤„ç†

typeCheck ctx (Case e x e1 y e2) = do
    sumType <- typeCheck ctx e
    case sumType of
        TSum t1 t2 -> do
            resultType1 <- typeCheck ((x, t1) : ctx) e1
            resultType2 <- typeCheck ((y, t2) : ctx) e2
            if resultType1 == resultType2
                then Right resultType1
                else Left (TypeMismatch resultType1 resultType2)
        _ -> Left (NotSumType sumType)
```

### 3. æ“ä½œè¯­ä¹‰

#### 3.1 å°æ­¥è¯­ä¹‰

**å®šä¹‰ 3.1 (å°æ­¥å½’çº¦)**
å°æ­¥å½’çº¦å…³ç³» $\rightarrow$ å®šä¹‰ä¸ºï¼š

**Betaå½’çº¦**:
$$(\lambda x : \tau.e) v \rightarrow e[v/x]$$

**æŠ•å½±å½’çº¦**:
$$\text{fst } (v_1, v_2) \rightarrow v_1$$
$$\text{snd } (v_1, v_2) \rightarrow v_2$$

**æ¨¡å¼åŒ¹é…å½’çº¦**:
$$\text{case inl } v \text{ of inl } x \Rightarrow e_1 \text{ | inr } y \Rightarrow e_2 \rightarrow e_1[v/x]$$
$$\text{case inr } v \text{ of inl } x \Rightarrow e_1 \text{ | inr } y \Rightarrow e_2 \rightarrow e_2[v/y]$$

**Haskell å®ç°**:

```haskell
-- å°æ­¥è¯­ä¹‰
step :: Expression -> Maybe Expression
step (App (Lambda x _ body) v) = 
    Just (substitute x v body)
step (Fst (Pair v1 v2)) = 
    Just v1
step (Snd (Pair v1 v2)) = 
    Just v2
step (Case (Inl v) x e1 y e2) = 
    Just (substitute x v e1)
step (Case (Inr v) x e1 y e2) = 
    Just (substitute y v e2)
step (App e1 e2) = do
    e1' <- step e1
    return (App e1' e2)
step (Pair e1 e2) = do
    e1' <- step e1
    return (Pair e1' e2)
step _ = Nothing

-- æ›¿æ¢
substitute :: String -> Expression -> Expression -> Expression
substitute x v (Var y) 
    | x == y = v
    | otherwise = Var y
substitute x v (Lambda y t body)
    | x == y = Lambda y t body
    | otherwise = Lambda y t (substitute x v body)
substitute x v (App e1 e2) = 
    App (substitute x v e1) (substitute x v e2)
substitute x v (Pair e1 e2) = 
    Pair (substitute x v e1) (substitute x v e2)
substitute x v (Fst e) = 
    Fst (substitute x v e)
substitute x v (Snd e) = 
    Snd (substitute x v e)
substitute x v (Inl e) = 
    Inl (substitute x v e)
substitute x v (Inr e) = 
    Inr (substitute x v e)
substitute x v (Case e y e1 z e2) = 
    Case (substitute x v e) y e1 z e2
substitute _ _ e = e
```

#### 3.2 å¤§æ­¥è¯­ä¹‰

**å®šä¹‰ 3.2 (å¤§æ­¥æ±‚å€¼)**
å¤§æ­¥æ±‚å€¼å…³ç³» $\Downarrow$ å®šä¹‰ä¸ºï¼š

**å€¼è§„åˆ™**:
$$v \Downarrow v$$

**åº”ç”¨è§„åˆ™**:
$$\frac{e_1 \Downarrow \lambda x : \tau.e \quad e_2 \Downarrow v \quad e[v/x] \Downarrow v'}{e_1 e_2 \Downarrow v'}$$

**Haskell å®ç°**:

```haskell
-- å¤§æ­¥è¯­ä¹‰
eval :: Expression -> Maybe Value
eval (Var x) = Nothing -- æœªç»‘å®šå˜é‡æ— æ³•æ±‚å€¼
eval (Lambda x t body) = 
    Just (VClosure x body [])
eval (App e1 e2) = do
    VClosure x body ctx <- eval e1
    v2 <- eval e2
    eval (substitute x e2 body)
eval Unit = Just VUnit
eval (Bool b) = Just (VBool b)
eval (Int n) = Just (VInt n)
eval (Float f) = Just (VFloat f)
eval (String s) = Just (VString s)
eval (Pair e1 e2) = do
    v1 <- eval e1
    v2 <- eval e2
    return (VPair v1 v2)
eval (Fst e) = do
    VPair v1 _ <- eval e
    return v1
eval (Snd e) = do
    VPair _ v2 <- eval e
    return v2
eval (Inl e) = do
    v <- eval e
    return (VInl v)
eval (Inr e) = do
    v <- eval e
    return (VInr v)
eval (Case e x e1 y e2) = do
    v <- eval e
    case v of
        VInl v1 -> eval (substitute x (valueToExpr v1) e1)
        VInr v2 -> eval (substitute y (valueToExpr v2) e2)
        _ -> Nothing
eval (If cond thenExpr elseExpr) = do
    VBool b <- eval cond
    if b then eval thenExpr else eval elseExpr

-- å€¼åˆ°è¡¨è¾¾å¼çš„è½¬æ¢
valueToExpr :: Value -> Expression
valueToExpr VUnit = Unit
valueToExpr (VBool b) = Bool b
valueToExpr (VInt n) = Int n
valueToExpr (VFloat f) = Float f
valueToExpr (VString s) = String s
valueToExpr (VPair v1 v2) = Pair (valueToExpr v1) (valueToExpr v2)
valueToExpr (VInl v) = Inl (valueToExpr v)
valueToExpr (VInr v) = Inr (valueToExpr v)
valueToExpr (VClosure x body ctx) = Lambda x TUnit body -- ç®€åŒ–å¤„ç†
```

### 4. ç±»å‹å®‰å…¨æ€§

#### 4.1 ç±»å‹ä¿æŒæ€§

**å®šç† 4.1 (ç±»å‹ä¿æŒæ€§)**
å¦‚æœ $\Gamma \vdash e : \tau$ ä¸” $e \rightarrow e'$ï¼Œåˆ™ $\Gamma \vdash e' : \tau$ã€‚

**è¯æ˜**:
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜ã€‚å¯¹äºæ¯ä¸ªå½’çº¦è§„åˆ™ï¼š

1. **Betaå½’çº¦**: $(\lambda x : \tau.e) v \rightarrow e[v/x]$
   - å¦‚æœ $\Gamma \vdash (\lambda x : \tau.e) v : \tau_2$
   - åˆ™ $\Gamma \vdash \lambda x : \tau.e : \tau \rightarrow \tau_2$ ä¸” $\Gamma \vdash v : \tau$
   - å› æ­¤ $\Gamma, x : \tau \vdash e : \tau_2$
   - é€šè¿‡æ›¿æ¢å¼•ç†ï¼Œ$\Gamma \vdash e[v/x] : \tau_2$

2. **æŠ•å½±å½’çº¦**: $\text{fst } (v_1, v_2) \rightarrow v_1$
   - å¦‚æœ $\Gamma \vdash \text{fst } (v_1, v_2) : \tau_1$
   - åˆ™ $\Gamma \vdash (v_1, v_2) : \tau_1 \times \tau_2$
   - å› æ­¤ $\Gamma \vdash v_1 : \tau_1$

#### 4.2 è¿›å±•æ€§

**å®šç† 4.2 (è¿›å±•æ€§)**
å¦‚æœ $\emptyset \vdash e : \tau$ï¼Œåˆ™è¦ä¹ˆ $e$ æ˜¯å€¼ï¼Œè¦ä¹ˆå­˜åœ¨ $e'$ ä½¿å¾— $e \rightarrow e'$ã€‚

**è¯æ˜**:
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜ã€‚å¯¹äºæ¯ä¸ªè¯­æ³•æ„é€ ï¼š

1. **å˜é‡**: åœ¨ç©ºä¸Šä¸‹æ–‡ä¸­æ— æ³•ç±»å‹åŒ–
2. **æŠ½è±¡**: $\lambda x : \tau.e$ æ˜¯å€¼
3. **åº”ç”¨**: $e_1 e_2$ï¼Œé€šè¿‡å½’çº³å‡è®¾ï¼Œ$e_1$ è¦ä¹ˆæ˜¯å€¼è¦ä¹ˆå¯ä»¥å½’çº¦
   - å¦‚æœ $e_1$ å¯ä»¥å½’çº¦ï¼Œåˆ™ $e_1 e_2$ å¯ä»¥å½’çº¦
   - å¦‚æœ $e_1$ æ˜¯å€¼ï¼Œåˆ™ $e_1 = \lambda x : \tau.e$ï¼Œå› æ­¤ $e_1 e_2$ å¯ä»¥Betaå½’çº¦

**Haskell å®ç°**:

```haskell
-- ç±»å‹ä¿æŒæ€§éªŒè¯
typePreservation :: Context -> Expression -> Bool
typePreservation ctx e = 
    case typeCheck ctx e of
        Right t -> 
            case step e of
                Just e' -> 
                    case typeCheck ctx e' of
                        Right t' -> t == t'
                        Left _ -> False
                Nothing -> True
        Left _ -> True

-- è¿›å±•æ€§éªŒè¯
progress :: Expression -> Bool
progress e = 
    case typeCheck [] e of
        Right _ -> isValue e || (step e /= Nothing)
        Left _ -> True

-- å€¼åˆ¤æ–­
isValue :: Expression -> Bool
isValue Unit = True
isValue (Bool _) = True
isValue (Int _) = True
isValue (Float _) = True
isValue (String _) = True
isValue (Lambda _ _ _) = True
isValue (Pair e1 e2) = isValue e1 && isValue e2
isValue (Inl e) = isValue e
isValue (Inr e) = isValue e
isValue _ = False
```

### 5. ç±»å‹æ¨æ–­

#### 5.1 Hindley-Milnerç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 5.1 (ç±»å‹å˜é‡)**
ç±»å‹å˜é‡ $\alpha$ ç”¨äºè¡¨ç¤ºæœªçŸ¥ç±»å‹ã€‚

**å®šä¹‰ 5.2 (ç±»å‹æ¨¡å¼)**
ç±»å‹æ¨¡å¼ $\sigma$ å®šä¹‰ä¸ºï¼š
$$\sigma ::= \tau \mid \forall \alpha.\sigma$$

**Haskell å®ç°**:

```haskell
-- ç±»å‹å˜é‡
data TypeVar = TypeVar String deriving (Show, Eq)

-- ç±»å‹æ¨¡å¼
data TypeScheme = 
    TypeScheme [TypeVar] Type
  | SimpleType Type
  deriving (Show, Eq)

-- ç±»å‹ç¯å¢ƒ
type TypeEnv = [(String, TypeScheme)]

-- ç±»å‹æ¨æ–­
inferType :: TypeEnv -> Expression -> Either TypeError (Type, Substitution)
inferType env (Var x) = 
    case lookup x env of
        Just (SimpleType t) -> Right (t, [])
        Just (TypeScheme vars t) -> 
            let freshVars = map (\v -> (v, freshTypeVar v)) vars
                t' = substituteTypeVars freshVars t
            in Right (t', [])
        Nothing -> Left (UnboundVariable x)

inferType env (Lambda x t body) = do
    (bodyType, s) <- inferType ((x, SimpleType t) : env) body
    return (TArrow t bodyType, s)

inferType env (App e1 e2) = do
    (t1, s1) <- inferType env e1
    (t2, s2) <- inferType (applySubst s1 env) e2
    alpha <- freshTypeVar "alpha"
    s3 <- unify (applySubst s2 t1) (TArrow t2 alpha)
    let resultType = applySubst s3 alpha
    let finalSubst = compose s3 (compose s2 s1)
    return (resultType, finalSubst)

-- ç±»å‹æ›¿æ¢
type Substitution = [(TypeVar, Type)]

applySubst :: Substitution -> Type -> Type
applySubst s (TArrow t1 t2) = TArrow (applySubst s t1) (applySubst s t2)
applySubst s (TProduct t1 t2) = TProduct (applySubst s t1) (applySubst s t2)
applySubst s (TSum t1 t2) = TSum (applySubst s t1) (applySubst s t2)
applySubst s (TVar alpha) = 
    case lookup alpha s of
        Just t -> t
        Nothing -> TVar alpha
applySubst _ t = t

-- åˆä¸€ç®—æ³•
unify :: Type -> Type -> Either TypeError Substitution
unify (TVar alpha) t = 
    if alpha `elem` freeTypeVars t 
        then Left (OccursCheck alpha t)
        else Right [(alpha, t)]
unify t (TVar alpha) = unify (TVar alpha) t
unify (TArrow t1 t2) (TArrow t1' t2') = do
    s1 <- unify t1 t1'
    s2 <- unify (applySubst s1 t2) (applySubst s1 t2')
    return (compose s2 s1)
unify (TProduct t1 t2) (TProduct t1' t2') = do
    s1 <- unify t1 t1'
    s2 <- unify (applySubst s1 t2) (applySubst s1 t2')
    return (compose s2 s1)
unify (TSum t1 t2) (TSum t1' t2') = do
    s1 <- unify t1 t1'
    s2 <- unify (applySubst s1 t2) (applySubst s1 t2')
    return (compose s2 s1)
unify t1 t2 = 
    if t1 == t2 then Right [] else Left (TypeMismatch t1 t2)
```

### 6. è¯­ä¹‰æ¨¡å‹

#### 6.1 æŒ‡ç§°è¯­ä¹‰

**å®šä¹‰ 6.1 (ç±»å‹è§£é‡Š)**
ç±»å‹ $\tau$ çš„æŒ‡ç§°è¯­ä¹‰ $\llbracket \tau \rrbracket$ å®šä¹‰ä¸ºï¼š

- $\llbracket \text{Unit} \rrbracket = \{*\}$
- $\llbracket \text{Bool} \rrbracket = \{\text{true}, \text{false}\}$
- $\llbracket \text{Int} \rrbracket = \mathbb{Z}$
- $\llbracket \tau_1 \rightarrow \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket \rightarrow \llbracket \tau_2 \rrbracket$
- $\llbracket \tau_1 \times \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket \times \llbracket \tau_2 \rrbracket$
- $\llbracket \tau_1 + \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket + \llbracket \tau_2 \rrbracket$

**Haskell å®ç°**:

```haskell
-- æŒ‡ç§°è¯­ä¹‰
class Denotational a where
    denotation :: a -> SemanticDomain

instance Denotational Type where
    denotation TUnit = UnitDomain
    denotation TBool = BoolDomain
    denotation TInt = IntDomain
    denotation TFloat = FloatDomain
    denotation TString = StringDomain
    denotation (TArrow t1 t2) = 
        FunctionDomain (denotation t1) (denotation t2)
    denotation (TProduct t1 t2) = 
        ProductDomain (denotation t1) (denotation t2)
    denotation (TSum t1 t2) = 
        SumDomain (denotation t1) (denotation t2)

-- è¯­ä¹‰åŸŸ
data SemanticDomain = 
    UnitDomain
  | BoolDomain
  | IntDomain
  | FloatDomain
  | StringDomain
  | FunctionDomain SemanticDomain SemanticDomain
  | ProductDomain SemanticDomain SemanticDomain
  | SumDomain SemanticDomain SemanticDomain
  deriving (Show, Eq)
```

### 7. åº”ç”¨å®ä¾‹

#### 7.1 å‡½æ•°å¼ç¼–ç¨‹

**å®ä¾‹ 7.1 (é«˜é˜¶å‡½æ•°)**
ç®€å•ç±»å‹è®ºæ”¯æŒé«˜é˜¶å‡½æ•°ï¼š

```haskell
-- é«˜é˜¶å‡½æ•°ç±»å‹
mapType :: Type -> Type -> Type
mapType a b = TArrow (TArrow a b) (TArrow (TList a) (TList b))

-- æ˜ å°„å‡½æ•°
mapFunction :: Expression
mapFunction = Lambda "f" (TArrow TInt TInt) 
    (Lambda "xs" (TList TInt) 
        (Case (Var "xs") "x" 
            (Cons (App (Var "f") (Var "x")) (App (App mapFunction (Var "f")) (Var "xs")))
            "xs" (Nil TInt)))

-- ç±»å‹æ£€æŸ¥
checkMap :: Bool
checkMap = case typeCheck [] mapFunction of
    Right (TArrow (TArrow TInt TInt) (TArrow (TList TInt) (TList TInt))) -> True
    _ -> False
```

#### 7.2 ç±»å‹å®‰å…¨ç¼–ç¨‹

**å®ä¾‹ 7.2 (ç±»å‹å®‰å…¨æ“ä½œ)**
ç®€å•ç±»å‹è®ºç¡®ä¿ç±»å‹å®‰å…¨ï¼š

```haskell
-- ç±»å‹å®‰å…¨çš„ç®—æœ¯è¿ç®—
safeAdd :: Expression
safeAdd = Lambda "x" TInt (Lambda "y" TInt (Add (Var "x") (Var "y")))

-- ç±»å‹å®‰å…¨çš„æ¡ä»¶è¡¨è¾¾å¼
safeIf :: Expression
safeIf = Lambda "b" TBool 
    (Lambda "x" TInt 
        (Lambda "y" TInt 
            (If (Var "b") (Var "x") (Var "y"))))

-- ç±»å‹æ£€æŸ¥éªŒè¯
verifyTypeSafety :: Bool
verifyTypeSafety = 
    case typeCheck [] safeAdd of
        Right (TArrow TInt (TArrow TInt TInt)) -> True
        _ -> False
```

### 8. æ‰©å±•æ€§

#### 8.1 é€’å½’ç±»å‹

**å®šä¹‰ 8.1 (é€’å½’ç±»å‹)**
é€’å½’ç±»å‹ $\mu \alpha.\tau$ è¡¨ç¤ºæ»¡è¶³ $\tau[\mu \alpha.\tau/\alpha] = \mu \alpha.\tau$ çš„ç±»å‹ã€‚

**Haskell å®ç°**:

```haskell
-- é€’å½’ç±»å‹
data RecursiveType = 
    Mu String Type
  | TypeVar String
  deriving (Show, Eq)

-- é€’å½’ç±»å‹å±•å¼€
unfold :: RecursiveType -> Type
unfold (Mu alpha tau) = substituteType alpha (Mu alpha tau) tau
unfold (TypeVar alpha) = TypeVar alpha

-- é€’å½’ç±»å‹æŠ˜å 
fold :: Type -> RecursiveType -> Type
fold tau (Mu alpha _) = Mu alpha tau
fold tau (TypeVar alpha) = TypeVar alpha
```

#### 8.2 å¤šæ€ç±»å‹

**å®šä¹‰ 8.2 (å¤šæ€ç±»å‹)**
å¤šæ€ç±»å‹ $\forall \alpha.\tau$ è¡¨ç¤ºå¯¹æ‰€æœ‰ç±»å‹ $\alpha$ éƒ½æˆç«‹çš„ç±»å‹ $\tau$ã€‚

**Haskell å®ç°**:

```haskell
-- å¤šæ€ç±»å‹
data PolymorphicType = 
    Forall String Type
  | Instantiate PolymorphicType Type
  deriving (Show, Eq)

-- ç±»å‹å®ä¾‹åŒ–
instantiate :: PolymorphicType -> Type -> Type
instantiate (Forall alpha tau) t = substituteType alpha t tau
instantiate (Instantiate poly t) t' = instantiate poly t'

-- ç±»å‹æ³›åŒ–
generalize :: Type -> PolymorphicType
generalize tau = Forall "alpha" tau
```

## ğŸ”„ æŒç»­æ¼”è¿›

### å½“å‰çŠ¶æ€

- **å®Œæˆåº¦**: 85%
- **å¾…å®Œæˆ**: æ›´å¤šæ‰©å±•å’Œä¼˜åŒ–
- **ä¸‹ä¸€æ­¥**: å®Œå–„ç±»å‹æ¨æ–­ç®—æ³•

### æ›´æ–°è®¡åˆ’

- **2024-11-XX**: å®Œæˆæ ¸å¿ƒç±»å‹ç³»ç»Ÿ
- **2024-11-XX**: æ·»åŠ æ›´å¤šç±»å‹æ„é€ å­
- **2024-11-XX**: ä¼˜åŒ–ç±»å‹æ¨æ–­ç®—æ³•

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Hindley, J. R. (1969). The principal type-scheme of an object in combinatory logic. Transactions of the American Mathematical Society, 146, 29-60.
2. Milner, R. (1978). A theory of type polymorphism in programming. Journal of computer and system sciences, 17(3), 348-375.
3. Pierce, B. C. (2002). Types and programming languages. MIT press.
4. Tait, W. W. (1967). Intensional interpretations of functionals of finite type I. The Journal of Symbolic Logic, 32(2), 198-212.
5. Girard, J. Y., Lafont, Y., & Taylor, P. (1989). Proofs and types (Vol. 7). Cambridge university press.

---

**æ¿€æƒ…æ¾æ¹ƒï¼Œè¿½æ±‚å“è¶Šï¼** ğŸš€

*æœ¬æ–‡æ¡£æ˜¯ç®€å•ç±»å‹è®ºçš„æ ¸å¿ƒæ–‡æ¡£ï¼Œä¸ºå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€æä¾›äº†ä¸¥æ ¼çš„æ•°å­¦åŸºç¡€ã€‚*
