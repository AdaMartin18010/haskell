# 02-02-01 简单类型论

## 📋 文档信息

- **文档编号**: 02-02-01
- **文档标题**: 简单类型论
- **创建日期**: 2024-11-XX
- **最后更新**: 2024-11-XX
- **文档状态**: 进行中
- **相关文档**:
  - [统一形式理论公理化框架](../02-01-统一理论/02-01-01-统一形式理论公理化框架.md)
  - [线性类型论](02-02-02-线性类型论.md)
  - [依赖类型论](02-02-03-依赖类型论.md)
  - [Haskell实现](../../haskell/TypeSystem.hs)

## 🎯 概述

简单类型论 (Simply Typed Lambda Calculus, STLC) 是类型理论的基础，为函数式编程语言提供了严格的数学基础。它通过类型系统确保程序的安全性和正确性，是现代编程语言设计的核心理论。

## 🏗️ 理论架构

### 1. 语法定义

#### 1.1 类型语法

**定义 1.1 (类型语法)**
简单类型论的类型语法定义为：
$$\tau ::= \text{Base} \mid \tau_1 \rightarrow \tau_2$$

其中：

- $\text{Base}$ 表示基础类型（如 $\text{Bool}$, $\text{Int}$, $\text{Unit}$）
- $\tau_1 \rightarrow \tau_2$ 表示函数类型

**Haskell 实现**:

```haskell
-- 类型语法
data Type = 
    TUnit           -- 单位类型
  | TBool           -- 布尔类型
  | TInt            -- 整数类型
  | TFloat          -- 浮点类型
  | TString         -- 字符串类型
  | TArrow Type Type -- 函数类型
  | TProduct Type Type -- 积类型
  | TSum Type Type     -- 和类型
  deriving (Show, Eq)

-- 类型上下文
type Context = [(String, Type)]

-- 类型判断
data TypeJudgment = 
    TypeJudgment 
        { context :: Context
        , expression :: Expression
        , type_ :: Type
        }
  deriving (Show, Eq)
```

#### 1.2 表达式语法

**定义 1.2 (表达式语法)**
简单类型论的表达式语法定义为：
$$e ::= x \mid \lambda x : \tau.e \mid e_1 e_2 \mid c$$

其中：

- $x$ 表示变量
- $\lambda x : \tau.e$ 表示类型化抽象
- $e_1 e_2$ 表示函数应用
- $c$ 表示常量

**Haskell 实现**:

```haskell
-- 表达式语法
data Expression = 
    Var String                    -- 变量
  | Lambda String Type Expression -- 类型化抽象
  | App Expression Expression     -- 函数应用
  | Unit                          -- 单位值
  | Bool Bool                     -- 布尔值
  | Int Int                       -- 整数值
  | Float Float                   -- 浮点值
  | String String                 -- 字符串值
  | Pair Expression Expression    -- 序对
  | Fst Expression                -- 第一投影
  | Snd Expression                -- 第二投影
  | Inl Expression                -- 左注入
  | Inr Expression                -- 右注入
  | Case Expression String Expression String Expression -- 模式匹配
  | If Expression Expression Expression -- 条件表达式
  deriving (Show, Eq)

-- 值
data Value = 
    VUnit
  | VBool Bool
  | VInt Int
  | VFloat Float
  | VString String
  | VPair Value Value
  | VInl Value
  | VInr Value
  | VClosure String Expression Context
  deriving (Show, Eq)
```

### 2. 类型规则

#### 2.1 基本类型规则

**规则 2.1 (变量规则)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \text{ (Var)}$$

**规则 2.2 (抽象规则)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x : \tau_1.e : \tau_1 \rightarrow \tau_2} \text{ (Abs)}$$

**规则 2.3 (应用规则)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2} \text{ (App)}$$

**Haskell 实现**:

```haskell
-- 类型检查
typeCheck :: Context -> Expression -> Either TypeError Type
typeCheck ctx (Var x) = 
    case lookup x ctx of
        Just t -> Right t
        Nothing -> Left (UnboundVariable x)

typeCheck ctx (Lambda x t body) = do
    bodyType <- typeCheck ((x, t) : ctx) body
    return (TArrow t bodyType)

typeCheck ctx (App e1 e2) = do
    t1 <- typeCheck ctx e1
    t2 <- typeCheck ctx e2
    case t1 of
        TArrow argType resultType 
            | argType == t2 -> Right resultType
            | otherwise -> Left (TypeMismatch argType t2)
        _ -> Left (NotFunctionType t1)

-- 类型错误
data TypeError = 
    UnboundVariable String
  | TypeMismatch Type Type
  | NotFunctionType Type
  | InvalidOperation String
  deriving (Show, Eq)
```

#### 2.2 积类型规则

**规则 2.4 (积类型引入)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2}{\Gamma \vdash (e_1, e_2) : \tau_1 \times \tau_2} \text{ (Pair)}$$

**规则 2.5 (积类型消除)**
$$\frac{\Gamma \vdash e : \tau_1 \times \tau_2}{\Gamma \vdash \text{fst } e : \tau_1} \text{ (Fst)}$$

$$\frac{\Gamma \vdash e : \tau_1 \times \tau_2}{\Gamma \vdash \text{snd } e : \tau_2} \text{ (Snd)}$$

**Haskell 实现**:

```haskell
-- 积类型检查
typeCheck ctx (Pair e1 e2) = do
    t1 <- typeCheck ctx e1
    t2 <- typeCheck ctx e2
    return (TProduct t1 t2)

typeCheck ctx (Fst e) = do
    t <- typeCheck ctx e
    case t of
        TProduct t1 _ -> Right t1
        _ -> Left (NotProductType t)

typeCheck ctx (Snd e) = do
    t <- typeCheck ctx e
    case t of
        TProduct _ t2 -> Right t2
        _ -> Left (NotProductType t)
```

#### 2.3 和类型规则

**规则 2.6 (和类型引入)**
$$\frac{\Gamma \vdash e : \tau_1}{\Gamma \vdash \text{inl } e : \tau_1 + \tau_2} \text{ (Inl)}$$

$$\frac{\Gamma \vdash e : \tau_2}{\Gamma \vdash \text{inr } e : \tau_1 + \tau_2} \text{ (Inr)}$$

**规则 2.7 (和类型消除)**
$$\frac{\Gamma \vdash e : \tau_1 + \tau_2 \quad \Gamma, x : \tau_1 \vdash e_1 : \tau \quad \Gamma, y : \tau_2 \vdash e_2 : \tau}{\Gamma \vdash \text{case } e \text{ of inl } x \Rightarrow e_1 \text{ | inr } y \Rightarrow e_2 : \tau} \text{ (Case)}$$

**Haskell 实现**:

```haskell
-- 和类型检查
typeCheck ctx (Inl e) = do
    t <- typeCheck ctx e
    -- 这里需要类型注解或类型推断来确定完整的和类型
    return (TSum t (TUnit)) -- 简化处理

typeCheck ctx (Inr e) = do
    t <- typeCheck ctx e
    return (TSum (TUnit) t) -- 简化处理

typeCheck ctx (Case e x e1 y e2) = do
    sumType <- typeCheck ctx e
    case sumType of
        TSum t1 t2 -> do
            resultType1 <- typeCheck ((x, t1) : ctx) e1
            resultType2 <- typeCheck ((y, t2) : ctx) e2
            if resultType1 == resultType2
                then Right resultType1
                else Left (TypeMismatch resultType1 resultType2)
        _ -> Left (NotSumType sumType)
```

### 3. 操作语义

#### 3.1 小步语义

**定义 3.1 (小步归约)**
小步归约关系 $\rightarrow$ 定义为：

**Beta归约**:
$$(\lambda x : \tau.e) v \rightarrow e[v/x]$$

**投影归约**:
$$\text{fst } (v_1, v_2) \rightarrow v_1$$
$$\text{snd } (v_1, v_2) \rightarrow v_2$$

**模式匹配归约**:
$$\text{case inl } v \text{ of inl } x \Rightarrow e_1 \text{ | inr } y \Rightarrow e_2 \rightarrow e_1[v/x]$$
$$\text{case inr } v \text{ of inl } x \Rightarrow e_1 \text{ | inr } y \Rightarrow e_2 \rightarrow e_2[v/y]$$

**Haskell 实现**:

```haskell
-- 小步语义
step :: Expression -> Maybe Expression
step (App (Lambda x _ body) v) = 
    Just (substitute x v body)
step (Fst (Pair v1 v2)) = 
    Just v1
step (Snd (Pair v1 v2)) = 
    Just v2
step (Case (Inl v) x e1 y e2) = 
    Just (substitute x v e1)
step (Case (Inr v) x e1 y e2) = 
    Just (substitute y v e2)
step (App e1 e2) = do
    e1' <- step e1
    return (App e1' e2)
step (Pair e1 e2) = do
    e1' <- step e1
    return (Pair e1' e2)
step _ = Nothing

-- 替换
substitute :: String -> Expression -> Expression -> Expression
substitute x v (Var y) 
    | x == y = v
    | otherwise = Var y
substitute x v (Lambda y t body)
    | x == y = Lambda y t body
    | otherwise = Lambda y t (substitute x v body)
substitute x v (App e1 e2) = 
    App (substitute x v e1) (substitute x v e2)
substitute x v (Pair e1 e2) = 
    Pair (substitute x v e1) (substitute x v e2)
substitute x v (Fst e) = 
    Fst (substitute x v e)
substitute x v (Snd e) = 
    Snd (substitute x v e)
substitute x v (Inl e) = 
    Inl (substitute x v e)
substitute x v (Inr e) = 
    Inr (substitute x v e)
substitute x v (Case e y e1 z e2) = 
    Case (substitute x v e) y e1 z e2
substitute _ _ e = e
```

#### 3.2 大步语义

**定义 3.2 (大步求值)**
大步求值关系 $\Downarrow$ 定义为：

**值规则**:
$$v \Downarrow v$$

**应用规则**:
$$\frac{e_1 \Downarrow \lambda x : \tau.e \quad e_2 \Downarrow v \quad e[v/x] \Downarrow v'}{e_1 e_2 \Downarrow v'}$$

**Haskell 实现**:

```haskell
-- 大步语义
eval :: Expression -> Maybe Value
eval (Var x) = Nothing -- 未绑定变量无法求值
eval (Lambda x t body) = 
    Just (VClosure x body [])
eval (App e1 e2) = do
    VClosure x body ctx <- eval e1
    v2 <- eval e2
    eval (substitute x e2 body)
eval Unit = Just VUnit
eval (Bool b) = Just (VBool b)
eval (Int n) = Just (VInt n)
eval (Float f) = Just (VFloat f)
eval (String s) = Just (VString s)
eval (Pair e1 e2) = do
    v1 <- eval e1
    v2 <- eval e2
    return (VPair v1 v2)
eval (Fst e) = do
    VPair v1 _ <- eval e
    return v1
eval (Snd e) = do
    VPair _ v2 <- eval e
    return v2
eval (Inl e) = do
    v <- eval e
    return (VInl v)
eval (Inr e) = do
    v <- eval e
    return (VInr v)
eval (Case e x e1 y e2) = do
    v <- eval e
    case v of
        VInl v1 -> eval (substitute x (valueToExpr v1) e1)
        VInr v2 -> eval (substitute y (valueToExpr v2) e2)
        _ -> Nothing
eval (If cond thenExpr elseExpr) = do
    VBool b <- eval cond
    if b then eval thenExpr else eval elseExpr

-- 值到表达式的转换
valueToExpr :: Value -> Expression
valueToExpr VUnit = Unit
valueToExpr (VBool b) = Bool b
valueToExpr (VInt n) = Int n
valueToExpr (VFloat f) = Float f
valueToExpr (VString s) = String s
valueToExpr (VPair v1 v2) = Pair (valueToExpr v1) (valueToExpr v2)
valueToExpr (VInl v) = Inl (valueToExpr v)
valueToExpr (VInr v) = Inr (valueToExpr v)
valueToExpr (VClosure x body ctx) = Lambda x TUnit body -- 简化处理
```

### 4. 类型安全性

#### 4.1 类型保持性

**定理 4.1 (类型保持性)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$。

**证明**:
通过结构归纳法证明。对于每个归约规则：

1. **Beta归约**: $(\lambda x : \tau.e) v \rightarrow e[v/x]$
   - 如果 $\Gamma \vdash (\lambda x : \tau.e) v : \tau_2$
   - 则 $\Gamma \vdash \lambda x : \tau.e : \tau \rightarrow \tau_2$ 且 $\Gamma \vdash v : \tau$
   - 因此 $\Gamma, x : \tau \vdash e : \tau_2$
   - 通过替换引理，$\Gamma \vdash e[v/x] : \tau_2$

2. **投影归约**: $\text{fst } (v_1, v_2) \rightarrow v_1$
   - 如果 $\Gamma \vdash \text{fst } (v_1, v_2) : \tau_1$
   - 则 $\Gamma \vdash (v_1, v_2) : \tau_1 \times \tau_2$
   - 因此 $\Gamma \vdash v_1 : \tau_1$

#### 4.2 进展性

**定理 4.2 (进展性)**
如果 $\emptyset \vdash e : \tau$，则要么 $e$ 是值，要么存在 $e'$ 使得 $e \rightarrow e'$。

**证明**:
通过结构归纳法证明。对于每个语法构造：

1. **变量**: 在空上下文中无法类型化
2. **抽象**: $\lambda x : \tau.e$ 是值
3. **应用**: $e_1 e_2$，通过归纳假设，$e_1$ 要么是值要么可以归约
   - 如果 $e_1$ 可以归约，则 $e_1 e_2$ 可以归约
   - 如果 $e_1$ 是值，则 $e_1 = \lambda x : \tau.e$，因此 $e_1 e_2$ 可以Beta归约

**Haskell 实现**:

```haskell
-- 类型保持性验证
typePreservation :: Context -> Expression -> Bool
typePreservation ctx e = 
    case typeCheck ctx e of
        Right t -> 
            case step e of
                Just e' -> 
                    case typeCheck ctx e' of
                        Right t' -> t == t'
                        Left _ -> False
                Nothing -> True
        Left _ -> True

-- 进展性验证
progress :: Expression -> Bool
progress e = 
    case typeCheck [] e of
        Right _ -> isValue e || (step e /= Nothing)
        Left _ -> True

-- 值判断
isValue :: Expression -> Bool
isValue Unit = True
isValue (Bool _) = True
isValue (Int _) = True
isValue (Float _) = True
isValue (String _) = True
isValue (Lambda _ _ _) = True
isValue (Pair e1 e2) = isValue e1 && isValue e2
isValue (Inl e) = isValue e
isValue (Inr e) = isValue e
isValue _ = False
```

### 5. 类型推断

#### 5.1 Hindley-Milner类型系统

**定义 5.1 (类型变量)**
类型变量 $\alpha$ 用于表示未知类型。

**定义 5.2 (类型模式)**
类型模式 $\sigma$ 定义为：
$$\sigma ::= \tau \mid \forall \alpha.\sigma$$

**Haskell 实现**:

```haskell
-- 类型变量
data TypeVar = TypeVar String deriving (Show, Eq)

-- 类型模式
data TypeScheme = 
    TypeScheme [TypeVar] Type
  | SimpleType Type
  deriving (Show, Eq)

-- 类型环境
type TypeEnv = [(String, TypeScheme)]

-- 类型推断
inferType :: TypeEnv -> Expression -> Either TypeError (Type, Substitution)
inferType env (Var x) = 
    case lookup x env of
        Just (SimpleType t) -> Right (t, [])
        Just (TypeScheme vars t) -> 
            let freshVars = map (\v -> (v, freshTypeVar v)) vars
                t' = substituteTypeVars freshVars t
            in Right (t', [])
        Nothing -> Left (UnboundVariable x)

inferType env (Lambda x t body) = do
    (bodyType, s) <- inferType ((x, SimpleType t) : env) body
    return (TArrow t bodyType, s)

inferType env (App e1 e2) = do
    (t1, s1) <- inferType env e1
    (t2, s2) <- inferType (applySubst s1 env) e2
    alpha <- freshTypeVar "alpha"
    s3 <- unify (applySubst s2 t1) (TArrow t2 alpha)
    let resultType = applySubst s3 alpha
    let finalSubst = compose s3 (compose s2 s1)
    return (resultType, finalSubst)

-- 类型替换
type Substitution = [(TypeVar, Type)]

applySubst :: Substitution -> Type -> Type
applySubst s (TArrow t1 t2) = TArrow (applySubst s t1) (applySubst s t2)
applySubst s (TProduct t1 t2) = TProduct (applySubst s t1) (applySubst s t2)
applySubst s (TSum t1 t2) = TSum (applySubst s t1) (applySubst s t2)
applySubst s (TVar alpha) = 
    case lookup alpha s of
        Just t -> t
        Nothing -> TVar alpha
applySubst _ t = t

-- 合一算法
unify :: Type -> Type -> Either TypeError Substitution
unify (TVar alpha) t = 
    if alpha `elem` freeTypeVars t 
        then Left (OccursCheck alpha t)
        else Right [(alpha, t)]
unify t (TVar alpha) = unify (TVar alpha) t
unify (TArrow t1 t2) (TArrow t1' t2') = do
    s1 <- unify t1 t1'
    s2 <- unify (applySubst s1 t2) (applySubst s1 t2')
    return (compose s2 s1)
unify (TProduct t1 t2) (TProduct t1' t2') = do
    s1 <- unify t1 t1'
    s2 <- unify (applySubst s1 t2) (applySubst s1 t2')
    return (compose s2 s1)
unify (TSum t1 t2) (TSum t1' t2') = do
    s1 <- unify t1 t1'
    s2 <- unify (applySubst s1 t2) (applySubst s1 t2')
    return (compose s2 s1)
unify t1 t2 = 
    if t1 == t2 then Right [] else Left (TypeMismatch t1 t2)
```

### 6. 语义模型

#### 6.1 指称语义

**定义 6.1 (类型解释)**
类型 $\tau$ 的指称语义 $\llbracket \tau \rrbracket$ 定义为：

- $\llbracket \text{Unit} \rrbracket = \{*\}$
- $\llbracket \text{Bool} \rrbracket = \{\text{true}, \text{false}\}$
- $\llbracket \text{Int} \rrbracket = \mathbb{Z}$
- $\llbracket \tau_1 \rightarrow \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket \rightarrow \llbracket \tau_2 \rrbracket$
- $\llbracket \tau_1 \times \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket \times \llbracket \tau_2 \rrbracket$
- $\llbracket \tau_1 + \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket + \llbracket \tau_2 \rrbracket$

**Haskell 实现**:

```haskell
-- 指称语义
class Denotational a where
    denotation :: a -> SemanticDomain

instance Denotational Type where
    denotation TUnit = UnitDomain
    denotation TBool = BoolDomain
    denotation TInt = IntDomain
    denotation TFloat = FloatDomain
    denotation TString = StringDomain
    denotation (TArrow t1 t2) = 
        FunctionDomain (denotation t1) (denotation t2)
    denotation (TProduct t1 t2) = 
        ProductDomain (denotation t1) (denotation t2)
    denotation (TSum t1 t2) = 
        SumDomain (denotation t1) (denotation t2)

-- 语义域
data SemanticDomain = 
    UnitDomain
  | BoolDomain
  | IntDomain
  | FloatDomain
  | StringDomain
  | FunctionDomain SemanticDomain SemanticDomain
  | ProductDomain SemanticDomain SemanticDomain
  | SumDomain SemanticDomain SemanticDomain
  deriving (Show, Eq)
```

### 7. 应用实例

#### 7.1 函数式编程

**实例 7.1 (高阶函数)**
简单类型论支持高阶函数：

```haskell
-- 高阶函数类型
mapType :: Type -> Type -> Type
mapType a b = TArrow (TArrow a b) (TArrow (TList a) (TList b))

-- 映射函数
mapFunction :: Expression
mapFunction = Lambda "f" (TArrow TInt TInt) 
    (Lambda "xs" (TList TInt) 
        (Case (Var "xs") "x" 
            (Cons (App (Var "f") (Var "x")) (App (App mapFunction (Var "f")) (Var "xs")))
            "xs" (Nil TInt)))

-- 类型检查
checkMap :: Bool
checkMap = case typeCheck [] mapFunction of
    Right (TArrow (TArrow TInt TInt) (TArrow (TList TInt) (TList TInt))) -> True
    _ -> False
```

#### 7.2 类型安全编程

**实例 7.2 (类型安全操作)**
简单类型论确保类型安全：

```haskell
-- 类型安全的算术运算
safeAdd :: Expression
safeAdd = Lambda "x" TInt (Lambda "y" TInt (Add (Var "x") (Var "y")))

-- 类型安全的条件表达式
safeIf :: Expression
safeIf = Lambda "b" TBool 
    (Lambda "x" TInt 
        (Lambda "y" TInt 
            (If (Var "b") (Var "x") (Var "y"))))

-- 类型检查验证
verifyTypeSafety :: Bool
verifyTypeSafety = 
    case typeCheck [] safeAdd of
        Right (TArrow TInt (TArrow TInt TInt)) -> True
        _ -> False
```

### 8. 扩展性

#### 8.1 递归类型

**定义 8.1 (递归类型)**
递归类型 $\mu \alpha.\tau$ 表示满足 $\tau[\mu \alpha.\tau/\alpha] = \mu \alpha.\tau$ 的类型。

**Haskell 实现**:

```haskell
-- 递归类型
data RecursiveType = 
    Mu String Type
  | TypeVar String
  deriving (Show, Eq)

-- 递归类型展开
unfold :: RecursiveType -> Type
unfold (Mu alpha tau) = substituteType alpha (Mu alpha tau) tau
unfold (TypeVar alpha) = TypeVar alpha

-- 递归类型折叠
fold :: Type -> RecursiveType -> Type
fold tau (Mu alpha _) = Mu alpha tau
fold tau (TypeVar alpha) = TypeVar alpha
```

#### 8.2 多态类型

**定义 8.2 (多态类型)**
多态类型 $\forall \alpha.\tau$ 表示对所有类型 $\alpha$ 都成立的类型 $\tau$。

**Haskell 实现**:

```haskell
-- 多态类型
data PolymorphicType = 
    Forall String Type
  | Instantiate PolymorphicType Type
  deriving (Show, Eq)

-- 类型实例化
instantiate :: PolymorphicType -> Type -> Type
instantiate (Forall alpha tau) t = substituteType alpha t tau
instantiate (Instantiate poly t) t' = instantiate poly t'

-- 类型泛化
generalize :: Type -> PolymorphicType
generalize tau = Forall "alpha" tau
```

## 🔄 持续演进

### 当前状态

- **完成度**: 85%
- **待完成**: 更多扩展和优化
- **下一步**: 完善类型推断算法

### 更新计划

- **2024-11-XX**: 完成核心类型系统
- **2024-11-XX**: 添加更多类型构造子
- **2024-11-XX**: 优化类型推断算法

## 📚 参考文献

1. Hindley, J. R. (1969). The principal type-scheme of an object in combinatory logic. Transactions of the American Mathematical Society, 146, 29-60.
2. Milner, R. (1978). A theory of type polymorphism in programming. Journal of computer and system sciences, 17(3), 348-375.
3. Pierce, B. C. (2002). Types and programming languages. MIT press.
4. Tait, W. W. (1967). Intensional interpretations of functionals of finite type I. The Journal of Symbolic Logic, 32(2), 198-212.
5. Girard, J. Y., Lafont, Y., & Taylor, P. (1989). Proofs and types (Vol. 7). Cambridge university press.

---

**激情澎湃，追求卓越！** 🚀

*本文档是简单类型论的核心文档，为函数式编程语言提供了严格的数学基础。*
