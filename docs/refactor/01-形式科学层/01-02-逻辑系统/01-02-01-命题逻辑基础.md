# 01-02-01 命题逻辑基础

## 目录

- [01-02-01 命题逻辑基础](#01-02-01-命题逻辑基础)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 核心概念](#11-核心概念)
    - [1.2 形式化目标](#12-形式化目标)
  - [2. 形式化定义](#2-形式化定义)
    - [2.1 语言定义](#21-语言定义)
    - [2.2 Haskell类型定义](#22-haskell类型定义)
  - [3. 语法系统](#3-语法系统)
    - [3.1 语法规则](#31-语法规则)
    - [3.2 语法函数](#32-语法函数)
  - [4. 语义系统](#4-语义系统)
    - [4.1 真值函数](#41-真值函数)
    - [4.2 Haskell语义实现](#42-haskell语义实现)
  - [5. 证明系统](#5-证明系统)
    - [5.1 自然演绎系统](#51-自然演绎系统)
    - [5.2 Haskell证明系统实现](#52-haskell证明系统实现)
  - [6. 元理论性质](#6-元理论性质)
    - [6.1 可靠性定理](#61-可靠性定理)
    - [6.2 完备性定理](#62-完备性定理)
    - [6.3 Haskell元理论实现](#63-haskell元理论实现)
  - [7. Haskell实现](#7-haskell实现)
    - [7.1 完整实现](#71-完整实现)
    - [7.2 测试和验证](#72-测试和验证)
  - [8. 应用与扩展](#8-应用与扩展)
    - [8.1 应用领域](#81-应用领域)
    - [8.2 扩展方向](#82-扩展方向)
    - [8.3 实际应用示例](#83-实际应用示例)
  - [总结](#总结)

## 1. 概述

命题逻辑是形式逻辑的基础分支，研究命题之间的逻辑关系。它提供了形式化推理的基本工具，是更高级逻辑系统的基础。

### 1.1 核心概念

- **命题**: 具有确定真值的陈述句
- **逻辑连接词**: 否定、合取、析取、蕴含、等价
- **重言式**: 在所有解释下都为真的公式
- **矛盾式**: 在所有解释下都为假的公式
- **可满足式**: 至少在一个解释下为真的公式

### 1.2 形式化目标

```haskell
-- 命题逻辑的核心目标
class PropositionalLogic a where
    -- 语法构造
    syntax :: a -> Formula
    -- 语义解释
    semantics :: a -> Interpretation -> Bool
    -- 证明系统
    proof :: a -> Proof
    -- 元理论性质
    soundness :: a -> Bool
    completeness :: a -> Bool
```

## 2. 形式化定义

### 2.1 语言定义

**定义 2.1.1 (命题语言)**
命题语言 $\mathcal{L}$ 是一个三元组 $(P, \mathcal{F}, \mathcal{A})$，其中：

- $P$ 是命题变元集合
- $\mathcal{F}$ 是公式集合
- $\mathcal{A}$ 是原子公式集合

**定义 2.1.2 (公式)**
公式集合 $\mathcal{F}$ 是满足以下条件的最小集合：

1. **原子公式**: 如果 $p \in P$，则 $p \in \mathcal{F}$
2. **否定**: 如果 $\phi \in \mathcal{F}$，则 $\neg \phi \in \mathcal{F}$
3. **合取**: 如果 $\phi, \psi \in \mathcal{F}$，则 $(\phi \land \psi) \in \mathcal{F}$
4. **析取**: 如果 $\phi, \psi \in \mathcal{F}$，则 $(\phi \lor \psi) \in \mathcal{F}$
5. **蕴含**: 如果 $\phi, \psi \in \mathcal{F}$，则 $(\phi \to \psi) \in \mathcal{F}$
6. **等价**: 如果 $\phi, \psi \in \mathcal{F}$，则 $(\phi \leftrightarrow \psi) \in \mathcal{F}$

### 2.2 Haskell类型定义

```haskell
-- 命题变元
type Proposition = String

-- 公式数据类型
data Formula = 
    Atom Proposition                    -- 原子公式
  | Not Formula                        -- 否定
  | And Formula Formula                -- 合取
  | Or Formula Formula                 -- 析取
  | Implies Formula Formula            -- 蕴含
  | Iff Formula Formula                -- 等价
  deriving (Eq, Show)

-- 解释函数类型
type Interpretation = Proposition -> Bool

-- 证明数据类型
data Proof = 
    Axiom Formula                      -- 公理
  | ModusPonens Proof Proof            -- 假言推理
  | AndIntro Proof Proof               -- 合取引入
  | AndElim1 Proof                     -- 合取消除1
  | AndElim2 Proof                     -- 合取消除2
  | OrIntro1 Formula Proof             -- 析取引入1
  | OrIntro2 Formula Proof             -- 析取引入2
  | OrElim Proof Proof Proof           -- 析取消除
  | NotIntro Proof                     -- 否定引入
  | NotElim Proof Proof                -- 否定消除
  | IffIntro Proof Proof               -- 等价引入
  | IffElim1 Proof                     -- 等价消除1
  | IffElim2 Proof                     -- 等价消除2
  deriving (Eq, Show)
```

## 3. 语法系统

### 3.1 语法规则

**规则 3.1.1 (原子公式)**
对于任意 $p \in P$，$p$ 是公式。

**规则 3.1.2 (否定)**
如果 $\phi$ 是公式，则 $\neg \phi$ 是公式。

**规则 3.1.3 (二元连接词)**
如果 $\phi$ 和 $\psi$ 是公式，则：

- $(\phi \land \psi)$ 是公式
- $(\phi \lor \psi)$ 是公式
- $(\phi \to \psi)$ 是公式
- $(\phi \leftrightarrow \psi)$ 是公式

### 3.2 语法函数

```haskell
-- 公式复杂度
complexity :: Formula -> Int
complexity (Atom _) = 0
complexity (Not phi) = 1 + complexity phi
complexity (And phi psi) = 1 + max (complexity phi) (complexity psi)
complexity (Or phi psi) = 1 + max (complexity phi) (complexity psi)
complexity (Implies phi psi) = 1 + max (complexity phi) (complexity psi)
complexity (Iff phi psi) = 1 + max (complexity phi) (complexity psi)

-- 子公式集合
subformulas :: Formula -> [Formula]
subformulas (Atom p) = [Atom p]
subformulas (Not phi) = Not phi : subformulas phi
subformulas (And phi psi) = And phi psi : subformulas phi ++ subformulas psi
subformulas (Or phi psi) = Or phi psi : subformulas phi ++ subformulas psi
subformulas (Implies phi psi) = Implies phi psi : subformulas phi ++ subformulas psi
subformulas (Iff phi psi) = Iff phi psi : subformulas phi ++ subformulas psi

-- 命题变元集合
propositions :: Formula -> [Proposition]
propositions (Atom p) = [p]
propositions (Not phi) = propositions phi
propositions (And phi psi) = propositions phi ++ propositions psi
propositions (Or phi psi) = propositions phi ++ propositions psi
propositions (Implies phi psi) = propositions phi ++ propositions psi
propositions (Iff phi psi) = propositions phi ++ propositions psi
```

## 4. 语义系统

### 4.1 真值函数

**定义 4.1.1 (真值函数)**
真值函数 $\llbracket \cdot \rrbracket : \mathcal{F} \times \mathcal{I} \to \{0,1\}$ 定义如下：

1. **原子公式**: $\llbracket p \rrbracket_I = I(p)$
2. **否定**: $\llbracket \neg \phi \rrbracket_I = 1 - \llbracket \phi \rrbracket_I$
3. **合取**: $\llbracket \phi \land \psi \rrbracket_I = \min(\llbracket \phi \rrbracket_I, \llbracket \psi \rrbracket_I)$
4. **析取**: $\llbracket \phi \lor \psi \rrbracket_I = \max(\llbracket \phi \rrbracket_I, \llbracket \psi \rrbracket_I)$
5. **蕴含**: $\llbracket \phi \to \psi \rrbracket_I = \max(1 - \llbracket \phi \rrbracket_I, \llbracket \psi \rrbracket_I)$
6. **等价**: $\llbracket \phi \leftrightarrow \psi \rrbracket_I = 1 - |\llbracket \phi \rrbracket_I - \llbracket \psi \rrbracket_I|$

### 4.2 Haskell语义实现

```haskell
-- 真值函数
eval :: Formula -> Interpretation -> Bool
eval (Atom p) i = i p
eval (Not phi) i = not (eval phi i)
eval (And phi psi) i = eval phi i && eval psi i
eval (Or phi psi) i = eval phi i || eval psi i
eval (Implies phi psi) i = not (eval phi i) || eval psi i
eval (Iff phi psi) i = eval phi i == eval psi i

-- 重言式检查
isTautology :: Formula -> Bool
isTautology phi = all (\i -> eval phi i) allInterpretations
  where
    props = nub (propositions phi)
    allInterpretations = generateAllInterpretations props

-- 矛盾式检查
isContradiction :: Formula -> Bool
isContradiction phi = all (\i -> not (eval phi i)) allInterpretations
  where
    props = nub (propositions phi)
    allInterpretations = generateAllInterpretations props

-- 可满足式检查
isSatisfiable :: Formula -> Bool
isSatisfiable phi = any (\i -> eval phi i) allInterpretations
  where
    props = nub (propositions phi)
    allInterpretations = generateAllInterpretations props

-- 生成所有解释
generateAllInterpretations :: [Proposition] -> [Interpretation]
generateAllInterpretations [] = [const False]
generateAllInterpretations (p:ps) = 
    [\q -> if q == p then b else i q | b <- [False, True], i <- generateAllInterpretations ps]

-- 逻辑等价
logicallyEquivalent :: Formula -> Formula -> Bool
logicallyEquivalent phi psi = all (\i -> eval phi i == eval psi i) allInterpretations
  where
    props = nub (propositions phi ++ propositions psi)
    allInterpretations = generateAllInterpretations props
```

## 5. 证明系统

### 5.1 自然演绎系统

**规则 5.1.1 (公理)**
对于任意公式 $\phi$，$\phi \vdash \phi$。

**规则 5.1.2 (假言推理)**
如果 $\Gamma \vdash \phi \to \psi$ 且 $\Gamma \vdash \phi$，则 $\Gamma \vdash \psi$。

**规则 5.1.3 (合取引入)**
如果 $\Gamma \vdash \phi$ 且 $\Gamma \vdash \psi$，则 $\Gamma \vdash \phi \land \psi$。

**规则 5.1.4 (合取消除)**
如果 $\Gamma \vdash \phi \land \psi$，则 $\Gamma \vdash \phi$ 且 $\Gamma \vdash \psi$。

**规则 5.1.5 (析取引入)**
如果 $\Gamma \vdash \phi$，则 $\Gamma \vdash \phi \lor \psi$ 且 $\Gamma \vdash \psi \lor \phi$。

**规则 5.1.6 (析取消除)**
如果 $\Gamma \vdash \phi \lor \psi$，$\Gamma, \phi \vdash \chi$，且 $\Gamma, \psi \vdash \chi$，则 $\Gamma \vdash \chi$。

**规则 5.1.7 (否定引入)**
如果 $\Gamma, \phi \vdash \bot$，则 $\Gamma \vdash \neg \phi$。

**规则 5.1.8 (否定消除)**
如果 $\Gamma \vdash \phi$ 且 $\Gamma \vdash \neg \phi$，则 $\Gamma \vdash \bot$。

### 5.2 Haskell证明系统实现

```haskell
-- 证明上下文
type Context = [Formula]

-- 证明关系
data Derivation = 
    Assumption Formula
  | ImplicationIntro Formula Derivation
  | ImplicationElim Derivation Derivation
  | ConjunctionIntro Derivation Derivation
  | ConjunctionElim1 Derivation
  | ConjunctionElim2 Derivation
  | DisjunctionIntro1 Formula Derivation
  | DisjunctionIntro2 Formula Derivation
  | DisjunctionElim Derivation Derivation Derivation
  | NegationIntro Formula Derivation
  | NegationElim Derivation Derivation
  | ContradictionElim Derivation Formula
  deriving (Eq, Show)

-- 证明检查
checkProof :: Context -> Formula -> Derivation -> Bool
checkProof ctx phi (Assumption psi) = psi `elem` ctx
checkProof ctx phi (ImplicationIntro psi deriv) = 
    phi == Implies psi (conclusion deriv) && 
    checkProof (psi:ctx) (conclusion deriv) deriv
checkProof ctx phi (ImplicationElim deriv1 deriv2) = 
    case conclusion deriv1 of
        Implies psi chi -> phi == chi && 
                          checkProof ctx (Implies psi chi) deriv1 && 
                          checkProof ctx psi deriv2
        _ -> False
checkProof ctx phi (ConjunctionIntro deriv1 deriv2) = 
    case phi of
        And psi chi -> checkProof ctx psi deriv1 && checkProof ctx chi deriv2
        _ -> False
checkProof ctx phi (ConjunctionElim1 deriv) = 
    case conclusion deriv of
        And psi _ -> phi == psi && checkProof ctx (conclusion deriv) deriv
        _ -> False
checkProof ctx phi (ConjunctionElim2 deriv) = 
    case conclusion deriv of
        And _ chi -> phi == chi && checkProof ctx (conclusion deriv) deriv
        _ -> False
checkProof ctx phi (DisjunctionIntro1 psi deriv) = 
    case phi of
        Or psi' chi -> psi == psi' && checkProof ctx psi deriv
        _ -> False
checkProof ctx phi (DisjunctionIntro2 psi deriv) = 
    case phi of
        Or chi psi' -> psi == psi' && checkProof ctx psi deriv
        _ -> False
checkProof ctx phi (DisjunctionElim deriv1 deriv2 deriv3) = 
    case conclusion deriv1 of
        Or psi chi -> checkProof ctx (Or psi chi) deriv1 &&
                     checkProof (psi:ctx) phi deriv2 &&
                     checkProof (chi:ctx) phi deriv3
        _ -> False
checkProof ctx phi (NegationIntro psi deriv) = 
    phi == Not psi && 
    checkProof (psi:ctx) (Atom "⊥") deriv
checkProof ctx phi (NegationElim deriv1 deriv2) = 
    case (conclusion deriv1, conclusion deriv2) of
        (psi, Not psi') -> psi == psi' && 
                          checkProof ctx psi deriv1 && 
                          checkProof ctx (Not psi') deriv2
        _ -> False
checkProof ctx phi (ContradictionElim deriv _) = 
    checkProof ctx (Atom "⊥") deriv

-- 获取证明结论
conclusion :: Derivation -> Formula
conclusion (Assumption phi) = phi
conclusion (ImplicationIntro psi deriv) = Implies psi (conclusion deriv)
conclusion (ImplicationElim deriv1 deriv2) = 
    case conclusion deriv1 of
        Implies _ chi -> chi
        _ -> error "Invalid implication elimination"
conclusion (ConjunctionIntro deriv1 deriv2) = And (conclusion deriv1) (conclusion deriv2)
conclusion (ConjunctionElim1 deriv) = 
    case conclusion deriv of
        And psi _ -> psi
        _ -> error "Invalid conjunction elimination"
conclusion (ConjunctionElim2 deriv) = 
    case conclusion deriv of
        And _ chi -> chi
        _ -> error "Invalid conjunction elimination"
conclusion (DisjunctionIntro1 psi deriv) = Or psi (conclusion deriv)
conclusion (DisjunctionIntro2 psi deriv) = Or (conclusion deriv) psi
conclusion (DisjunctionElim _ deriv2 _) = conclusion deriv2
conclusion (NegationIntro psi deriv) = Not psi
conclusion (NegationElim _ _) = Atom "⊥"
conclusion (ContradictionElim _ phi) = phi
```

## 6. 元理论性质

### 6.1 可靠性定理

**定理 6.1.1 (可靠性)**
如果 $\Gamma \vdash \phi$，则 $\Gamma \models \phi$。

**证明：**
对证明的长度进行归纳。

**基础情况：** 如果证明长度为1，则 $\phi \in \Gamma$，显然 $\Gamma \models \phi$。

**归纳步骤：** 假设对于所有长度小于 $n$ 的证明，定理成立。考虑长度为 $n$ 的证明。

根据最后使用的规则进行分情况讨论：

1. **假言推理**: 如果最后使用假言推理，则存在 $\psi$ 使得 $\Gamma \vdash \psi \to \phi$ 且 $\Gamma \vdash \psi$。由归纳假设，$\Gamma \models \psi \to \phi$ 且 $\Gamma \models \psi$。设 $I$ 是 $\Gamma$ 的模型，则 $I \models \psi \to \phi$ 且 $I \models \psi$，因此 $I \models \phi$。

2. **合取引入**: 如果最后使用合取引入，则 $\phi = \psi \land \chi$，且 $\Gamma \vdash \psi$ 和 $\Gamma \vdash \chi$。由归纳假设，$\Gamma \models \psi$ 且 $\Gamma \models \chi$。设 $I$ 是 $\Gamma$ 的模型，则 $I \models \psi$ 且 $I \models \chi$，因此 $I \models \psi \land \chi$。

其他情况类似可证。

### 6.2 完备性定理

**定理 6.1.2 (完备性)**
如果 $\Gamma \models \phi$，则 $\Gamma \vdash \phi$。

**证明：**
使用反证法。假设 $\Gamma \not\vdash \phi$，则 $\Gamma \cup \{\neg \phi\}$ 是一致的。

根据Lindenbaum引理，存在极大一致集 $\Delta$ 包含 $\Gamma \cup \{\neg \phi\}$。

定义解释 $I$ 如下：对于任意命题变元 $p$，$I(p) = \text{true}$ 当且仅当 $p \in \Delta$。

通过结构归纳可以证明：对于任意公式 $\psi$，$I \models \psi$ 当且仅当 $\psi \in \Delta$。

由于 $\neg \phi \in \Delta$，所以 $I \models \neg \phi$，即 $I \not\models \phi$。

但 $\Gamma \subseteq \Delta$，所以 $I$ 是 $\Gamma$ 的模型，这与 $\Gamma \models \phi$ 矛盾。

### 6.3 Haskell元理论实现

```haskell
-- 可靠性检查
soundness :: Context -> Formula -> Derivation -> Bool
soundness ctx phi deriv = 
    checkProof ctx phi deriv && 
    all (\i -> eval phi i) (modelsOf ctx)
  where
    modelsOf gamma = [i | i <- allInterpretations, all (\psi -> eval psi i) gamma]
    allInterpretations = generateAllInterpretations (concatMap propositions gamma)

-- 完备性检查（简化版本）
completeness :: Context -> Formula -> Bool
completeness ctx phi = 
    if all (\i -> eval phi i) (modelsOf ctx)
    then hasProof ctx phi
    else True
  where
    modelsOf gamma = [i | i <- allInterpretations, all (\psi -> eval psi i) gamma]
    allInterpretations = generateAllInterpretations (concatMap propositions gamma)
    hasProof gamma psi = -- 简化的证明存在性检查
        case psi of
            Implies alpha beta -> hasProof (alpha:gamma) beta
            And alpha beta -> hasProof gamma alpha && hasProof gamma beta
            Or alpha beta -> hasProof gamma alpha || hasProof gamma beta
            Not alpha -> hasProof (alpha:gamma) (Atom "⊥")
            _ -> psi `elem` gamma

-- 一致性检查
isConsistent :: Context -> Bool
isConsistent ctx = not (hasProof ctx (Atom "⊥"))
  where
    hasProof gamma psi = -- 简化的证明存在性检查
        case psi of
            Implies alpha beta -> hasProof (alpha:gamma) beta
            And alpha beta -> hasProof gamma alpha && hasProof gamma beta
            Or alpha beta -> hasProof gamma alpha || hasProof gamma beta
            Not alpha -> hasProof (alpha:gamma) (Atom "⊥")
            _ -> psi `elem` gamma

-- 极大一致集构造
maximalConsistentSet :: Context -> [Formula]
maximalConsistentSet ctx = 
    let allFormulas = generateAllFormulas ctx
        addIfConsistent gamma phi = 
            if isConsistent (phi:gamma) then phi:gamma else gamma
    in foldl addIfConsistent ctx allFormulas

-- 生成所有公式（简化版本）
generateAllFormulas :: Context -> [Formula]
generateAllFormulas ctx = 
    let props = nub (concatMap propositions ctx)
        atoms = map Atom props
        -- 这里简化处理，实际应该生成所有可能的公式
    in atoms
```

## 7. Haskell实现

### 7.1 完整实现

```haskell
-- 文件: PropositionalLogic.hs
module PropositionalLogic where

import Data.List (nub, (\\), intersect, union)
import Data.Maybe (fromJust, isJust)

-- 基本类型定义
type Proposition = String

data Formula = 
    Atom Proposition
  | Not Formula
  | And Formula Formula
  | Or Formula Formula
  | Implies Formula Formula
  | Iff Formula Formula
  deriving (Eq, Show)

type Interpretation = Proposition -> Bool

-- 语法函数
complexity :: Formula -> Int
complexity (Atom _) = 0
complexity (Not phi) = 1 + complexity phi
complexity (And phi psi) = 1 + max (complexity phi) (complexity psi)
complexity (Or phi psi) = 1 + max (complexity phi) (complexity psi)
complexity (Implies phi psi) = 1 + max (complexity phi) (complexity psi)
complexity (Iff phi psi) = 1 + max (complexity phi) (complexity psi)

subformulas :: Formula -> [Formula]
subformulas (Atom p) = [Atom p]
subformulas (Not phi) = Not phi : subformulas phi
subformulas (And phi psi) = And phi psi : subformulas phi ++ subformulas psi
subformulas (Or phi psi) = Or phi psi : subformulas phi ++ subformulas psi
subformulas (Implies phi psi) = Implies phi psi : subformulas phi ++ subformulas psi
subformulas (Iff phi psi) = Iff phi psi : subformulas phi ++ subformulas psi

propositions :: Formula -> [Proposition]
propositions (Atom p) = [p]
propositions (Not phi) = propositions phi
propositions (And phi psi) = propositions phi ++ propositions psi
propositions (Or phi psi) = propositions phi ++ propositions psi
propositions (Implies phi psi) = propositions phi ++ propositions psi
propositions (Iff phi psi) = propositions phi ++ propositions psi

-- 语义函数
eval :: Formula -> Interpretation -> Bool
eval (Atom p) i = i p
eval (Not phi) i = not (eval phi i)
eval (And phi psi) i = eval phi i && eval psi i
eval (Or phi psi) i = eval phi i || eval psi i
eval (Implies phi psi) i = not (eval phi i) || eval psi i
eval (Iff phi psi) i = eval phi i == eval psi i

generateAllInterpretations :: [Proposition] -> [Interpretation]
generateAllInterpretations [] = [const False]
generateAllInterpretations (p:ps) = 
    [\q -> if q == p then b else i q | b <- [False, True], i <- generateAllInterpretations ps]

isTautology :: Formula -> Bool
isTautology phi = all (\i -> eval phi i) allInterpretations
  where
    props = nub (propositions phi)
    allInterpretations = generateAllInterpretations props

isContradiction :: Formula -> Bool
isContradiction phi = all (\i -> not (eval phi i)) allInterpretations
  where
    props = nub (propositions phi)
    allInterpretations = generateAllInterpretations props

isSatisfiable :: Formula -> Bool
isSatisfiable phi = any (\i -> eval phi i) allInterpretations
  where
    props = nub (propositions phi)
    allInterpretations = generateAllInterpretations props

logicallyEquivalent :: Formula -> Formula -> Bool
logicallyEquivalent phi psi = all (\i -> eval phi i == eval psi i) allInterpretations
  where
    props = nub (propositions phi ++ propositions psi)
    allInterpretations = generateAllInterpretations props

-- 证明系统
type Context = [Formula]

data Derivation = 
    Assumption Formula
  | ImplicationIntro Formula Derivation
  | ImplicationElim Derivation Derivation
  | ConjunctionIntro Derivation Derivation
  | ConjunctionElim1 Derivation
  | ConjunctionElim2 Derivation
  | DisjunctionIntro1 Formula Derivation
  | DisjunctionIntro2 Formula Derivation
  | DisjunctionElim Derivation Derivation Derivation
  | NegationIntro Formula Derivation
  | NegationElim Derivation Derivation
  | ContradictionElim Derivation Formula
  deriving (Eq, Show)

conclusion :: Derivation -> Formula
conclusion (Assumption phi) = phi
conclusion (ImplicationIntro psi deriv) = Implies psi (conclusion deriv)
conclusion (ImplicationElim deriv1 deriv2) = 
    case conclusion deriv1 of
        Implies _ chi -> chi
        _ -> error "Invalid implication elimination"
conclusion (ConjunctionIntro deriv1 deriv2) = And (conclusion deriv1) (conclusion deriv2)
conclusion (ConjunctionElim1 deriv) = 
    case conclusion deriv of
        And psi _ -> psi
        _ -> error "Invalid conjunction elimination"
conclusion (ConjunctionElim2 deriv) = 
    case conclusion deriv of
        And _ chi -> chi
        _ -> error "Invalid conjunction elimination"
conclusion (DisjunctionIntro1 psi deriv) = Or psi (conclusion deriv)
conclusion (DisjunctionIntro2 psi deriv) = Or (conclusion deriv) psi
conclusion (DisjunctionElim _ deriv2 _) = conclusion deriv2
conclusion (NegationIntro psi deriv) = Not psi
conclusion (NegationElim _ _) = Atom "⊥"
conclusion (ContradictionElim _ phi) = phi

checkProof :: Context -> Formula -> Derivation -> Bool
checkProof ctx phi (Assumption psi) = psi `elem` ctx
checkProof ctx phi (ImplicationIntro psi deriv) = 
    phi == Implies psi (conclusion deriv) && 
    checkProof (psi:ctx) (conclusion deriv) deriv
checkProof ctx phi (ImplicationElim deriv1 deriv2) = 
    case conclusion deriv1 of
        Implies psi chi -> phi == chi && 
                          checkProof ctx (Implies psi chi) deriv1 && 
                          checkProof ctx psi deriv2
        _ -> False
checkProof ctx phi (ConjunctionIntro deriv1 deriv2) = 
    case phi of
        And psi chi -> checkProof ctx psi deriv1 && checkProof ctx chi deriv2
        _ -> False
checkProof ctx phi (ConjunctionElim1 deriv) = 
    case conclusion deriv of
        And psi _ -> phi == psi && checkProof ctx (conclusion deriv) deriv
        _ -> False
checkProof ctx phi (ConjunctionElim2 deriv) = 
    case conclusion deriv of
        And _ chi -> phi == chi && checkProof ctx (conclusion deriv) deriv
        _ -> False
checkProof ctx phi (DisjunctionIntro1 psi deriv) = 
    case phi of
        Or psi' chi -> psi == psi' && checkProof ctx psi deriv
        _ -> False
checkProof ctx phi (DisjunctionIntro2 psi deriv) = 
    case phi of
        Or chi psi' -> psi == psi' && checkProof ctx psi deriv
        _ -> False
checkProof ctx phi (DisjunctionElim deriv1 deriv2 deriv3) = 
    case conclusion deriv1 of
        Or psi chi -> checkProof ctx (Or psi chi) deriv1 &&
                     checkProof (psi:ctx) phi deriv2 &&
                     checkProof (chi:ctx) phi deriv3
        _ -> False
checkProof ctx phi (NegationIntro psi deriv) = 
    phi == Not psi && 
    checkProof (psi:ctx) (Atom "⊥") deriv
checkProof ctx phi (NegationElim deriv1 deriv2) = 
    case (conclusion deriv1, conclusion deriv2) of
        (psi, Not psi') -> psi == psi' && 
                          checkProof ctx psi deriv1 && 
                          checkProof ctx (Not psi) deriv2
        _ -> False
checkProof ctx phi (ContradictionElim deriv _) = 
    checkProof ctx (Atom "⊥") deriv

-- 元理论函数
isConsistent :: Context -> Bool
isConsistent ctx = not (hasProof ctx (Atom "⊥"))
  where
    hasProof gamma psi = -- 简化的证明存在性检查
        case psi of
            Implies alpha beta -> hasProof (alpha:gamma) beta
            And alpha beta -> hasProof gamma alpha && hasProof gamma beta
            Or alpha beta -> hasProof gamma alpha || hasProof gamma beta
            Not alpha -> hasProof (alpha:gamma) (Atom "⊥")
            _ -> psi `elem` gamma

soundness :: Context -> Formula -> Derivation -> Bool
soundness ctx phi deriv = 
    checkProof ctx phi deriv && 
    all (\i -> eval phi i) (modelsOf ctx)
  where
    modelsOf gamma = [i | i <- allInterpretations, all (\psi -> eval psi i) gamma]
    allInterpretations = generateAllInterpretations (concatMap propositions gamma)

-- 示例和测试
example1 :: Formula
example1 = Implies (And (Atom "p") (Atom "q")) (Atom "p")

example2 :: Formula
example2 = Or (Atom "p") (Not (Atom "p"))

example3 :: Formula
example3 = Implies (Atom "p") (Implies (Atom "q") (Atom "p"))

-- 测试函数
testTautology :: Bool
testTautology = isTautology example2

testSatisfiable :: Bool
testSatisfiable = isSatisfiable example1

testEquivalent :: Bool
testEquivalent = logicallyEquivalent 
    (Implies (Atom "p") (Atom "q")) 
    (Or (Not (Atom "p")) (Atom "q"))
```

### 7.2 测试和验证

```haskell
-- 测试模块
module PropositionalLogicTest where

import PropositionalLogic

-- 基本测试
testBasic :: IO ()
testBasic = do
    putStrLn "=== 命题逻辑基础测试 ==="
    
    -- 测试重言式
    putStrLn $ "p ∨ ¬p 是重言式: " ++ show (isTautology example2)
    
    -- 测试可满足性
    putStrLn $ "p ∧ q → p 是可满足的: " ++ show (isSatisfiable example1)
    
    -- 测试逻辑等价
    putStrLn $ "p → q ≡ ¬p ∨ q: " ++ show testEquivalent
    
    -- 测试复杂度
    putStrLn $ "p ∧ q → p 的复杂度: " ++ show (complexity example1)
    
    -- 测试子公式
    putStrLn $ "p ∧ q → p 的子公式数量: " ++ show (length (subformulas example1))

-- 运行所有测试
runTests :: IO ()
runTests = do
    testBasic
    putStrLn "\n所有测试完成！"
```

## 8. 应用与扩展

### 8.1 应用领域

1. **形式验证**: 软件和硬件的形式化验证
2. **人工智能**: 知识表示和推理系统
3. **数据库**: 查询语言和约束条件
4. **编译器**: 语法分析和语义分析
5. **密码学**: 协议验证和安全分析

### 8.2 扩展方向

1. **一阶逻辑**: 添加量词和谓词
2. **模态逻辑**: 添加模态算子
3. **时态逻辑**: 添加时间算子
4. **直觉逻辑**: 构造性证明
5. **线性逻辑**: 资源敏感推理

### 8.3 实际应用示例

```haskell
-- 电路设计验证
circuitExample :: Formula
circuitExample = 
    Iff (And (Atom "input1") (Atom "input2")) 
        (Atom "output")

-- 协议验证
protocolExample :: Formula
protocolExample = 
    Implies (And (Atom "send") (Atom "receive")) 
            (Atom "complete")

-- 约束条件
constraintExample :: Formula
constraintExample = 
    Implies (Atom "condition1") 
            (Or (Atom "action1") (Atom "action2"))
```

## 总结

本文档提供了命题逻辑的完整形式化处理，包括：

1. **严格的数学定义**: 语法、语义、证明系统的形式化定义
2. **完整的Haskell实现**: 类型安全、函数式的实现
3. **元理论性质**: 可靠性、完备性等重要定理
4. **实际应用**: 形式验证、人工智能等领域的应用

这个基础为更高级的逻辑系统（如一阶逻辑、模态逻辑、时态逻辑等）提供了坚实的基础，也为形式化方法在计算机科学中的应用提供了理论支撑。
