# 设计模式实践案例

> 本文档展示Haskell与Lean在设计模式实践方面的具体案例与应用，包括实际项目示例、最佳实践和实现模板，是设计模式目录的实践指南。

## 1. 函数式设计模式实践

### 1.1 Reader模式实践案例

**Haskell实现：配置依赖注入**:

```haskell
-- Reader模式实现依赖注入
import Control.Monad.Reader

data AppConfig = AppConfig {
    dbUrl :: String,
    apiKey :: String,
    maxConnections :: Int
}

-- 使用Reader管理配置依赖
type AppM a = Reader AppConfig a

-- 访问配置的函数
getDbConnection :: AppM Connection
getDbConnection = do
    config <- ask
    liftIO $ connectDb (dbUrl config) (maxConnections config)

-- 业务逻辑
getUserData :: UserId -> AppM UserData
getUserData uid = do
    conn <- getDbConnection
    liftIO $ queryUser conn uid

-- 运行应用
runApp :: AppConfig -> AppM a -> a
runApp config app = runReader app config

-- 实际使用
main :: IO ()
main = do
    let config = AppConfig "localhost:5432" "secret-key" 10
        userData = runApp config (getUserData 42)
    print userData
```

**Lean实现：可证明的配置依赖**:

```lean
-- 依赖类型Reader模式
structure AppConfig where
  dbUrl : String
  apiKey : String
  maxConnections : Nat
  -- 配置约束
  validConnections : maxConnections > 0

-- Reader模式
def AppM (α : Type) := AppConfig → α

-- 访问配置
def getDbUrl : AppM String :=
  fun config => config.dbUrl

-- 使用Reader模式
def getUserData (uid : UserId) : AppM UserData :=
  fun config => 
    let conn := connectDb config.dbUrl config.maxConnections
    queryUser conn uid

-- 运行应用并证明配置有效
def runApp {α : Type} (config : AppConfig) (app : AppM α) : α :=
  app config

-- 使用示例，带配置证明
def main : IO Unit := do
  let config : AppConfig := {
    dbUrl := "localhost:5432",
    apiKey := "secret-key",
    maxConnections := 10,
    validConnections := by sorry -- 提供10 > 0的证明
  }
  let userData := runApp config (getUserData 42)
  IO.println userData
```

### 1.2 Monad变换器实践

**Haskell实现：组合多种效应**:

```haskell
-- 综合效应的应用栈
import Control.Monad.Reader
import Control.Monad.State
import Control.Monad.Except

-- 应用状态
data AppState = AppState {
    userCache :: Map UserId User,
    requestCount :: Int
}

-- 错误类型
data AppError = NotFound | Unauthorized | ServerError String

-- 应用环境
data Env = Env {
    dbPool :: ConnectionPool,
    logger :: String -> IO ()
}

-- 组合多种效应的应用栈
type AppM a = ReaderT Env (StateT AppState (ExceptT AppError IO)) a

-- 中间件示例：记录请求
logRequest :: String -> AppM ()
logRequest endpoint = do
    env <- ask
    liftIO $ (logger env) $ "Request to " ++ endpoint
    modify $ \s -> s { requestCount = requestCount s + 1 }

-- 业务逻辑
getUser :: UserId -> AppM User
getUser uid = do
    logRequest $ "getUser " ++ show uid
    cache <- gets userCache
    case Map.lookup uid cache of
        Just user -> return user
        Nothing -> do
            env <- ask
            userM <- liftIO $ queryUser (dbPool env) uid
            case userM of
                Just user -> do
                    modify $ \s -> s { userCache = Map.insert uid user (userCache s) }
                    return user
                Nothing -> throwError NotFound

-- 运行应用
runApp :: Env -> AppState -> AppM a -> IO (Either AppError (a, AppState))
runApp env state app = runExceptT $ runStateT (runReaderT app env) state
```

**Lean实现：可验证的效应组合**:

```lean
-- 带证明的效应组合
structure AppState where
  userCache : Map UserId User
  requestCount : Nat

structure AppError
| notFound : AppError
| unauthorized : AppError
| serverError : String → AppError

structure Env where
  dbPool : ConnectionPool
  logger : String → IO Unit

-- 依赖类型版本的应用栈
def AppM (α : Type) :=
  Env → AppState → IO (Except AppError (α × AppState))

-- 访问环境
def ask : AppM Env :=
  fun env state => pure (Except.ok (env, state))

-- 修改状态
def modify (f : AppState → AppState) : AppM Unit :=
  fun env state => pure (Except.ok ((), f state))

-- 抛出错误
def throwError (err : AppError) : AppM α :=
  fun _ _ => pure (Except.error err)

-- 中间件：记录请求
def logRequest (endpoint : String) : AppM Unit := do
  let env ← ask
  env.logger s!"Request to {endpoint}"
  modify (fun state => { state with requestCount := state.requestCount + 1 })

-- 业务逻辑带证明
def getUser (uid : UserId) : AppM User := do
  logRequest s!"getUser {uid}"
  let state ← get
  match state.userCache.find? uid with
  | some user => pure user
  | none => do
      let env ← ask
      let userOpt ← IO.runSync (queryUser env.dbPool uid)
      match userOpt with
      | some user => do
          modify (fun s => { s with userCache := s.userCache.insert uid user })
          pure user
      | none => throwError AppError.notFound

-- 运行应用
def runApp {α : Type} (env : Env) (state : AppState) (app : AppM α) : 
    IO (Except AppError (α × AppState)) :=
  app env state
```

## 2. 架构设计模式实践

### 2.1 MVC架构实践

**Haskell实现：Web应用中的MVC**:

```haskell
-- 使用Servant和MVC模式实现Web API
import Servant
import Data.Aeson
import Database.PostgreSQL.Simple

-- 模型层
data User = User {
    userId :: Int,
    userName :: String,
    userEmail :: String
}

instance FromRow User where
    fromRow = User <$> field <*> field <*> field

-- 数据访问层
class Monad m => UserRepository m where
    findAll :: m [User]
    findById :: Int -> m (Maybe User)
    save :: User -> m Int

instance UserRepository IO where
    findAll = do
        conn <- getConnection
        query_ conn "SELECT id, name, email FROM users"
    
    findById uid = do
        conn <- getConnection
        result <- query conn "SELECT id, name, email FROM users WHERE id = ?" (Only uid)
        return $ listToMaybe result
    
    save user = do
        conn <- getConnection
        execute conn "INSERT INTO users (name, email) VALUES (?, ?) RETURNING id"
               (userName user, userEmail user)

-- 控制器层
type UserAPI = 
    "users" :> Get '[JSON] [User]
    :<|> "users" :> Capture "id" Int :> Get '[JSON] User
    :<|> "users" :> ReqBody '[JSON] User :> Post '[JSON] Int

userServer :: Server UserAPI
userServer = 
    getAllUsers
    :<|> getUserById
    :<|> createUser

getAllUsers :: Handler [User]
getAllUsers = liftIO findAll

getUserById :: Int -> Handler User
getUserById uid = do
    userM <- liftIO $ findById uid
    case userM of
        Just user -> return user
        Nothing -> throwError err404

createUser :: User -> Handler Int
createUser = liftIO . save

-- 视图层（API返回的JSON表示）
instance ToJSON User
instance FromJSON User

-- 应用入口
app :: Application
app = serve userAPI userServer

userAPI :: Proxy UserAPI
userAPI = Proxy

main :: IO ()
main = run 8080 app
```

**Lean实现：可验证的MVC架构**:

```lean
-- 类型驱动的MVC架构
structure User where
  id : Nat
  name : String
  email : String
  -- 不变量：电子邮件必须包含@符号
  validEmail : email.contains "@"

-- 数据访问接口
class UserRepository (m : Type → Type) where
  findAll : m (List User)
  findById : Nat → m (Option User)
  save : User → m Nat

-- 正确性证明
class UserRepositorySpec (m : Type → Type) where
  findById_returns_valid : ∀ (id : Nat) (user : User),
    findById id = some user → user.id = id
  save_generates_id : ∀ (user : User) (id : Nat),
    save user = id → id > 0
  save_then_find : ∀ (user : User) (id : Nat),
    save user = id → findById id = some { user with id := id }

-- 控制器层
class UserController (m : Type → Type) where
  getAllUsers : m (List User)
  getUserById : Nat → m (Option User)
  createUser : String → String → Option Nat
                → m (Except String Nat)

-- 控制器实现
instance [UserRepository m] : UserController m where
  getAllUsers := findAll
  getUserById := findById
  createUser name email _ := do
    if email.contains "@" then
      let user : User := {
        id := 0,
        name := name,
        email := email,
        validEmail := by sorry -- 提供email包含@的证明
      }
      let id ← save user
      pure (Except.ok id)
    else
      pure (Except.error "Invalid email format")

-- Web API规范（伪代码）
def UserAPI := {
  "users" → GET → returns (List User),
  "users/{id}" → GET → returns (Option User),
  "users" → POST → accepts User → returns Nat
}

-- 服务器应用
def server [UserRepository IO] : IO Unit :=
  startServer 8080 UserAPI
```

### 2.2 CQRS与事件溯源实践

**Haskell实现：银行账户系统**:

```haskell
-- CQRS与事件溯源模式
import Data.Time
import qualified Data.Map as Map

-- 事件定义
data AccountEvent = 
    AccountCreated { accountId :: String, owner :: String, timestamp :: UTCTime }
    | MoneyDeposited { accountId :: String, amount :: Double, timestamp :: UTCTime }
    | MoneyWithdrawn { accountId :: String, amount :: Double, timestamp :: UTCTime }
    | AccountClosed { accountId :: String, timestamp :: UTCTime }

-- 命令定义
data AccountCommand = 
    CreateAccount { cmdAccountId :: String, cmdOwner :: String }
    | DepositMoney { cmdAccountId :: String, cmdAmount :: Double }
    | WithdrawMoney { cmdAccountId :: String, cmdAmount :: Double }
    | CloseAccount { cmdAccountId :: String }

-- 查询模型
data AccountView = AccountView {
    viewAccountId :: String,
    viewOwner :: String,
    viewBalance :: Double,
    viewIsActive :: Bool,
    viewLastUpdated :: UTCTime
}

-- 命令处理
handleCommand :: AccountCommand -> [AccountEvent] -> IO [AccountEvent]
handleCommand cmd events = do
    now <- getCurrentTime
    case cmd of
        CreateAccount accId owner -> 
            if null events
            then return [AccountCreated accId owner now]
            else error "Account already exists"
            
        DepositMoney accId amount ->
            let view = buildView events
            in if viewIsActive view
               then return [MoneyDeposited accId amount now]
               else error "Account is closed"
               
        WithdrawMoney accId amount ->
            let view = buildView events
                balance = viewBalance view
            in if not (viewIsActive view)
               then error "Account is closed"
               else if balance < amount
                    then error "Insufficient funds"
                    else return [MoneyWithdrawn accId amount now]
                    
        CloseAccount accId ->
            let view = buildView events
            in if viewIsActive view
               then return [AccountClosed accId now]
               else error "Account already closed"

-- 事件处理：构建查询模型
buildView :: [AccountEvent] -> AccountView
buildView = foldl applyEvent defaultView
  where
    defaultView = AccountView "" "" 0 False minBound
    
    applyEvent view (AccountCreated accId owner time) =
        view { viewAccountId = accId, viewOwner = owner, 
               viewIsActive = True, viewLastUpdated = time }
               
    applyEvent view (MoneyDeposited _ amount time) =
        view { viewBalance = viewBalance view + amount, viewLastUpdated = time }
        
    applyEvent view (MoneyWithdrawn _ amount time) =
        view { viewBalance = viewBalance view - amount, viewLastUpdated = time }
        
    applyEvent view (AccountClosed _ time) =
        view { viewIsActive = False, viewLastUpdated = time }

-- 事件存储
saveEvents :: String -> [AccountEvent] -> IO ()
saveEvents accountId events = do
    -- 保存到事件存储
    putStrLn $ "Saving events for account " ++ accountId
    
-- 查询服务
getAccountView :: String -> IO AccountView
getAccountView accountId = do
    -- 从事件存储读取事件
    events <- loadEventsForAccount accountId
    return $ buildView events
    
loadEventsForAccount :: String -> IO [AccountEvent]
loadEventsForAccount = undefined -- 从数据库读取事件
```

**Lean实现：可验证的CQRS**:

```lean
-- 带证明的CQRS与事件溯源
import Lean.Data.Json

structure AccountId where
  value : String
  validFormat : String.length value > 0

-- 事件定义，带时间戳
inductive AccountEvent where
| accountCreated : AccountId → String → Time → AccountEvent
| moneyDeposited : AccountId → Float → Time → AccountEvent
| moneyWithdrawn : AccountId → Float → Time → AccountEvent
| accountClosed : AccountId → Time → AccountEvent

-- 命令定义
inductive AccountCommand where
| createAccount : AccountId → String → AccountCommand
| depositMoney : AccountId → Float → AccountCommand
| withdrawMoney : AccountId → Float → AccountCommand
| closeAccount : AccountId → AccountCommand

-- 查询模型带不变量
structure AccountView where
  accountId : AccountId
  owner : String
  balance : Float
  isActive : Bool
  lastUpdated : Time
  -- 不变量：没有负数余额
  nonNegativeBalance : balance ≥ 0

-- 命令处理器带证明
def handleCommand (cmd : AccountCommand) (events : List AccountEvent) : 
    Except String (List AccountEvent) :=
  match cmd with
  | AccountCommand.createAccount accId owner => do
      if events.isEmpty then
        let now ← getCurrentTime
        pure [AccountEvent.accountCreated accId owner now]
      else
        throw "Account already exists"
        
  | AccountCommand.depositMoney accId amount => do
      let view ← buildView events
      if view.isActive then
        let now ← getCurrentTime
        pure [AccountEvent.moneyDeposited accId amount now]
      else
        throw "Account is closed"
        
  | AccountCommand.withdrawMoney accId amount => do
      let view ← buildView events
      if !view.isActive then
        throw "Account is closed"
      else if view.balance < amount then
        throw "Insufficient funds"
      else
        let now ← getCurrentTime
        pure [AccountEvent.moneyWithdrawn accId amount now]
        
  | AccountCommand.closeAccount accId => do
      let view ← buildView events
      if view.isActive then
        let now ← getCurrentTime
        pure [AccountEvent.accountClosed accId now]
      else
        throw "Account already closed"

-- 事件处理：构建查询模型，带证明
def buildView (events : List AccountEvent) : Option AccountView :=
  events.foldl applyEvent none
  where
    applyEvent : Option AccountView → AccountEvent → Option AccountView
    | none, AccountEvent.accountCreated accId owner time => 
        some {
          accountId := accId,
          owner := owner,
          balance := 0,
          isActive := true,
          lastUpdated := time,
          nonNegativeBalance := by simp -- 证明0 ≥ 0
        }
    
    | some view, AccountEvent.moneyDeposited _ amount time =>
        some {
          view with
          balance := view.balance + amount,
          lastUpdated := time,
          nonNegativeBalance := by sorry -- 证明 view.balance + amount ≥ 0
        }
        
    | some view, AccountEvent.moneyWithdrawn _ amount time =>
        -- 这里我们知道命令处理器确保余额充足
        some {
          view with
          balance := view.balance - amount,
          lastUpdated := time,
          nonNegativeBalance := by sorry -- 证明 view.balance - amount ≥ 0
        }
        
    | some view, AccountEvent.accountClosed _ time =>
        some {
          view with
          isActive := false,
          lastUpdated := time
        }
        
    | view, _ => view -- 其他情况保持不变

-- 系统正确性证明
theorem withdraw_preserves_non_negative_balance :
  ∀ (cmd : AccountCommand) (events : List AccountEvent) (newEvents : List AccountEvent),
  handleCommand cmd events = Except.ok newEvents →
  match cmd with
  | AccountCommand.withdrawMoney _ _ =>
      let viewBefore := buildView events
      let viewAfter := buildView (events ++ newEvents)
      viewBefore.map (fun v => v.balance) = some 0 →
      viewAfter.map (fun v => v.balance) = some 0
  | _ => True :=
by sorry -- 具体证明
```

## 3. 设计模式实践指南

### 3.1 函数式设计模式选择指南

| 场景 | 推荐模式 | Haskell实现 | Lean实现 |
|------|----------|------------|----------|
| **配置管理** | Reader模式 | ReaderT环境 | 依赖类型Reader |
| **错误处理** | Either/Except | Either, ExceptT | Except类型 |
| **状态管理** | State模式 | StateT变换器 | 状态传递函数 |
| **异步操作** | Promise/Future | Async库 | IO Monad |
| **数据验证** | Applicative验证 | Validation | 依赖类型约束 |

### 3.2 架构模式选择指南

| 场景 | 推荐架构 | Haskell优势 | Lean优势 |
|------|----------|------------|----------|
| **数据密集型** | 分层+事件源 | 高性能库支持 | 数据一致性证明 |
| **交互密集型** | MVC或MVVM | Web框架生态 | UI状态验证 |
| **领域复杂型** | DDD+CQRS | 表达力强 | 领域规则形式化 |
| **高可靠系统** | Actor模型 | 并发库支持 | 并发安全证明 |

### 3.3 模式使用最佳实践

1. **逐步引入复杂性**
   - 从简单模式开始，如Reader和State
   - 随着需求增长引入更复杂的架构

2. **类型驱动设计**
   - 先设计类型和接口，后实现
   - 利用类型系统捕获领域规则

3. **分离关注点**
   - 将纯逻辑与IO分离
   - 使用变换器栈隔离不同效应

4. **验证与实现平衡**
   - Lean用于核心算法验证
   - Haskell用于高效实现

5. **模式组合**
   - 组合小型模式构建复杂系统
   - 利用函数组合构建流水线

## 4. 实践案例结论

Haskell和Lean在设计模式实践中展现出强大的互补性：

1. **Haskell的优势**：生态系统丰富，工程化程度高，库支持完善，执行效率高
2. **Lean的优势**：形式验证能力强，类型安全保障高，可以证明系统属性
3. **最佳实践**：结合两者优势，用Lean设计核心算法和验证关键属性，用Haskell实现高效系统

通过这种协同方法，可以同时获得形式化方法的严谨性和实用系统的高效性，创建既正确又高效的软件系统。

---

-*最后更新：2024年*
