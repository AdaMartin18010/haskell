# Haskell 函数组合 (Function Composition)

## 概述

函数组合是函数式编程的核心概念，它允许我们将多个函数连接起来形成新的函数。在Haskell中，函数组合通过 `(.)` 操作符实现，这是函数式编程中最优雅和强大的特性之一。

## 数学定义

### 函数组合的形式化定义

给定两个函数 $f : B \to C$ 和 $g : A \to B$，它们的组合 $f \circ g : A \to C$ 定义为：

$$(f \circ g)(x) = f(g(x))$$

### 函数组合的代数性质

#### 1. 结合律

对于函数 $f : C \to D$，$g : B \to C$，$h : A \to B$：

$$(f \circ g) \circ h = f \circ (g \circ h)$$

#### 2. 单位元

对于函数 $f : A \to B$，恒等函数 $\text{id} : A \to A$ 满足：

$$f \circ \text{id} = f = \text{id} \circ f$$

其中 $\text{id}(x) = x$。

#### 3. 分配律

对于函数 $f, g : A \to B$ 和 $h : B \to C$：

$$h \circ (f + g) = h \circ f + h \circ g$$

## Haskell中的函数组合

### 基本语法

```haskell
-- 函数组合操作符 (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)

-- 数学定义：f . g = λx. f(g(x))
```

### 基本示例

```haskell
-- 基本函数组合
addOne :: Int -> Int
addOne = (+1)

double :: Int -> Int
double = (*2)

-- 组合函数：先加1，再乘2
addOneThenDouble :: Int -> Int
addOneThenDouble = double . addOne

-- 等价于：addOneThenDouble x = double (addOne x)

-- 测试
main :: IO ()
main = do
    print $ addOneThenDouble 5  -- 12 (5+1)*2
    print $ (double . addOne) 5 -- 12
```

## 高级函数组合

### 1. 多函数组合

```haskell
-- 组合多个函数
square :: Int -> Int
square = (^2)

-- 组合三个函数：先加1，再平方，最后乘2
complexFunction :: Int -> Int
complexFunction = double . square . addOne

-- 等价于：complexFunction x = double (square (addOne x))

-- 测试
main :: IO ()
main = do
    print $ complexFunction 3  -- 32 ((3+1)^2)*2
```

### 2. 列表函数组合

```haskell
-- 列表处理函数组合
filterEven :: [Int] -> [Int]
filterEven = filter even

mapSquare :: [Int] -> [Int]
mapSquare = map (^2)

takeFirst :: [Int] -> [Int]
takeFirst = take 3

-- 组合：过滤偶数 -> 平方 -> 取前3个
processList :: [Int] -> [Int]
processList = takeFirst . mapSquare . filterEven

-- 测试
main :: IO ()
main = do
    let numbers = [1..10]
    print $ processList numbers  -- [4, 16, 36]
```

### 3. 高阶函数组合

```haskell
-- 高阶函数组合
compose :: (b -> c) -> (a -> b) -> a -> c
compose f g = f . g

-- 组合多个高阶函数
composeMany :: [a -> a] -> a -> a
composeMany = foldr (.) id

-- 测试
main :: IO ()
main = do
    let functions = [addOne, double, square]
    let combined = composeMany functions
    print $ combined 2  -- 36 ((2+1)*2)^2
```

## 函数组合的实用技巧

### 1. 管道操作

```haskell
-- 使用函数组合创建管道
data Person = Person 
    { name :: String
    , age :: Int
    , city :: String
    }

-- 管道函数
getName :: Person -> String
getName = name

toUpper :: String -> String
toUpper = map toUpper

addPrefix :: String -> String
addPrefix = ("Hello " ++)

-- 组合管道
greetPerson :: Person -> String
greetPerson = addPrefix . toUpper . getName

-- 测试
main :: IO ()
main = do
    let person = Person "alice" 25 "New York"
    print $ greetPerson person  -- "Hello ALICE"
```

### 2. 条件组合

```haskell
-- 条件函数组合
isPositive :: Int -> Bool
isPositive = (>0)

isEven :: Int -> Bool
isEven = even

-- 组合条件
isPositiveAndEven :: Int -> Bool
isPositiveAndEven = isPositive &&& isEven
  where (&&&) f g x = f x && g x

-- 或者使用 Applicative
import Control.Applicative

isPositiveAndEven' :: Int -> Bool
isPositiveAndEven' = liftA2 (&&) isPositive isEven

-- 测试
main :: IO ()
main = do
    print $ isPositiveAndEven 4   -- True
    print $ isPositiveAndEven 3   -- False
    print $ isPositiveAndEven (-2) -- False
```

### 3. 错误处理组合

```haskell
-- Maybe 类型的函数组合
safeDivide :: Double -> Double -> Maybe Double
safeDivide _ 0 = Nothing
safeDivide x y = Just (x / y)

safeSqrt :: Double -> Maybe Double
safeSqrt x
    | x < 0 = Nothing
    | otherwise = Just (sqrt x)

-- 组合安全函数
safeDivideAndSqrt :: Double -> Double -> Maybe Double
safeDivideAndSqrt x y = safeDivide x y >>= safeSqrt

-- 使用 Kleisli 组合
import Control.Monad

safeDivideAndSqrt' :: Double -> Double -> Maybe Double
safeDivideAndSqrt' = safeSqrt <=< safeDivide

-- 测试
main :: IO ()
main = do
    print $ safeDivideAndSqrt 4 2   -- Just 1.4142135623730951
    print $ safeDivideAndSqrt 4 0   -- Nothing
    print $ safeDivideAndSqrt (-4) 2 -- Nothing
```

## 函数组合的优化

### 1. 编译时优化

```haskell
-- 编译器会优化函数组合
optimizedComposition :: Int -> Int
optimizedComposition = (+1) . (*2) . (^2)

-- 编译器生成优化的代码，避免中间函数调用
-- 等价于：optimizedComposition x = ((x^2)*2)+1
```

### 2. 惰性求值

```haskell
-- 函数组合支持惰性求值
lazyComposition :: [Int] -> [Int]
lazyComposition = map (+1) . filter even . take 5

-- 只计算需要的元素
main :: IO ()
main = do
    let result = lazyComposition [1..1000000]
    print $ take 3 result  -- 只计算前3个元素
```

## 函数组合的理论基础

### 1. 范畴论视角

在范畴论中，函数组合是态射的组合：

```haskell
-- 范畴论中的函数组合
class Category cat where
    id :: cat a a
    (.) :: cat b c -> cat a b -> cat a c

-- Haskell 函数范畴
instance Category (->) where
    id = \x -> x
    (.) = (.)

-- 数学定义：在函数范畴中，对象是类型，态射是函数
```

### 2. 单子组合

```haskell
-- 单子组合
composeM :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
composeM f g = \x -> g x >>= f

-- Kleisli 组合
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
f <=< g = \x -> g x >>= f

-- 数学定义：Kleisli 组合是单子中的函数组合
```

## 实际应用示例

### 1. 数据处理管道

```haskell
-- 数据处理管道
processData :: [String] -> [Int]
processData = map read          -- 字符串转数字
            . filter (not . null) -- 过滤空字符串
            . map trim           -- 去除空格
            . filter (/= "")     -- 过滤空字符串
  where
    trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace

-- 测试
main :: IO ()
main = do
    let data = [" 1 ", "  ", "2", "", " 3 "]
    print $ processData data  -- [1, 2, 3]
```

### 2. 配置处理

```haskell
-- 配置处理管道
data Config = Config 
    { port :: Int
    , host :: String
    , debug :: Bool
    }

-- 配置验证函数
validatePort :: Int -> Maybe Int
validatePort p
    | p > 0 && p < 65536 = Just p
    | otherwise = Nothing

validateHost :: String -> Maybe String
validateHost h
    | not (null h) = Just h
    | otherwise = Nothing

-- 组合验证
validateConfig :: Config -> Maybe Config
validateConfig (Config p h d) = 
    Config <$> validatePort p <*> validateHost h <*> pure d

-- 测试
main :: IO ()
main = do
    let config1 = Config 8080 "localhost" True
    let config2 = Config 0 "localhost" True
    print $ validateConfig config1  -- Just (Config 8080 "localhost" True)
    print $ validateConfig config2  -- Nothing
```

### 3. 日志处理

```haskell
-- 日志处理管道
data LogEntry = LogEntry 
    { timestamp :: String
    , level :: String
    , message :: String
    }

-- 日志处理函数
parseTimestamp :: String -> Maybe String
parseTimestamp = Just . take 19  -- 简化处理

filterByLevel :: String -> [LogEntry] -> [LogEntry]
filterByLevel level = filter (\e -> level == LogEntry.level e)

extractMessage :: LogEntry -> String
extractMessage = message

-- 组合日志处理
processLogs :: String -> [LogEntry] -> [String]
processLogs level = map extractMessage 
                  . filterByLevel level
                  . filter (isJust . parseTimestamp . timestamp)
  where
    isJust (Just _) = True
    isJust Nothing = False

-- 测试
main :: IO ()
main = do
    let logs = [LogEntry "2024-01-01 10:00:00" "INFO" "System started"
               ,LogEntry "2024-01-01 10:01:00" "ERROR" "Connection failed"
               ,LogEntry "2024-01-01 10:02:00" "INFO" "System recovered"]
    print $ processLogs "INFO" logs  -- ["System started", "System recovered"]
```

## 形式化验证

### 1. 函数组合的性质验证

```haskell
import Test.QuickCheck

-- 验证结合律
prop_associativity :: Int -> Bool
prop_associativity x = 
    let f = (+1)
        g = (*2)
        h = (^2)
    in ((f . g) . h) x == (f . (g . h)) x

-- 验证单位元
prop_identity :: Int -> Bool
prop_identity x = 
    let f = (+1)
    in (f . id) x == f x && (id . f) x == f x

-- 测试
main :: IO ()
main = do
    quickCheck prop_associativity
    quickCheck prop_identity
```

### 2. 函数组合的终止性

```haskell
-- 函数组合的终止性证明
-- 如果 f 和 g 都是终止的，那么 f . g 也是终止的
-- 证明：对于输入 x，g(x) 终止产生值 y，然后 f(y) 终止产生最终值
```

## 总结

函数组合是Haskell函数式编程的核心特性，它提供了：

1. **声明式编程**：通过组合描述计算流程
2. **模块化**：将复杂函数分解为简单函数
3. **可读性**：代码意图清晰明确
4. **可维护性**：易于修改和扩展
5. **性能优化**：编译器可以优化组合函数

函数组合的数学基础确保了其正确性和可靠性，使其成为函数式编程中不可或缺的工具。

---

**相关主题**：
- [高阶函数](./高阶函数.md)
- [函数式编程基础](../01-Basic-Concepts/函数式编程基础.md)
- [类型系统](../04-Type-System/类型基础.md) 