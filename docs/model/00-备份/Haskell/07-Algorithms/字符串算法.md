# 字符串算法 - Haskell实现

## 概述

字符串算法是处理文本数据的基础算法，广泛应用于文本搜索、数据压缩、生物信息学等领域。本文档使用Haskell实现常见的字符串算法，展示函数式编程在字符串处理中的优势。

## 字符串匹配算法

### 朴素字符串匹配

```haskell
-- 朴素字符串匹配算法
naiveStringMatch :: String -> String -> [Int]
naiveStringMatch pattern text = 
    [i | i <- [0..length text - length pattern],
        pattern == take (length pattern) (drop i text)]

-- 使用Data.Text的优化版本
import qualified Data.Text as T
import qualified Data.Text.Internal.Search as Search

naiveTextMatch :: T.Text -> T.Text -> [Int]
naiveTextMatch pattern text = 
    [i | i <- [0..T.length text - T.length pattern],
        pattern == T.take (T.length pattern) (T.drop i text)]
```

### Knuth-Morris-Pratt算法

```haskell
-- KMP算法的失效函数
failureFunction :: String -> [Int]
failureFunction pattern = 
    let n = length pattern
        f = array (0, n-1) [(0, -1)] :: Array Int Int
        
        buildFailure i j = 
            if i >= n 
            then f
            else if pattern !! i == pattern !! j
                 then let f' = f // [(i+1, j+1)]
                      in buildFailure (i+1) (j+1)
                 else if j > 0
                      then buildFailure i (f ! j)
                      else let f' = f // [(i+1, 0)]
                           in buildFailure (i+1) 0
    in elems $ buildFailure 1 0

-- KMP字符串匹配
kmpMatch :: String -> String -> [Int]
kmpMatch pattern text = 
    let failure = failureFunction pattern
        n = length pattern
        m = length text
        
        search i j matches = 
            if i >= m 
            then reverse matches
            else if j >= 0 && pattern !! j /= text !! i
                 then search i (failure !! j) matches
                 else if j == n - 1
                      then search (i+1) (failure !! j) ((i-j):matches)
                      else search (i+1) (j+1) matches
    in search 0 0 []
```

### Boyer-Moore算法

```haskell
-- Boyer-Moore算法的坏字符规则
badCharacterRule :: String -> Map Char Int
badCharacterRule pattern = 
    Map.fromList [(c, i) | (c, i) <- zip pattern [0..]]

-- Boyer-Moore算法的好后缀规则
goodSuffixRule :: String -> [Int]
goodSuffixRule pattern = 
    let n = length pattern
        suffix = array (0, n-1) [(i, 0) | i <- [0..n-1]] :: Array Int Int
        
        -- 计算后缀数组
        buildSuffix i j = 
            if i < 0 
            then suffix
            else if pattern !! (n-1-j) == pattern !! i
                 then let suffix' = suffix // [(j+1, i+1)]
                      in buildSuffix (i-1) (j+1)
                 else buildSuffix (i-1) j
    in elems $ buildSuffix (n-2) 0

-- Boyer-Moore字符串匹配
boyerMooreMatch :: String -> String -> [Int]
boyerMooreMatch pattern text = 
    let badChar = badCharacterRule pattern
        goodSuffix = goodSuffixRule pattern
        n = length pattern
        m = length text
        
        search i matches = 
            if i > m - n 
            then reverse matches
            else let j = n - 1
                     matchPos = i + j
                 in if j >= 0 && pattern !! j == text !! matchPos
                    then search i matches  -- 继续向左匹配
                    else let badCharShift = j - Map.findWithDefault (-1) (text !! matchPos) badChar
                             goodSuffixShift = if j == n - 1 
                                              then 1 
                                              else n - 1 - goodSuffix !! (n - 1 - j)
                             shift = max badCharShift goodSuffixShift
                         in search (i + shift) matches
    in search 0 []
```

## 编辑距离算法

### Levenshtein距离

```haskell
-- Levenshtein编辑距离
levenshteinDistance :: String -> String -> Int
levenshteinDistance s1 s2 = 
    let m = length s1
        n = length s2
        dp = array ((0,0), (m,n)) [((i,j), 0) | i <- [0..m], j <- [0..n]] :: Array (Int,Int) Int
        
        -- 初始化第一行和第一列
        initDP = dp // [((0,j), j) | j <- [0..n]] 
                      // [((i,0), i) | i <- [0..m]]
        
        -- 填充DP表
        fillDP i j = 
            if i > m 
            then initDP
            else if j > n 
                 then fillDP (i+1) 0
                 else let cost = if s1 !! (i-1) == s2 !! (j-1) then 0 else 1
                          dp' = fillDP i (j+1)
                          current = minimum [dp' ! (i-1, j) + 1,      -- 删除
                                           dp' ! (i, j-1) + 1,      -- 插入
                                           dp' ! (i-1, j-1) + cost] -- 替换
                      in dp' // [((i,j), current)]
    in (fillDP 1 1) ! (m,n)

-- 使用记忆化的优化版本
levenshteinMemo :: String -> String -> Int
levenshteinMemo s1 s2 = 
    let m = length s1
        n = length s2
        memo = array ((0,0), (m,n)) [((i,j), -1) | i <- [0..m], j <- [0..n]] :: Array (Int,Int) Int
        
        distance i j = 
            if memo ! (i,j) >= 0 
            then memo ! (i,j)
            else let result = case (i, j) of
                                (0, _) -> j
                                (_, 0) -> i
                                (i', j') -> let cost = if s1 !! (i'-1) == s2 !! (j'-1) 
                                                      then 0 else 1
                                          in minimum [distance (i'-1) j' + 1,
                                                     distance i' (j'-1) + 1,
                                                     distance (i'-1) (j'-1) + cost]
                 in memo // [((i,j), result)]
    in distance m n
```

### 最长公共子序列 (LCS)

```haskell
-- 最长公共子序列
longestCommonSubsequence :: String -> String -> String
longestCommonSubsequence s1 s2 = 
    let m = length s1
        n = length s2
        dp = array ((0,0), (m,n)) [((i,j), 0) | i <- [0..m], j <- [0..n]] :: Array (Int,Int) Int
        
        -- 填充DP表
        fillDP i j = 
            if i > m 
            then dp
            else if j > n 
                 then fillDP (i+1) 0
                 else let dp' = fillDP i (j+1)
                          current = if s1 !! (i-1) == s2 !! (j-1)
                                   then dp' ! (i-1, j-1) + 1
                                   else max (dp' ! (i-1, j)) (dp' ! (i, j-1))
                      in dp' // [((i,j), current)]
        
        -- 回溯构建LCS
        backtrack i j = 
            if i == 0 || j == 0 
            then ""
            else if s1 !! (i-1) == s2 !! (j-1)
                 then backtrack (i-1) (j-1) ++ [s1 !! (i-1)]
                 else if dp ! (i-1, j) > dp ! (i, j-1)
                      then backtrack (i-1) j
                      else backtrack i (j-1)
        
        dp' = fillDP 1 1
    in backtrack m n
```

## 字符串压缩算法

### 游程编码 (RLE)

```haskell
-- 游程编码
runLengthEncode :: String -> [(Char, Int)]
runLengthEncode [] = []
runLengthEncode (x:xs) = 
    let (run, rest) = span (== x) xs
    in (x, 1 + length run) : runLengthEncode rest

-- 游程解码
runLengthDecode :: [(Char, Int)] -> String
runLengthDecode = concatMap (\(c, n) -> replicate n c)

-- 压缩字符串
compressRLE :: String -> String
compressRLE = concatMap (\(c, n) -> 
    if n == 1 then [c] else c : show n) . runLengthEncode
```

### Huffman编码

```haskell
-- Huffman树节点
data HuffmanTree = Leaf Char Int | Node Int HuffmanTree HuffmanTree deriving Show

-- 计算频率
frequency :: String -> Map Char Int
frequency = foldr (\c -> Map.insertWith (+) c 1) Map.empty

-- 构建Huffman树
buildHuffmanTree :: String -> HuffmanTree
buildHuffmanTree text = 
    let freq = frequency text
        leaves = [Leaf c f | (c, f) <- Map.toList freq]
        
        buildTree [] = error "Empty text"
        buildTree [tree] = tree
        buildTree trees = 
            let sorted = sortBy (comparing weight) trees
                (t1:t2:rest) = sorted
                newNode = Node (weight t1 + weight t2) t1 t2
            in buildTree (newNode:rest)
        
        weight (Leaf _ w) = w
        weight (Node _ left right) = w
    in buildTree leaves

-- 生成Huffman编码
huffmanCodes :: HuffmanTree -> Map Char String
huffmanCodes tree = 
    let go (Leaf c _) code = Map.singleton c code
        go (Node _ left right) code = 
            Map.union (go left (code ++ "0")) 
                     (go right (code ++ "1"))
    in go tree ""

-- Huffman编码
huffmanEncode :: String -> (HuffmanTree, String)
huffmanEncode text = 
    let tree = buildHuffmanTree text
        codes = huffmanCodes tree
        encoded = concatMap (\c -> codes Map.! c) text
    in (tree, encoded)

-- Huffman解码
huffmanDecode :: HuffmanTree -> String -> String
huffmanDecode tree bits = 
    let go (Leaf c _) _ = [c]
        go (Node _ left right) ('0':rest) = go left rest
        go (Node _ left right) ('1':rest) = go right rest
        go _ [] = []
        
        decodeAll [] = []
        decodeAll bits = 
            let (char, rest) = decodeOne tree bits
            in char : decodeAll rest
        
        decodeOne (Leaf c _) bits = (c, bits)
        decodeOne (Node _ left right) ('0':rest) = decodeOne left rest
        decodeOne (Node _ left right) ('1':rest) = decodeOne right rest
    in decodeAll bits
```

## 字符串哈希算法

### 多项式哈希

```haskell
-- 多项式哈希函数
polynomialHash :: String -> Int
polynomialHash s = 
    let p = 31  -- 质数
        m = 10^9 + 7  -- 模数
    in foldl (\hash c -> (hash * p + fromEnum c) `mod` m) 0 s

-- 滚动哈希
rollingHash :: String -> Int -> [Int]
rollingHash s windowSize = 
    let p = 31
        m = 10^9 + 7
        pPow = take windowSize $ iterate (\x -> (x * p) `mod` m) 1
        
        initialHash = sum $ zipWith (\c pow -> 
            (fromEnum c * pow) `mod` m) (take windowSize s) pPow
        
        roll hash i = 
            if i + windowSize > length s 
            then []
            else let oldChar = fromEnum (s !! i)
                     newChar = fromEnum (s !! (i + windowSize))
                     newHash = ((hash - oldChar * head pPow) * p + newChar) `mod` m
                 in newHash : roll newHash (i + 1)
    in initialHash : roll initialHash 0
```

### Rabin-Karp算法

```haskell
-- Rabin-Karp字符串匹配
rabinKarpMatch :: String -> String -> [Int]
rabinKarpMatch pattern text = 
    let m = length pattern
        n = length text
        p = 31
        mod = 10^9 + 7
        
        patternHash = polynomialHash pattern
        textHashes = rollingHash text m
        
        matches = [i | (i, hash) <- zip [0..] textHashes, 
                      hash == patternHash,
                      take m (drop i text) == pattern]
    in matches
```

## 后缀数组和LCP数组

### 后缀数组构建

```haskell
-- 后缀数组
buildSuffixArray :: String -> [Int]
buildSuffixArray text = 
    let n = length text
        suffixes = [(i, drop i text) | i <- [0..n-1]]
        sorted = sortBy (comparing snd) suffixes
    in map fst sorted

-- 最长公共前缀数组
longestCommonPrefix :: String -> String -> Int
longestCommonPrefix s1 s2 = 
    length $ takeWhile (uncurry (==)) $ zip s1 s2

-- LCP数组
buildLCPArray :: String -> [Int] -> [Int]
buildLCPArray text suffixArray = 
    let n = length text
        lcp = array (0, n-1) [(i, 0) | i <- [0..n-1]] :: Array Int Int
        
        computeLCP i = 
            if i == 0 
            then 0
            else let prevSuffix = text `drop` (suffixArray !! (i-1))
                     currSuffix = text `drop` (suffixArray !! i)
                 in longestCommonPrefix prevSuffix currSuffix
        
        lcpArray = [computeLCP i | i <- [0..n-1]]
    in lcpArray
```

## 实际应用示例

### 文本搜索系统

```haskell
-- 简单的文本搜索系统
data TextIndex = TextIndex 
    { documents :: [String]
    , index :: Map String [Int]  -- 词 -> 文档ID列表
    } deriving Show

-- 构建索引
buildIndex :: [String] -> TextIndex
buildIndex docs = 
    let words = concatMap (\doc -> zip (words doc) (repeat doc)) docs
        indexMap = foldr (\(word, doc) acc -> 
            Map.insertWith (++) word [doc] acc) Map.empty words
    in TextIndex docs indexMap

-- 搜索
search :: TextIndex -> String -> [String]
search index query = 
    let queryWords = words query
        docSets = map (\word -> Set.fromList $ Map.findWithDefault [] word (index index)) queryWords
        intersection = foldr1 Set.intersection docSets
    in Set.toList intersection
```

### DNA序列分析

```haskell
-- DNA序列类型
type DNASequence = String

-- 计算GC含量
gcContent :: DNASequence -> Double
gcContent sequence = 
    let gcCount = length $ filter (`elem` "GC") sequence
        totalLength = length sequence
    in fromIntegral gcCount / fromIntegral totalLength

-- 寻找重复序列
findRepeats :: DNASequence -> Int -> [(String, [Int])]
findRepeats sequence minLength = 
    let n = length sequence
        substrings = [(i, take minLength (drop i sequence)) | 
                     i <- [0..n-minLength]]
        grouped = groupBy ((==) `on` snd) $ sortBy (comparing snd) substrings
        repeats = filter (\group -> length group > 1) grouped
    in [(snd (head group), map fst group) | group <- repeats]

-- 序列比对
sequenceAlignment :: DNASequence -> DNASequence -> Int
sequenceAlignment s1 s2 = levenshteinDistance s1 s2
```

## 性能优化

### 使用Data.Text优化

```haskell
import qualified Data.Text as T
import qualified Data.Text.Internal.Search as Search

-- 优化的字符串匹配
optimizedMatch :: T.Text -> T.Text -> [Int]
optimizedMatch pattern text = 
    let indices = Search.indices pattern text
    in map fromIntegral indices

-- 批量字符串处理
batchProcess :: [T.Text] -> (T.Text -> T.Text) -> [T.Text]
batchProcess texts f = map f texts

-- 并行字符串处理
parallelProcess :: [T.Text] -> (T.Text -> T.Text) -> [T.Text]
parallelProcess texts f = 
    let chunks = chunksOf 1000 texts
    in concat $ parMap rpar (map f) chunks
```

### 内存优化

```haskell
-- 流式字符串处理
streamProcess :: String -> (Char -> Bool) -> String
streamProcess text predicate = 
    filter predicate text

-- 惰性字符串生成
lazyStringGeneration :: Int -> String
lazyStringGeneration n = 
    take n $ cycle "abcdefghijklmnopqrstuvwxyz"

-- 字符串缓存
stringCache :: Map String Int
stringCache = Map.empty

-- 带缓存的字符串处理
cachedProcess :: String -> (String -> Int) -> Map String Int -> (Int, Map String Int)
cachedProcess input f cache = 
    case Map.lookup input cache of
        Just result -> (result, cache)
        Nothing -> 
            let result = f input
                newCache = Map.insert input result cache
            in (result, newCache)
```

## 总结

本文档展示了Haskell中字符串算法的完整实现，包括：

1. **字符串匹配**：朴素匹配、KMP、Boyer-Moore算法
2. **编辑距离**：Levenshtein距离、最长公共子序列
3. **压缩算法**：游程编码、Huffman编码
4. **哈希算法**：多项式哈希、Rabin-Karp算法
5. **后缀数组**：后缀数组构建、LCP数组
6. **实际应用**：文本搜索、DNA序列分析
7. **性能优化**：Data.Text优化、并行处理

这些算法展示了Haskell在字符串处理中的优势：

- **类型安全**：编译时保证算法正确性
- **函数式风格**：清晰的算法表达
- **惰性求值**：优化内存使用
- **高阶函数**：抽象算法模式
- **不可变性**：避免副作用，便于并行化

通过这些实现，我们可以看到Haskell不仅适合理论研究，也适合实际的字符串处理和文本分析应用。
