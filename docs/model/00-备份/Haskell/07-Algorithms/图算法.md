# 图算法 - Haskell实现

## 概述

图算法是计算机科学中的核心算法，用于解决图结构上的各种问题。本文档使用Haskell实现常见的图算法，包括图的表示、遍历、最短路径、最小生成树等。

## 图的表示

### 邻接表表示

```haskell
-- 图的邻接表表示
type Graph a = Map a [a]

-- 创建空图
emptyGraph :: Graph a
emptyGraph = Map.empty

-- 添加顶点
addVertex :: Ord a => a -> Graph a -> Graph a
addVertex v g = Map.insertWith (++) v [] g

-- 添加边
addEdge :: Ord a => a -> a -> Graph a -> Graph a
addEdge u v g = Map.insertWith (++) u [v] g

-- 获取顶点的邻居
neighbors :: Ord a => a -> Graph a -> [a]
neighbors v g = Map.findWithDefault [] v g
```

### 邻接矩阵表示

```haskell
-- 邻接矩阵表示
type AdjMatrix = Array (Int, Int) Bool

-- 创建邻接矩阵
createAdjMatrix :: Int -> [(Int, Int)] -> AdjMatrix
createAdjMatrix n edges = 
    array ((0,0), (n-1,n-1)) 
          [((i,j), (i,j) `elem` edges) | i <- [0..n-1], j <- [0..n-1]]

-- 检查边是否存在
hasEdge :: AdjMatrix -> Int -> Int -> Bool
hasEdge matrix u v = matrix ! (u, v)
```

## 图的遍历

### 深度优先搜索 (DFS)

```haskell
-- 深度优先搜索
dfs :: Ord a => Graph a -> a -> [a]
dfs g start = dfsHelper g start Set.empty []

dfsHelper :: Ord a => Graph a -> a -> Set a -> [a] -> [a]
dfsHelper g v visited acc
    | v `Set.member` visited = acc
    | otherwise = v : foldr (dfsHelper g) (Set.insert v visited) (neighbors v g) acc

-- 使用状态单子的DFS
dfsM :: Ord a => Graph a -> a -> State (Set a) [a]
dfsM g v = do
    visited <- get
    if v `Set.member` visited
        then return []
        else do
            put (Set.insert v visited)
            neighbors <- return $ neighbors v g
            rest <- mapM (dfsM g) neighbors
            return (v : concat rest)
```

### 广度优先搜索 (BFS)

```haskell
-- 广度优先搜索
bfs :: Ord a => Graph a -> a -> [a]
bfs g start = bfsHelper g [start] Set.empty []

bfsHelper :: Ord a => Graph a -> [a] -> Set a -> [a] -> [a]
bfsHelper g [] _ acc = reverse acc
bfsHelper g (v:vs) visited acc
    | v `Set.member` visited = bfsHelper g vs visited acc
    | otherwise = bfsHelper g (vs ++ neighbors v g) (Set.insert v visited) (v:acc)

-- 使用队列的BFS
bfsQueue :: Ord a => Graph a -> a -> [a]
bfsQueue g start = bfsQueueHelper g (Queue.singleton start) Set.empty []

bfsQueueHelper :: Ord a => Graph a -> Queue a -> Set a -> [a] -> [a]
bfsQueueHelper g q visited acc = case Queue.viewl q of
    Queue.EmptyL -> reverse acc
    v Queue.:< q' -> 
        if v `Set.member` visited
            then bfsQueueHelper g q' visited acc
            else bfsQueueHelper g (foldr Queue.|> q' (neighbors v g)) 
                                (Set.insert v visited) (v:acc)
```

## 最短路径算法

### Dijkstra算法

```haskell
-- 带权图表示
type WeightedGraph a = Map a [(a, Double)]

-- Dijkstra最短路径算法
dijkstra :: Ord a => WeightedGraph a -> a -> Map a (Double, Maybe a)
dijkstra g start = dijkstraHelper g (Map.singleton start (0, Nothing)) 
                                   (Set.singleton start) 
                                   (Map.delete start g)

dijkstraHelper :: Ord a => WeightedGraph a -> Map a (Double, Maybe a) 
                -> Set a -> WeightedGraph a -> Map a (Double, Maybe a)
dijkstraHelper g distances visited unvisited
    | Map.null unvisited = distances
    | otherwise = 
        let (current, _) = Map.findMin unvisited
            currentDist = fst $ distances Map.! current
            neighbors = Map.findWithDefault [] current g
            newDistances = foldr updateDistance distances neighbors
            updateDistance (neighbor, weight) dists =
                let newDist = currentDist + weight
                    oldDist = fst $ Map.findWithDefault (1/0, Nothing) neighbor dists
                in if newDist < oldDist
                   then Map.insert neighbor (newDist, Just current) dists
                   else dists
        in dijkstraHelper g newDistances (Set.insert current visited) 
                         (Map.delete current unvisited)
```

### Floyd-Warshall算法

```haskell
-- Floyd-Warshall全源最短路径算法
floydWarshall :: Int -> [(Int, Int, Double)] -> Array (Int, Int) Double
floydWarshall n edges = 
    let initial = array ((0,0), (n-1,n-1)) 
                        [((i,j), if i == j then 0 else 1/0) | i <- [0..n-1], j <- [0..n-1]]
        withEdges = foldr (\(u,v,w) arr -> arr // [((u,v), w)]) initial edges
    in foldr (\k arr -> 
        array ((0,0), (n-1,n-1)) 
              [((i,j), min (arr ! (i,j)) (arr ! (i,k) + arr ! (k,j))) 
               | i <- [0..n-1], j <- [0..n-1]]) withEdges [0..n-1]
```

## 最小生成树算法

### Kruskal算法

```haskell
-- 边表示
data Edge a = Edge { from :: a, to :: a, weight :: Double } deriving (Show, Eq, Ord)

-- 并查集数据结构
data UnionFind a = UnionFind (Map a a) (Map a Int) deriving Show

-- 创建并查集
makeUnionFind :: Ord a => [a] -> UnionFind a
makeUnionFind vs = UnionFind (Map.fromList [(v, v) | v <- vs]) 
                              (Map.fromList [(v, 1) | v <- vs])

-- 查找根节点
find :: Ord a => UnionFind a -> a -> a
find (UnionFind parent _) v = 
    let p = parent Map.! v
    in if p == v then v else find (UnionFind parent Map.empty) p

-- 合并集合
union :: Ord a => UnionFind a -> a -> a -> UnionFind a
union (UnionFind parent rank) x y = 
    let rootX = find (UnionFind parent rank) x
        rootY = find (UnionFind parent rank) y
    in if rootX == rootY 
       then UnionFind parent rank
       else let rankX = rank Map.! rootX
                rankY = rank Map.! rootY
            in if rankX < rankY
               then UnionFind (Map.insert rootX rootY parent) rank
               else if rankX > rankY
                    then UnionFind (Map.insert rootY rootX parent) rank
                    else UnionFind (Map.insert rootY rootX parent) 
                                  (Map.insert rootX (rankX + 1) rank)

-- Kruskal算法
kruskal :: Ord a => [Edge a] -> [Edge a]
kruskal edges = 
    let sortedEdges = sort edges
        vertices = nub $ concat [[from e, to e] | e <- edges]
        uf = makeUnionFind vertices
        (mst, _) = foldr addEdge ([], uf) sortedEdges
        addEdge e (mstEdges, uf') = 
            let rootFrom = find uf' (from e)
                rootTo = find uf' (to e)
            in if rootFrom == rootTo
               then (mstEdges, uf')
               else (e:mstEdges, union uf' (from e) (to e))
    in reverse mst
```

### Prim算法

```haskell
-- Prim算法
prim :: Ord a => WeightedGraph a -> a -> [(a, a, Double)]
prim g start = primHelper g (Set.singleton start) [] (Map.delete start g)

primHelper :: Ord a => WeightedGraph a -> Set a -> [(a, a, Double)] 
            -> WeightedGraph a -> [(a, a, Double)]
primHelper g mst edges unvisited
    | Map.null unvisited = edges
    | otherwise = 
        let -- 找到所有跨越MST和未访问顶点的边
            crossingEdges = [(u, v, w) | u <- Set.toList mst, 
                                        (v, w) <- Map.findWithDefault [] u g,
                                        v `Set.notMember` mst]
            -- 选择最小权重的边
            (u, v, w) = minimumBy (comparing (\(_,_,w') -> w')) crossingEdges
        in primHelper g (Set.insert v mst) ((u,v,w):edges) (Map.delete v unvisited)
```

## 拓扑排序

```haskell
-- 拓扑排序
topologicalSort :: Ord a => Graph a -> Either [a] [a]
topologicalSort g = 
    let vertices = Map.keys g
        inDegree = foldr (\v acc -> Map.insert v (inDegreeOf v g) acc) 
                        Map.empty vertices
        inDegreeOf v g = length [u | u <- vertices, v `elem` neighbors u g]
        
        -- Kahn算法
        kahn inDeg = 
            let sources = [v | (v, deg) <- Map.toList inDeg, deg == 0]
            in if null sources
               then if Map.null inDeg 
                    then Right []
                    else Left [] -- 有环
               else let v = head sources
                        newInDeg = foldr (\u acc -> 
                            Map.insert u (inDeg Map.! u - 1) acc) 
                            (Map.delete v inDeg) (neighbors v g)
                        rest = kahn newInDeg
                    in case rest of
                         Left _ -> Left []
                         Right vs -> Right (v:vs)
    in kahn inDegree
```

## 强连通分量

```haskell
-- Kosaraju算法求强连通分量
stronglyConnectedComponents :: Ord a => Graph a -> [[a]]
stronglyConnectedComponents g = 
    let vertices = Map.keys g
        -- 第一次DFS，记录完成时间
        (_, finishTimes) = foldr (\v (visited, times) -> 
            if v `Set.member` visited 
            then (visited, times)
            else let (newVisited, newTimes) = dfsWithTime g v visited times
                 in (newVisited, newTimes)) (Set.empty, []) vertices
        
        -- 构建转置图
        transposeG = foldr (\v acc -> 
            foldr (\u acc' -> addEdge u v acc') acc (neighbors v g)) 
            emptyGraph vertices
        
        -- 按完成时间倒序进行第二次DFS
        sortedVertices = map snd $ sortBy (flip compare) 
                         [(i, v) | (v, i) <- zip vertices finishTimes]
        
        -- 第二次DFS找强连通分量
        (_, sccs) = foldr (\v (visited, components) -> 
            if v `Set.member` visited 
            then (visited, components)
            else let (newVisited, component) = dfsComponent transposeG v visited []
                 in (newVisited, component:components)) (Set.empty, []) sortedVertices
    in sccs

-- DFS记录完成时间
dfsWithTime :: Ord a => Graph a -> a -> Set a -> [Int] -> (Set a, [Int])
dfsWithTime g v visited times = 
    if v `Set.member` visited 
    then (visited, times)
    else let newVisited = Set.insert v visited
             (finalVisited, finalTimes) = foldr (\u (vis, ts) -> 
                 dfsWithTime g u vis ts) (newVisited, times) (neighbors v g)
         in (finalVisited, length finalTimes:finalTimes)

-- DFS找强连通分量
dfsComponent :: Ord a => Graph a -> a -> Set a -> [a] -> (Set a, [a])
dfsComponent g v visited component = 
    if v `Set.member` visited 
    then (visited, component)
    else let newVisited = Set.insert v visited
             (finalVisited, finalComponent) = foldr (\u (vis, comp) -> 
                 dfsComponent g u vis comp) (newVisited, v:component) (neighbors v g)
         in (finalVisited, finalComponent)
```

## 网络流算法

### Ford-Fulkerson最大流算法

```haskell
-- 网络流图表示
type FlowGraph = Array (Int, Int) Int

-- Ford-Fulkerson最大流算法
fordFulkerson :: Int -> Int -> Int -> [(Int, Int, Int)] -> Int
fordFulkerson n source sink edges = 
    let -- 构建容量矩阵
        capacity = array ((0,0), (n-1,n-1)) 
                         [((i,j), 0) | i <- [0..n-1], j <- [0..n-1]]
        capacity' = foldr (\(u,v,c) arr -> arr // [((u,v), c)]) capacity edges
        
        -- 寻找增广路径
        findAugmentingPath :: FlowGraph -> Int -> Int -> Maybe [Int]
        findAugmentingPath cap s t = 
            let visited = array (0, n-1) [(i, False) | i <- [0..n-1]]
                dfs u path = 
                    if u == t 
                    then Just (reverse (u:path))
                    else let neighbors = [v | v <- [0..n-1], 
                                             cap ! (u,v) > 0,
                                             not (visited ! v)]
                         in foldr (\v acc -> case acc of
                             Nothing -> do
                                 let visited' = visited // [(v, True)]
                                 path' <- dfs v (u:path)
                                 return path'
                             Just p -> return p) Nothing neighbors
            in dfs s []
        
        -- 计算路径上的最小容量
        minCapacity :: FlowGraph -> [Int] -> Int
        minCapacity cap path = 
            minimum [cap ! (u,v) | (u,v) <- zip path (tail path)]
        
        -- 更新残余网络
        updateResidual :: FlowGraph -> [Int] -> Int -> FlowGraph
        updateResidual cap path flow = 
            foldr (\(u,v) arr -> 
                arr // [((u,v), arr ! (u,v) - flow),
                       ((v,u), arr ! (v,u) + flow)]) 
                cap (zip path (tail path))
        
        -- 主循环
        maxFlowLoop cap = 
            case findAugmentingPath cap source sink of
                Nothing -> 0
                Just path -> 
                    let flow = minCapacity cap path
                        newCap = updateResidual cap path flow
                    in flow + maxFlowLoop newCap
    in maxFlowLoop capacity'
```

## 实际应用示例

### 社交网络分析

```haskell
-- 社交网络图
type SocialNetwork = Graph String

-- 计算用户的影响力（基于度中心性）
influence :: SocialNetwork -> String -> Double
influence network user = 
    let neighbors = neighbors user network
        totalUsers = Map.size network
    in fromIntegral (length neighbors) / fromIntegral totalUsers

-- 找到最受欢迎的用户
mostPopular :: SocialNetwork -> String
mostPopular network = 
    fst $ maximumBy (comparing snd) 
         [(user, influence network user) | user <- Map.keys network]

-- 计算两个用户之间的最短路径
shortestPath :: SocialNetwork -> String -> String -> [String]
shortestPath network start end = 
    let distances = dijkstra (convertToWeighted network) start
        convertToWeighted g = Map.map (\neighbors -> 
            [(n, 1.0) | n <- neighbors]) g
    in case Map.lookup end distances of
         Just (_, Just prev) -> shortestPath network start prev ++ [end]
         _ -> []
```

### 路由算法

```haskell
-- 网络拓扑
type NetworkTopology = WeightedGraph String

-- 计算最优路由
optimalRoute :: NetworkTopology -> String -> String -> [String]
optimalRoute network start end = 
    let distances = dijkstra network start
        buildPath current path = 
            case Map.lookup current distances of
                Just (_, Just prev) -> buildPath prev (current:path)
                _ -> start:path
    in reverse $ buildPath end []

-- 网络负载均衡
loadBalance :: NetworkTopology -> String -> String -> [String] -> [String]
loadBalance network start end alternativePaths = 
    let routes = optimalRoute network start end : alternativePaths
        routeLoads = map (\route -> (route, calculateLoad network route)) routes
    in map fst $ sortBy (comparing snd) routeLoads

calculateLoad :: NetworkTopology -> [String] -> Double
calculateLoad network route = 
    sum [w | (u, v) <- zip route (tail route), 
            (v', w) <- Map.findWithDefault [] u network, 
            v' == v]
```

## 性能优化

### 使用ST单子优化图算法

```haskell
-- 使用ST单子优化Dijkstra算法
dijkstraST :: Ord a => WeightedGraph a -> a -> Map a (Double, Maybe a)
dijkstraST g start = runST $ do
    distances <- newSTRef (Map.singleton start (0, Nothing))
    visited <- newSTRef Set.empty
    unvisited <- newSTRef (Map.delete start g)
    
    let loop = do
            unv <- readSTRef unvisited
            if Map.null unv
                then readSTRef distances
                else do
                    let (current, _) = Map.findMin unv
                    dists <- readSTRef distances
                    let currentDist = fst $ dists Map.! current
                        neighbors = Map.findWithDefault [] current g
                        newDistances = foldr updateDistance dists neighbors
                        updateDistance (neighbor, weight) dists' =
                            let newDist = currentDist + weight
                                oldDist = fst $ Map.findWithDefault (1/0, Nothing) neighbor dists'
                            in if newDist < oldDist
                               then Map.insert neighbor (newDist, Just current) dists'
                               else dists'
                    writeSTRef distances newDistances
                    writeSTRef visited (Set.insert current =<< readSTRef visited)
                    writeSTRef unvisited (Map.delete current unv)
                    loop
    loop
```

## 总结

本文档展示了Haskell中图算法的完整实现，包括：

1. **图的表示**：邻接表和邻接矩阵
2. **图的遍历**：DFS和BFS
3. **最短路径**：Dijkstra和Floyd-Warshall算法
4. **最小生成树**：Kruskal和Prim算法
5. **拓扑排序**：Kahn算法
6. **强连通分量**：Kosaraju算法
7. **网络流**：Ford-Fulkerson算法
8. **实际应用**：社交网络分析和路由算法
9. **性能优化**：使用ST单子优化

这些算法展示了Haskell在算法实现中的优势：

- **类型安全**：编译时保证算法正确性
- **函数式风格**：清晰的算法表达
- **不可变性**：避免副作用，便于并行化
- **高阶函数**：抽象算法模式
- **惰性求值**：优化计算性能

通过这些实现，我们可以看到Haskell不仅适合理论研究，也适合实际的算法实现和系统开发。
