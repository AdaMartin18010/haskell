# Haskell 金融应用

## 概述

本文档介绍Haskell在金融领域的应用，包括量化金融、风险管理、区块链技术等。Haskell的类型安全和函数式特性使其特别适合金融建模和计算。

## 目录

1. [量化金融](#量化金融)
2. [风险管理](#风险管理)
3. [区块链技术](#区块链技术)
4. [金融建模](#金融建模)
5. [实际案例](#实际案例)

## 量化金融

### 期权定价模型

```haskell
-- 布莱克-斯科尔斯期权定价模型
module Financial.Options where

import Data.Vector
import Control.Monad.State

-- 期权类型
data OptionType = Call | Put deriving (Show, Eq)

-- 期权参数
data OptionParams = OptionParams
    { spotPrice :: Double      -- 当前价格
    , strikePrice :: Double    -- 执行价格
    , timeToMaturity :: Double -- 到期时间
    , riskFreeRate :: Double   -- 无风险利率
    , volatility :: Double     -- 波动率
    } deriving (Show)

-- 布莱克-斯科尔斯公式
blackScholes :: OptionType -> OptionParams -> Double
blackScholes Call params = 
    spotPrice params * normCDF d1 - 
    strikePrice params * exp (-riskFreeRate params * timeToMaturity params) * normCDF d2
  where
    d1 = (log (spotPrice params / strikePrice params) + 
          (riskFreeRate params + volatility params^2 / 2) * timeToMaturity params) / 
         (volatility params * sqrt (timeToMaturity params))
    d2 = d1 - volatility params * sqrt (timeToMaturity params)

blackScholes Put params = 
    strikePrice params * exp (-riskFreeRate params * timeToMaturity params) * normCDF (-d2) - 
    spotPrice params * normCDF (-d1)
  where
    d1 = (log (spotPrice params / strikePrice params) + 
          (riskFreeRate params + volatility params^2 / 2) * timeToMaturity params) / 
         (volatility params * sqrt (timeToMaturity params))
    d2 = d1 - volatility params * sqrt (timeToMaturity params)

-- 标准正态分布累积分布函数
normCDF :: Double -> Double
normCDF x = 0.5 * (1 + erf (x / sqrt 2))
  where
    erf z = sign * (1 - exp (-z*z) / sqrt pi * 
            (1/2 + 1/2 * z*z + 3/4 * z^4 + 15/8 * z^6))
      where
        sign = if z >= 0 then 1 else -1
        pi = 3.141592653589793
```

### 蒙特卡洛模拟

```haskell
-- 蒙特卡洛期权定价
module Financial.MonteCarlo where

import System.Random
import Control.Monad.State
import Data.Vector

-- 随机数生成器状态
type RandomState = State StdGen

-- 生成标准正态分布随机数
normalRandom :: RandomState Double
normalRandom = do
    gen <- get
    let (u1, gen1) = randomR (0, 1) gen
        (u2, gen2) = randomR (0, 1) gen1
        z = sqrt (-2 * log u1) * cos (2 * pi * u2)
    put gen2
    return z
  where
    pi = 3.141592653589793

-- 几何布朗运动路径
geometricBrownianMotion :: Double -> Double -> Double -> Double -> Int -> RandomState [Double]
geometricBrownianMotion s0 mu sigma t n = do
    let dt = t / fromIntegral n
    path <- replicateM n normalRandom
    return $ scanl (\s dz -> s * exp ((mu - sigma^2/2) * dt + sigma * sqrt dt * dz)) s0 path

-- 蒙特卡洛期权定价
monteCarloOption :: OptionType -> OptionParams -> Int -> RandomState Double
monteCarloOption optType params nPaths = do
    let t = timeToMaturity params
        r = riskFreeRate params
        s0 = spotPrice params
        k = strikePrice params
    
    payoffs <- replicateM nPaths $ do
        path <- geometricBrownianMotion s0 r (volatility params) t 252
        let finalPrice = last path
            payoff = case optType of
                Call -> max 0 (finalPrice - k)
                Put -> max 0 (k - finalPrice)
        return payoff
    
    let avgPayoff = sum payoffs / fromIntegral nPaths
    return $ avgPayoff * exp (-r * t)
```

## 风险管理

### VaR (Value at Risk) 计算

```haskell
-- 风险价值计算
module Financial.RiskManagement where

import Data.Vector
import Data.List (sort)
import Statistics.Distribution.Normal

-- 投资组合
data Portfolio = Portfolio
    { positions :: [(String, Double)]  -- (资产, 权重)
    , returns :: Vector Double         -- 历史收益率
    } deriving (Show)

-- 计算投资组合收益率
portfolioReturns :: Portfolio -> Vector Double
portfolioReturns portfolio = 
    let weights = V.fromList $ map snd (positions portfolio)
        assetReturns = V.fromList [returns portfolio] -- 简化，实际应该是矩阵
    in V.zipWith (*) weights assetReturns

-- 参数化VaR
parametricVaR :: Portfolio -> Double -> Double -> Double
parametricVaR portfolio confidenceLevel timeHorizon = 
    let returns = portfolioReturns portfolio
        mean = V.sum returns / fromIntegral (V.length returns)
        stdDev = sqrt $ V.sum (V.map (\r -> (r - mean)^2) returns) / fromIntegral (V.length returns - 1)
        zScore = quantile (normalDistr mean stdDev) (1 - confidenceLevel)
    in zScore * sqrt timeHorizon

-- 历史模拟VaR
historicalVaR :: Portfolio -> Double -> Double
historicalVaR portfolio confidenceLevel = 
    let returns = portfolioReturns portfolio
        sortedReturns = V.toList $ V.sort returns
        index = floor $ confidenceLevel * fromIntegral (length sortedReturns)
    in sortedReturns !! index

-- 蒙特卡洛VaR
monteCarloVaR :: Portfolio -> Double -> Int -> RandomState Double
monteCarloVaR portfolio confidenceLevel nSimulations = do
    let returns = portfolioReturns portfolio
        mean = V.sum returns / fromIntegral (V.length returns)
        stdDev = sqrt $ V.sum (V.map (\r -> (r - mean)^2) returns) / fromIntegral (V.length returns - 1)
    
    simulatedReturns <- replicateM nSimulations normalRandom
    let portfolioReturns = map (\r -> mean + stdDev * r) simulatedReturns
        sortedReturns = sort portfolioReturns
        index = floor $ confidenceLevel * fromIntegral nSimulations
    
    return $ sortedReturns !! index
```

### 压力测试

```haskell
-- 压力测试框架
module Financial.StressTesting where

import Data.Vector
import Control.Monad.State

-- 压力情景
data StressScenario = StressScenario
    { scenarioName :: String
    , marketShock :: Double      -- 市场冲击
    , volatilityShock :: Double  -- 波动率冲击
    , correlationShock :: Double -- 相关性冲击
    } deriving (Show)

-- 压力测试结果
data StressTestResult = StressTestResult
    { scenario :: StressScenario
    , portfolioValue :: Double
    , loss :: Double
    , var :: Double
    } deriving (Show)

-- 执行压力测试
runStressTest :: Portfolio -> [StressScenario] -> [StressTestResult]
runStressTest portfolio scenarios = 
    map (\scenario -> 
        let shockedPortfolio = applyStressScenario portfolio scenario
            currentValue = calculatePortfolioValue portfolio
            stressedValue = calculatePortfolioValue shockedPortfolio
            loss = currentValue - stressedValue
            var = parametricVaR shockedPortfolio 0.95 1
        in StressTestResult scenario stressedValue loss var
    ) scenarios

-- 应用压力情景
applyStressScenario :: Portfolio -> StressScenario -> Portfolio
applyStressScenario portfolio scenario = 
    portfolio { returns = V.map (\r -> r * (1 + marketShock scenario)) (returns portfolio) }
```

## 区块链技术

### 智能合约

```haskell
-- 智能合约框架
module Blockchain.SmartContracts where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Time
import Control.Monad.State

-- 账户
data Account = Account
    { address :: String
    , balance :: Integer
    , nonce :: Integer
    } deriving (Show, Eq)

-- 交易
data Transaction = Transaction
    { from :: String
    , to :: String
    , value :: Integer
    , data_ :: String
    , nonce :: Integer
    } deriving (Show)

-- 区块链状态
data BlockchainState = BlockchainState
    { accounts :: Map String Account
    , blockNumber :: Integer
    , timestamp :: UTCTime
    } deriving (Show)

-- 智能合约
class SmartContract a where
    execute :: a -> Transaction -> State BlockchainState Bool
    validate :: a -> Transaction -> State BlockchainState Bool

-- 简单代币合约
data TokenContract = TokenContract
    { name :: String
    , symbol :: String
    , totalSupply :: Integer
    , balances :: Map String Integer
    , allowances :: Map (String, String) Integer
    } deriving (Show)

instance SmartContract TokenContract where
    validate contract tx = do
        state <- get
        let fromAccount = Map.lookup (from tx) (accounts state)
        case fromAccount of
            Nothing -> return False
            Just acc -> return (nonce acc == nonce tx)
    
    execute contract tx = do
        case tx of
            Transfer{} -> executeTransfer contract tx
            Approve{} -> executeApprove contract tx
            _ -> return False

-- 转账操作
data Transfer = Transfer
    { recipient :: String
    , amount :: Integer
    } deriving (Show)

executeTransfer :: TokenContract -> Transaction -> State BlockchainState Bool
executeTransfer contract tx = do
    state <- get
    let fromBalance = Map.findWithDefault 0 (from tx) (balances contract)
        toBalance = Map.findWithDefault 0 (to tx) (balances contract)
        amount = value tx
    
    if fromBalance >= amount
        then do
            let newBalances = Map.insert (from tx) (fromBalance - amount) 
                        $ Map.insert (to tx) (toBalance + amount) (balances contract)
            put $ state { accounts = updateAccountBalance state (from tx) (-amount) }
            return True
        else return False

-- 更新账户余额
updateAccountBalance :: BlockchainState -> String -> Integer -> Map String Account
updateAccountBalance state addr delta = 
    case Map.lookup addr (accounts state) of
        Nothing -> Map.insert addr (Account addr delta 0) (accounts state)
        Just acc -> Map.insert addr (acc { balance = balance acc + delta }) (accounts state)
```

### 共识算法

```haskell
-- 共识算法实现
module Blockchain.Consensus where

import Data.Vector
import Control.Monad.State
import System.Random

-- 节点
data Node = Node
    { nodeId :: String
    , stake :: Double
    , isValidator :: Bool
    } deriving (Show)

-- 区块
data Block = Block
    { blockNumber :: Integer
    , parentHash :: String
    , transactions :: [Transaction]
    , timestamp :: UTCTime
    , validator :: String
    } deriving (Show)

-- 权益证明 (PoS)
data ProofOfStake = ProofOfStake
    { validators :: [Node]
    , totalStake :: Double
    , currentValidator :: String
    } deriving (Show)

-- 选择下一个验证者
selectNextValidator :: ProofOfStake -> RandomState String
selectNextValidator pos = do
    let validators = filter isValidator (validators pos)
        totalStake = sum $ map stake validators
        weights = map (\v -> stake v / totalStake) validators
    
    r <- randomR (0, 1)
    return $ selectByWeight validators weights r

-- 按权重选择
selectByWeight :: [Node] -> [Double] -> Double -> String
selectByWeight nodes weights r = 
    let cumulative = scanl1 (+) weights
        index = length $ takeWhile (< r) cumulative
    in nodeId (nodes !! index)

-- 验证区块
validateBlock :: Block -> [Transaction] -> Bool
validateBlock block txs = 
    length (transactions block) == length txs &&
    all validateTransaction (transactions block)

-- 验证交易
validateTransaction :: Transaction -> Bool
validateTransaction tx = 
    value tx >= 0 &&
    length (from tx) > 0 &&
    length (to tx) > 0
```

## 金融建模

### 利率模型

```haskell
-- 利率模型
module Financial.InterestRateModels where

import Data.Vector
import Control.Monad.State

-- Hull-White模型
data HullWhiteModel = HullWhiteModel
    { alpha :: Double  -- 均值回归速度
    , sigma :: Double  -- 波动率
    , initialRate :: Double
    } deriving (Show)

-- 利率路径
interestRatePath :: HullWhiteModel -> Double -> Int -> RandomState [Double]
interestRatePath model t n = do
    let dt = t / fromIntegral n
    path <- replicateM n normalRandom
    return $ scanl (\r dz -> 
        r + alpha model * (initialRate model - r) * dt + 
        sigma model * sqrt dt * dz) (initialRate model) path

-- 零息债券定价
zeroCouponBond :: HullWhiteModel -> Double -> Double -> Double
zeroCouponBond model t maturity = 
    let r = initialRate model
        a = alpha model
        s = sigma model
        b = (1 - exp (-a * maturity)) / a
        a_t = (b - maturity) * (s^2 / (2 * a^2)) - (s^2 * b^2) / (4 * a)
    in exp (-r * b + a_t)
```

### 信用风险模型

```haskell
-- 信用风险模型
module Financial.CreditRisk where

import Data.Vector
import Control.Monad.State

-- Merton模型
data MertonModel = MertonModel
    { assetValue :: Double
    , debtValue :: Double
    , volatility :: Double
    , riskFreeRate :: Double
    , timeToMaturity :: Double
    } deriving (Show)

-- 违约概率
defaultProbability :: MertonModel -> Double
defaultProbability model = 
    let v = assetValue model
        d = debtValue model
        sigma = volatility model
        r = riskFreeRate model
        t = timeToMaturity model
        
        d1 = (log (v / d) + (r + sigma^2 / 2) * t) / (sigma * sqrt t)
        d2 = d1 - sigma * sqrt t
    in normCDF (-d2)

-- 信用价差
creditSpread :: MertonModel -> Double
creditSpread model = 
    let pd = defaultProbability model
        t = timeToMaturity model
        r = riskFreeRate model
    in -log (1 - pd) / t - r
```

## 实际案例

### 高频交易系统

```haskell
-- 高频交易系统
module Financial.HighFrequencyTrading where

import Data.Vector
import Control.Concurrent
import Control.Monad.State

-- 市场数据
data MarketData = MarketData
    { symbol :: String
    , price :: Double
    , volume :: Integer
    , timestamp :: UTCTime
    } deriving (Show)

-- 交易信号
data TradingSignal = Buy | Sell | Hold deriving (Show, Eq)

-- 策略
class TradingStrategy a where
    generateSignal :: a -> MarketData -> TradingSignal
    calculatePosition :: a -> MarketData -> Integer

-- 移动平均策略
data MovingAverageStrategy = MovingAverageStrategy
    { shortPeriod :: Int
    , longPeriod :: Int
    , prices :: Vector Double
    } deriving (Show)

instance TradingStrategy MovingAverageStrategy where
    generateSignal strategy data_ = 
        let shortMA = calculateMA (prices strategy) (shortPeriod strategy)
            longMA = calculateMA (prices strategy) (longPeriod strategy)
        in if shortMA > longMA then Buy else Sell
    
    calculatePosition strategy data_ = 
        case generateSignal strategy data_ of
            Buy -> 100
            Sell -> -100
            Hold -> 0

-- 计算移动平均
calculateMA :: Vector Double -> Int -> Double
calculateMA prices period = 
    if V.length prices >= period
        then V.sum (V.take period prices) / fromIntegral period
        else 0
```

### 风险管理仪表板

```haskell
-- 风险管理仪表板
module Financial.RiskDashboard where

import Data.Vector
import Data.Time
import Control.Monad.State

-- 风险指标
data RiskMetrics = RiskMetrics
    { var :: Double
    , expectedShortfall :: Double
    , sharpeRatio :: Double
    , maxDrawdown :: Double
    } deriving (Show)

-- 投资组合风险
calculatePortfolioRisk :: Portfolio -> RiskMetrics
calculatePortfolioRisk portfolio = 
    let returns = portfolioReturns portfolio
        var = parametricVaR portfolio 0.95 1
        es = expectedShortfall portfolio 0.95
        sharpe = sharpeRatio portfolio
        mdd = maxDrawdown portfolio
    in RiskMetrics var es sharpe mdd

-- 预期损失
expectedShortfall :: Portfolio -> Double -> Double
expectedShortfall portfolio confidenceLevel = 
    let returns = portfolioReturns portfolio
        var = parametricVaR portfolio confidenceLevel 1
        tailReturns = V.filter (<= var) returns
    in V.sum tailReturns / fromIntegral (V.length tailReturns)

-- 夏普比率
sharpeRatio :: Portfolio -> Double
sharpeRatio portfolio = 
    let returns = portfolioReturns portfolio
        mean = V.sum returns / fromIntegral (V.length returns)
        stdDev = sqrt $ V.sum (V.map (\r -> (r - mean)^2) returns) / fromIntegral (V.length returns - 1)
        riskFreeRate = 0.02 -- 假设无风险利率
    in (mean - riskFreeRate) / stdDev

-- 最大回撤
maxDrawdown :: Portfolio -> Double
maxDrawdown portfolio = 
    let returns = portfolioReturns portfolio
        cumulative = V.scanl1 (*) (V.map (1 +) returns)
        runningMax = V.scanl1 max cumulative
        drawdowns = V.zipWith (\cum max_ -> (cum - max_) / max_) cumulative runningMax
    in V.minimum drawdowns
```

## 总结

Haskell在金融应用中的优势：

1. **类型安全**: 防止运行时错误，提高系统可靠性
2. **函数式编程**: 纯函数便于测试和验证
3. **高性能**: 编译优化和惰性求值
4. **并发安全**: 软件事务内存和不可变数据结构
5. **形式化验证**: 支持程序正确性证明

这些特性使Haskell特别适合构建高可靠性、高性能的金融系统。

---

**相关链接**:

- [量化金融理论](../../05-Industry-Domains/01-FinTech/量化金融.md)
- [风险管理理论](../../05-Industry-Domains/01-FinTech/风险管理.md)
- [区块链技术](../05-Industry-Domains/01-FinTech/区块链.md)
